1. **网络分层模型**
网络分层模型，现在常见的有三种，第一种就是比较通用的一种理论分层模型，叫OSI，有7层。第二种是TCP/IP的五层协议，也是目前来说比较通用的网络设计模型，还有一种更简化的4层的TCP/IP模型。五层模型是将7层模型中的应用层、表示层、会话层合并为了应用层，四层模型就是将5层模型中的数据链路层和物理层合并成网络接口层。

OSI的7层模型：
* 应用层，是负责给应用程序提供服务的，里面包含了大量的应用程序相关的协议：
  * http
  * https
  * dns
  * ftp
  * sftp
  * telnet
  * ssh
* 表示层：负责将应用程序传输的数据翻译表征成统一的二进制数据，以方便一个系统的应用程序传出的数据，能够被另一个系统的应用程序传输的数据所接受并理解，数据的压缩、加密、解密都是这一层的工作
* 会话层：负责建立、控制、终止应用程序之间的会话
* 传输层：负责提供应用层实体端到端的传输数据能力，负责保证数据的传输顺序和可靠或不可靠交付，包括流量控制、拥塞控制都是这一层，这里面包含的最主要的协议就是TCP和UDP。这一层还可以实现复用和分用，复用就是多个应用程序共同使用传输层来传输数据，分用就是传输层来分发数据给不同的应用程序。应用层传来的数据，加传输层的头部控制信息后传递给网络层。
* 网络层：负责主机到主机的通信问题，最主要的协议IP协议，给每个主机赋予一个IP地址，给传输层传来的数据匹配正确的路由和IP地址，正确地运送的目的端，这里最主要的协议就是IP，路由器就是典型的网络层的物理设备。传输层传来的数据会被加上IP报文，传递给数据链路层
* 数据链路层：负责物理机到网络的通信问题，里面最重要的一层就是MAC层，会把报文分装成数据帧，添加上MAC头部传送给物理层，
* 物理层：将数据帧转换为电信号，通过物理介质控制比特流，比如电平、电压、帧脚之类的。

2. TCP和UDP
UDP，User Datagram Protocol，用户数据协议，主要特点包含：
* 无连接的，传输数据是不需要建立连接的，在传输数据之后也不需要去释放连接，在传送的过程中，应用层的数据只要加一个UDP头部就传给网络层了
* 尽最大努力交付，但不是可靠交付，不备份数据，也不关心对方是否正确接收
* 是一个一对一，一对多，多对多的交互通信
* 面向报文的，发送方给传来的数据添加首部交给网络层，既不合并，也不拆分，拿到网络层传来的报文，只需要拆解UDP首部，就还给应用层
* 没有拥塞控制，允许在网络情况差，拥塞的情况下丢失一部分数据
* UDP的首部只占8个字节，包含源端口，目的端口，长度和检验和就没得了

TCP，Transimission Control Protocol，传输控制协议，主要特点包含：
* 面向连接的，在发送数据之前必须要建立连接，在传送完之后要释放连接
* 是保证可靠交付的，保证数据按序到达，保证数据的无差错、不跌势，是通过TCP首部的数据序号来保证的
* 是一个一对一的交互通信
* 全双工通信，发送方可以发送数据，也可以接收数据，也都可以缓存双向传输的数据
* 面向字节流的，TCP把引用程序叫下来的数据当做一连串无结构的字节流，并不理解字节流的含义，但保证接收方收到的和应用程序发送的一直
* 有拥塞控制

TCP的报文
* 源端口和目的端口
* 报文序号SEQ
* 确认号ACK
* 数据偏移
* 保留
  * FIN
  * SYN
  * URG
  * ACK
  * RST
  * PSH
* 窗口
* 检验和
* 紧急指针

TCP连接
* 建立连接
  * 发送方发送一个报文，设置SYN = 1， seq = u
  * 接收方收到报文之后，设置ACK = u + 1，seq = v，SYN = 1
  * 发送方收到确认之后，设置ACK= v + 1，seq = u + 1，SYN = 1
* 终止连接
  * 发送方发送一个报文，设置FIN = 1，seq = u
  * 接收方收到报文后，返回一个确认报文，ACK=u+1, seq=v
  * 接收方也没有数据传输了，就会返回一个释放连接的报文，FIN=1, seq=w, ACK = u+1
  * 发送方收到后返回确认，ACK=w+1, seq=u+1, FIN=1

可靠传输的保证
* 每发完一个分组，就会等待确认，确认收到了才会发送下一个报文
* 如果发送方传输给接收方，会设置一个计时器，超时没有收到确认就会重传数据
* 如果收到重复的数据，就会丢弃重复数据，如果收到重复的确认，就会什么都不做

拥塞控制：发送方会维持一个拥塞窗口的状态变量，会根据网络拥塞状态动态变化，发送方会让自己的发送窗口等于拥塞窗口，当发送方没有按时收到确认报文，推断网络出现拥塞，此时发送方就可以调整拥塞窗口变小，减轻网络的负担
* 慢开始和拥塞避免：慢开始就是最开始将拥塞窗口设为1，只发送一个报文段，然后之后在收到确认报文之后，没收到一次，就将拥塞窗口设为之前的2倍，逐次增大。拥塞避免就是让拥塞窗口每次都加1，慢慢增大。实际应用中就是设置一个慢开始门限，先用慢开始的算法较快的增大拥塞窗口的数值，等到慢开始门限就逐一增大，遇到网络拥塞的时候，就将慢开始门限设为之前的一半，拥塞窗口值设为1，然后再轮回增大拥塞窗口值
* 快重传和快恢复：快重传，是发送过程中，接收方没有按序收到数据，中间有遗漏，就每次都重发缺漏的报文段前一段的确认报文，连续几次收到相同的确认报文，就会立刻重发，而不至于等待倒计时，提高吞吐量。快恢复就是在发送发重发的时候，同时要讲拥塞窗口值减半，然后用拥塞避免算法逐次增大拥塞窗口

1. HTTP和HTTPS
http报文 请求行、请求首部、通用首部、实体首部
http支持的方法：
* get:
* post
* put
* head
* delete
* trace

get和post的区别
* get数据放链接，长度有限制，请求中产生一个数据包，post数据放请求体，产生两个数据包
* get请求数据，post传输数据
* get可以回退，可以收藏，可以刷新，post不能，刷新要重新提交表单
* post更安全

http状态码：
* 1xx：请求正在处理
* 2xx：请求正常处理完毕
* 3xx：需要附加操作才能完成请求
  * 302：临时重定向
  * 301：永久重定向
  * 304：服务器没有发生变量，可以用浏览器缓存
* 4xx：服务器无法处理请求
  * 404：资源没找到
  * 403：拒绝访问
  * 401：需要认证
  * 400：存在语法错误
* 5xx：服务器出现错误
  * 500：服务器内部出现问题

http缓存：
* 强制缓存：expires是一个绝对的过期时间，cache-control,
  * max-age
  * private
  * public
  * no-store
  * no-cache
* 协商缓存：last-modified, if-modified-since,   e-tag, if-not-match

http版本
* 1.0：get、post、head请求，任何格式的内容都可以发送，不止可以传输文字，还可以传输图片。视频和二进制文件；短连接模式，每次都要建立连接，且每次都只能传送全部的页面数据，只有expires,if-modified-since作为缓存标准

* 1.1：引入持久连接，默认不关闭，复用连接，通过首部keep-alive来设置，引入管道机制，同一个连接可以发送多个请求；e-tag, if-not-match, cache-control来控制缓存，支持断点续传，新增put.delete.options

* 2.0：二进制分帧，用二进制数据进行传输，支持多路复用，一个TCP连接可以传输多个连接，压缩头部头部，会将js.img.css,html一起合并发送给客户端

* 3.0：在UDP协议上实现可靠传输、有序交付、多路复用、加密的功能。uuid不变不必重新建立连接 

代理：
* 正向代理：客户端向代理发起请求，指定目标服务器，活的请求结果后将结果返回给客户端
* 反向代理：客户端向代理发起请求，并不必指定目标服务器，由代理判断请求的目标服务器，然后发起请求，不必知道服务端是哪边

http的状态：无状态，明文传输，安全问题，队头阻塞

https: 将通信层换为SSL，HTTP先向SSL通信，SSL与TCP进行通信，是HTTP+SSl

加密机制：
* 对称加密：通信两端的加密算法是一样的
* 非对称加密：A与B进行通信，是A先用B的公钥进行加密，然后B用私钥进行解密

https用混合加密的方法：非对称加密对二者的通信秘钥进行加密，然后在正常的通信中用对称通信进行通信。SSL握手过程：
* A与B通信，A将自己的SSL版本、支持的加密算法发给B，并且生成一个随机数1
* B收到后，生成随机数2，然后将选定的加密算法、CA证书，都发给A
* A收到后，先验证CA证书，有效的话，就会生成随机数3，然后用B的公钥加密发送给B
* B收到后，用自己的私钥解密，解密后，用随机数1,2,3生成会话秘钥，之后就用对称加密进行解密

CA证书：数字签名hash, hash算法，提供服务的服务商的信息
验证的方法：
* 用公钥对hash值进行解密，得到一个值
* 用hash算法进行加密，得到一个值，两个值一致就可以

1. 浏览器缓存
cookie: 4k左右，用于保存一些操作记录，比如购物车列表，收藏列表，用户登陆信息
session：存在服务端，没有大小限制，为每次对话建立一个Session缓存，会话结束之后就清除了，然后把一个id作为cookie传给客户端

2. 浏览器网络安全
* XSS共计，网页注入脚本，一种是通过修改页面内容注入，第二种是输入框注入数据库。可以通过xss白名单过滤进行防御
* CSRF攻击：让一个已经登陆的用户从登陆的网页跳转到攻击者的网页，攻击者就可以拿到登陆的网页的cookie，然后直接调用里面的接口就可以达到非法的目的
  * 可以校验referer
  * cookie可以设置http-only，值允许服务端使用
  * 接口设置跨域
  * get请求不用于数据修改
* 点击劫持，嵌套一个iframe，设置为透明，这样点击页面的时候也就点击了透明的iframe达到非法目的。X-Frame-Options用来表明页面内是否允许嵌套iframe

