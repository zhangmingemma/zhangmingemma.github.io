<!-- ---
title: 计算机网络系列之浏览器缓存及安全
date: 2022-10-18
tags: 计算机网络
set: Network
--- -->

## 一. 网络安全问题

JS常见的网络安全问题：

* **XSS攻击**：XSS 攻击全称跨站脚本攻击，是利用html可以执行<script>alert(1)</script>的特性，想尽办法将脚本注入页面中的攻击手段。XSS攻击有两种，一种是通过修改浏览器URL导致脚本被注入到页面，另一种是通过输入框将脚本代码注入数据库。前面一种会被chrome浏览器自动防御攻击（但最好还是手动也防御一下），后面一种则需要我们手动防御，推荐使用'xss'库的白名单过滤防御方法

* **CSRF攻击**：源于Web的隐式身份验证机制！Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。例如网站有一个关注接口，那登陆网站的用户只要进入我的页面，我就可以拿到登陆的Cookie，如果我在我的页面调用了这条接口，就可以实现自动关注。CSRF攻击的问题一般是由服务端解决：
  * Get请求不用于数据的修改
  * Cookie设为HTTP Only
  * 接口设置跨域
  * 请求时附带验证信息
  * 校验Referer和Origin

* **点击劫持**：将Iframe嵌入页面，并设置为透明。当用户点击某个位置时，实际上也点击了透明的Iframe。这种需要在HTTP响应头添加`X-Frame-Options`用来表明页面内是否允许Iframe嵌套，以及嵌套的域名范围

## 二. 浏览器服务端交互缓存

**Cookie**
HTTP是无状态的，不记录连接的双方，如果每次忘记上一次的操作，会消耗成本。Cookie是浏览器访问服务器后，服务器返回的一段数据`Set-Cookie`，以后每次请求浏览器都要带上这段数据`Cookie`。最常见的应用场景就是永久登录，用户登录后给一个用户的特殊标识，每次请求都带上，服务器就方便识别用户。再比如一些个性化的设置、浏览器的行为跟踪、以及其他会话状态管理数据。Cookie的内容包含：
* Name & Value: Name标识Cookie的名称，服务器通过这个值来获取Cookie的值Value
* Domain & Path: 标识可以访问此Cookie的域名，Path代表可以访问此Cookie的路径
* Expires & Max-Age: 标识Cookie的失效时间，不设置的话默认是Session，意思是跟随会话一起失效
* Size: 代表Name+Value的字符长度，不同浏览器对Cookie的支持个数和尺寸都不同，大约都是4k左右
* Http-Only: 若该属性为true，则只在请求头中带有此Cookie，不可以使用JS的`document.cookie`来获取cookie
* Secure: 只能使用https来传递这个字段

**Session**
Cookie在浏览器中是用户可见的，并且存储大小也有限制，还可以随意的修改，很不安全。Session应运而生，是浏览器在第一次请求服务器的时候，服务器就为这一次会话创建了一个Session对象，保存在服务端，Session的ID以Cookie的形式传递给客户端。这样以后的请求，服务端就可以通过Cookie中的ID拿到Session对象，解析出其中包含的关键信息，更加安全

> **Cookie与Session的区别**
> * 安全性：Session比Cookie安全
> * 存储值类型：Session可存任意类型的数据，Cookie只能存储字符串
> * 存储大小：Cookie最长大约4k，Session可由服务器定义，但远大于Cookie
> * 有效期：Cookie可设置长时间保持，Session失效时间较短，通常客户端关闭或Session超时都会失效

**Token**
令牌也叫访问资源凭证，一般可以由用户唯一标识、时间戳、签名通过压缩后生成的一定长度的十六进制字符串，和Cookie差不多的验证流程，客户端第一次请求服务器的时候，服务器返回给客户端，由客户端自行存储，之后每次请求的时候带上，可以放在Cookie或者LocalStorage。状态：Token无状态，可扩展性好，通常用来保存用户的身份凭证，Session有状态，可以记录会话信息

## 三. 浏览器缓存

浏览器缓存，也就是不与服务端交互，纯浏览器本身的缓存，包含LocalStorage和SessionStorage，二者的区别是：
* 生命周期：LocalStorage生命周期是永久的，除非主动删除否则永远不会消失；SessionStorage仅在当前会话有效，在浏览器窗口关闭后缓存就消失了
* 服务端：都仅在客户端保存，不参与与服务端的通信
* 大小：都差不多是5MB

## 四. 跨域问题

浏览器出于安全考虑，限制非同源资源的访问，同源就是指协议+域名+端口都相同。那如果浏览器访问非同源资源，则会导致跨域问题。解决跨域问题有下面几种方法：

**跨域头**
跨域头需要浏览器和后端同时支持，即后端在`Http Header`设置`Access-Control-Allow-Origin`，值为具体域名，或者`*`，`*`代表所有域名都可以向服务端发起请求。跨域头的有点是非常灵活简单，也是目前解决跨域问题最主要的方式

**jsonp**
利用`<script>`标签没有跨域限制这一点，实现过程是：声明回调函数，将函数名作为参数传递给请求数据的服务器；服务器将数据作为回调函数形参，返回给客户端。jsonp的优点是比较灵活简单，也能够实现跨域的需求，但缺点是只能实现GET方法，也不太安全，需要服务端配合，接口不能在其他应用场景复用

```javascript
//封装jsonp
function jsonp({url, params, callback}) {
  return new Promise((resolve,  reject) => {
    let script = document.createElement('script')
    window[callback] = function(data) {
      resolve(data)
      document.body.removeChild(script)
    }
    params = {...params, callback}
    let arrs = []
    for(let key of params) {
      arrs.push(`${key}=${params[key]}`)
    }
    script.src = `${url}?${arrs.join('&')}`
    document.body.appendChild(script)
  })
}
jsonp({
  url: `https://xxx.com/say`,
  params: { a: 'hello' },
  callback: 'show'
}).then(data => {
  console.error(data)
})
```

**代理**
利用的是服务器发起请求不存在跨域限制，因此需要先请求同源服务器，由同源服务器代为发起请求。vue工程运行设置的Proxy Table就是这样的原理