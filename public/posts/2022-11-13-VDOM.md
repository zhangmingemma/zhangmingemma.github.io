<!-- ---
title: Vue基础系列之虚拟DOM
date: 2022-11-13
tags: Vue基础系列
set: BaseVue
--- -->

**虚拟DOM**是**Vue2**中很关键的点，为什么一定要加入虚拟DOM？以及Vue采用数据劫持的手段可以精准拿到变化的数据，为什么还要用虚拟DOM？这篇文章就是试图了解并解决Vue中虚拟DOM的实现及原理。

### 一. 虚拟DOM是什么

虚拟DOM是一棵以JS对象作为基础的树，每一个节点称为`VNode`，用对象属性来描述节点，实际上它是一层对真实DOM的抽象，最终可以通过渲染操作使这棵树映射到真实环境上。

```html
<ul id="id1">
    <li>item 1</li>
    <li>item 2</li>
</ul>
```

这个真实的DOM节点，用虚拟DOM来描述就是
```javascript
{
    tag: 'ul',
    attributes: {
        id: 'id1'
    },
    children: [
        // 这里是li
    ]
}
```

VNode属性的含义包含：
```javascript
tag: 标签名
data: 关联数据
children: 子节点
text: 文本，文本节点或注释节点会有该属性
elm: 对应的真实的DOM
ns: namespace
context: Component，编译、渲染的作用域
key: key属性，作为节点标识，有利于patch的优化
componentOptions?: 组件配置项
componentInstance?: 组件实例
parent: 组件的占位节点
raw: 服务端专用，原始HTML
isStatic: 静态节点，未绑定动态数据，在数据更新时不需要对比节点
isRootInsert: 是否作为根节点插入，被<transition>包裹的节点，该属性的值为false
isComment: 注释节点
isCloned: 克隆节点
isOnce: v-once node
asyncFactory?: async component factory function
asyncMeta: Object | void
isAsyncPlaceholder: boolean
ssrContext?: 服务端渲染上下文
fnContext: 函数式组件上下文
fnOptions?: 函数式组件配置项
devtoolsMeta?: used to store functional render context for devtools
fnScopeId?: 函数式组件作用域ID
```

### 二. 虚拟DOM的作用

**Vue1.0还没有引入虚拟DOM技术**，当时的**响应更新粒度极小**，也就是每个数据与使用到自己的DOM节点都绑定了依赖关系，因此内存开销比较大，当项目比较大时会遇到性能瓶颈。在检查中检测具体到节点的状态变化，采用更细粒度来绑定更新视图。

**那Vue2.0为什么引入虚拟DOM呢？****Vue2.0采用中等粒度方案监听**，只能监听到组件的变化，而组件内部就使用虚拟DOM进行状态对比。每次渲染视图时都是先创建`VNode`，然后使用它创建真实DOM插入到页面中，所以可以将上一次渲染视图时所创建的`VNode`缓存起来，之后每当需要重新渲染视图时，将新创建的`VNode`和上一次缓存的`VNode`进行对比，找出更新前后的DOM差异，再基于DOM差异去修改真实的`DOM`。

尤雨溪在<a href="https://zhuanlan.zhihu.com/p/23752826" target="__blank">[Vue 的理念问题]</a>中的回答谈到，**虚拟DOM的优势**是：
* **组件的高度抽象化**：Vue2.0引入`VDOM`的主要原因是`VDOM`是把渲染过程抽象化了，从而使组件的抽象能力得到提升，并且可以适配DOM以外的渲染目标。
* **可以更好实现SSR，同构渲染**：Vue1.0都是直接操作DOM，比如SSR时，node上没有DOM也做不了DOM操作，只走DOM操作之前的模板替换阶段的话，根本渲染不出什么有用的东西来。有VDOM的话，SSR就很好实现了。也可以渲染到DOM之外的平台，`Weex`等框架应用的就是这一特性。
* **性能提升**：这个方面其实只有在HTML tag剧烈变化的时候才会体现出VDOM的好处，在大量、频繁的数据更新下，能够对视图进行合理、高效的更新

##### 1. **SSR**
**SSR**是指服务端渲染，是指由服务侧完成页面的HTML结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态和事件，称为完全可交互页面的过程。

**与客户端的单页应用 (SPA) 相比，SSR 的优势主要在于：**
* **更快的首屏加载**：这一点在慢网速或者运行缓慢的设备上尤为重要。服务端渲染的 HTML 无需等到所有的 JavaScript 都下载并执行完成之后才显示，所以你的用户将会更快地看到完整渲染的页面。除此之外，数据获取过程在首次访问时在服务端完成，相比于从客户端获取，可能有更快的数据库连接。这通常可以带来更高的核心 Web 指标评分、更好的用户体验，而对于那些“首屏加载速度与转化率直接相关”的应用来说，这点可能至关重要。
* **统一的心智模型**：你可以使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换。
* **更好的SEO**：搜索引擎爬虫可以直接看到完全渲染的页面

**使用SSR时还有一些权衡之处需要考量：**
* **开发中的限制**：浏览器端特定的代码只能在某些生命周期钩子中使用；一些外部库可能需要特殊处理才能在服务端渲染的应用中运行。
* **更多的与构建配置和部署相关的要求**：服务端渲染的应用需要一个能让 Node.js 服务器运行的环境，不像完全静态的 SPA 那样可以部署在任意的静态文件服务器上。
* **更高的服务端负载**：在 Node.js 中渲染一个完整的应用要比仅仅托管静态文件更加占用 CPU 资源，因此如果你预期有高流量，请为相应的服务器负载做好准备，并采用合理的缓存策略。

##### 2. **同构渲染**
同构渲染简单来说就是一份代码，服务端先通过**SSR**生成html以及初始化数据，客户端拿到代码和初始化数据后，通过对html的dom进行patch和事件绑定对dom进行客户端激活**CSH**，这个整体的过程叫同构渲染。

**同构渲染能解决首屏加载和seo的问题吗？**
首先，文件交由服务端渲染完，展示的速度肯定是提升的。同样也可以解决SEO的问题。比较前后端还是属于不同环境，同构考验开发人员对大局观的考虑，约束了特定环境的一些开发灵活性，同时也影响代码解耦。ssr抛开这两点好处，甚至没有找到任何优点。所以这是当前前后端同构不温不火的重要原因
