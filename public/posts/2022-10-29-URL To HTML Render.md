<!-- ---
title: JS基础系列之从URL输入到渲染
date: 2022-10-29
tags: JS基础系列
set: BaseJS
--- -->

URL从输入到渲染整个过程可以分为`网络通信`和`页面渲染`两个方面。每个环节都有优化的空间，都可以称为页面性能提升的关键点。

### 一. 网络通信

浏览器将接收到的`URL`中抽取出域名字段，就是访问的主机名，例如`http://www.qq.com`，会向域名服务器发起请求获取域名对应的`IP`地址，就可以向该`IP`地址定位的`HTTP`服务器发起`TCP`连接。

#### 1. DNS解析

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-29/2.png" style="display:inline-block; margin-bottom:16px;"></div>

DNS解析过程涉及很多步骤，我们在之前的文章<a href="https://zhangmingemma.github.io/#/post?file=2022-10-16-DNS" target="__blank">《计算机网络系列之DNS以及网络域名解析》</a>有介绍过DNS的域名服务器和解析的过程：

* 浏览器缓存：当用户通过浏览器访问域名时，浏览器首先会在自己缓存中查找是否有域名对应的`IP地址`，如果有缓存则直接得到`IP地址`发起请求，否则继续下一步
* 本地服务器：向本地服务器，即系统`Hosts`文件查询缓存
* 根域名服务器：向根域名服务器`.com`查询`IP地址`
* 二级域名服务器：向二级域名服务器`.qq.com`查询`IP地址`
* 三级域名服务器：向三级域名服务器`www.qq.com`查询`IP地址`

### 二. 页面渲染

#### 1. 进程与线程的概念

##### (1) 进程

CPU是计算机的核心，承担所有的计算任务，`进程`是`CPU`资源分配的最小单位，是一个可以独立运行且拥有自己的资源空间的任务程序。`CPU`给每个`进程`分配资源空间，分出去越多，越卡，每个`进程`之间是相互独立的，在运行一个`进程`时，其他`进程`都处于非运行状态，使用`时间片轮转调度算法`来实现同时运行多个进程

##### (2) 线程

**线程**是`CPU`调度的最小单元，是建立在`进程`基础上的一次程序运行单位，通俗来讲，就是程序中的一个执行流，一个`进程`可以由多个`线程`。一个`进程`只有一个`线程`的时候，被称作`单线程`，程序执行时，所走的程序路径按照连续顺序排下来，前面的处理好，后面的才会执行。一个`进程`包含多个`线程`的时候，被称作`多线程`。

##### (3) JS为单线程

JS作为浏览器脚本语言，主要用途是与用户互动，以及操作`DOM`，这就决定了它只能是单线程，否则会带来复杂的同步问题。`HTML5`提出`web worker`标准，允许`JS`脚本创建多线程，但子线程完全受主线程控制的，不能操作`DOM`，本质上没有改变`JS`的单线程的本质

##### (4) 浏览器渲染进程

浏览器渲染进程也就是常说的浏览器内核，主要作用为页面渲染、脚本执行和事件处理等。这个渲染进程是多线程的

* **GUI渲染线程**：负责渲染浏览器页面，解析`HTML`、`CSS`，构建`DOM树`和`RenderObject`树，布局和绘制等
* **JS引擎线程**：就是JS内核，负责处理JS脚本程序，JS是单线程运行的，并且**JS引擎线程**和**GUI渲染线程**是互斥的，JS引擎线程会阻塞GUI渲染线程，比如浏览器渲染的时候遇到`<script>`标签，就会停止GUI渲染，然后JS线程开始运行代码，JS引擎线程停止工作，GUI线程才会继续渲染下面的内容。
* **事件触发线程**：用来控制事件循环，并且管理着一个事件队列，当JS执行碰到事件绑定和一些异步操作，会走事件触发线程将对应的事件添加到对应的线程中，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待JS引擎线程空闲时来处理，
* **定时触发器线程**：就是`SetTimeout`和`SetInterval`线程，用来计时，将回调函数加入单独的线程，计时结束等JS引擎线程空闲后执行
* **异步请求线程**：在`XHR`连接后在浏览器新开一个线程请求，检测到`XHR`状态变更时，如果设置有回调函数，异步线程就会有状态变更事件，将这个回调再放入事件队列中由JS引擎线程执行。

#### 2. 渲染过程

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-29/3.png" style="display:inline-block; margin-bottom:16px;"></div>

##### (1) 解析HTML构建DOM树

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-29/4.png" style="display:inline-block; margin-bottom:16px;"></div>

* **字节流编码**：浏览器拿到页面`HTML`内容，这个内容是`0/1`原始的字节流，需要先用文件的指定编码将它们转换为各个字符，也就是一大串字符串。
* **词法解析**：也就是从字符串解析出编译的最小单元，如标签开始、标签结束、属性、注释、CDATA节点等。把这些解析出来，父子关系构建好，最终就构成了`DOM树`。

##### (2) 解析CSS构建CSSOM树

* **请求CSS资源**：构建`DOM树`，也就是解析HTML的时候，如果遇到了`link`，就会立即发起对资源的请求，返回样式内容，也就是字节流
* **构建CSSOM**：将CSS文件字符串，进行词法解析，生成CSSOM，决定着DOM结构的样式，即使是`DOM`构建先完成，也要等`CSSOM`构建完成，才能进行下一步

> 这里涉及到一个针对CSS样式的优化点：减少使用标签定义样式，避免多层嵌套，多使用class和id来提升CSS渲染构建的效率

##### (3) 解析JS脚本

构建`DOM`树的过程中，如果遇到了`script`标签的时候，立即会阻塞`DOM`树的构建，将控制权交回给JS引擎线程，等到JS引擎线程执行完毕，浏览器才会从中断的地方恢复DOM树的构建。

> 这里涉及到一个针对JS脚本解析的优化点：一般都将JS文件放到`HTML`底部进行加载，或是对JS文件执行`async`和`defer`加载
> async：异步执行，不保证执行顺序，一定在onload前，但不确定在`DOMContentLoaded`事件的前后
> defer：延迟执行，在浏览器看起来的效果像是把JS加载放在了`body`后面，虽然按照规范是在`DOMContentLoaded`之前，但实际上浏览器优化效果不同，可能在之后

##### (4) 构建渲染树

渲染树是由`DOM树`和`CSSOM树`合并而成的，并不是等`DOM树`和`CSSOM树`加载完成后才开始合并构建`渲染树`，三者的构建并无先后条件，也并非完全独立，而是会有交叉，并行构建，因此会一边加载，一边解析，一边渲染。渲染树只包含网页中每个可见元素的布局，并输出绘制流程，将像素渲染到屏幕上。

##### (5) 重绘

元素发生的改变只是影响了元素的一些外观，例如背景色、边框颜色、文字颜色等，此时只需要应用新样式绘制这个元素就可以了

##### (6) 回流

也叫**重排**，**回流**一定伴随着**重绘**，成本较高，引起**回流**的条件包括有：
* 页面渲染初始化
* `DOM`结构改变，比如删除某个节点
* `render`树变化，比如减少`padding`
* 窗口`resize`
* 元素的width/height/fontSize等发生了变化的时候
* 读取元素的offset、client、getComputeStyle()等

> 这里就涉及到了新的优化点：
> * 减少逐项更改样式，最好一次性修改，或者将样式组合成class并以此更新
> * 避免循环操作DOM，先创建`documentFragment`，在它上面应用所有的`DOM`操作，最后再把它添加到`window.document`。
> * 避免多次读取`offset`等属性，无法避免就要缓存到变量
> * 将复杂的元素绝对定位或者固定定位，脱离文档流，否则回流代价会很高
> * 尽量减少改变字体大小、table布局等，减少回流的可能性
> * 动画中使用`transform`和`opacity`，不会发生重排和重绘