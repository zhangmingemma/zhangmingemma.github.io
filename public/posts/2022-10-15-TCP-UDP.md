<!-- ---
title: 计算机网络系列之TCP与UDP
date: 2022-10-15
tags: 计算机网络
set: Network
--- -->

我们在<a href="https://zhangmingemma.github.io/#/post?file=2022-10-14-HTTP">《计算机网络系列之HTTP基础》</a>那一篇中讲到了传输层有两个代表性的协议就是TCP和UDP，接下来主要讲二者的概念以及主要区别。

## 一. UDP

用户数据报协议（User Datagram Protocol，UDP）的主要特点包含：

* **无连接**，即发送数据之前无需建立连接，减少了建立连接的时延和开销。在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据加一个UDP头标识，就传递给网络层了
* 尽最大努力交付，即**不保证可靠交付**。收到什么传递什么，也不会备份数据，也不关心对方是否正确接收到数据
* 支持一对一、一对多、多对一和多对多的交互通信
* **面向报文**，发送方的UDP对应用层传来的报文，直接添加首部就会交给IP层，既不合并，也不拆分，保留报文的边界。接收方收到IP层传来的报文，直接拆分首部就会返回给应用层，因此应用层必须选择合适大小的报文
* **没有拥塞控制**，当实时视频会议要求源主机以恒定的频率发送数据，并且允许在网络发生拥塞的时候丢失一部分数据，UDP就很适合
* **UDP首部开销比较小**，只有8个字节，包含4个字段，源端口、目的端口、长度和检验和，长度为数据报文的长度，检验和为数据报文是否出错，出错则会丢弃

## 二. TCP 

传输控制协议(Transmission Control Protocol, TCP)的主要特点包含：

* **面向连接**，即应用程序在传送数据前，必须要先建立TCP连接，在传送完数据之后，必须释放已经建立的连接
* **提供可靠交付的服务**，通过TCP传送的数据，无差错、不丢失、不重复，并且按序到达。TCP判断丢包、误码靠的是TCP的段编号以及确认号，为了保证可靠传输，给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。
* **一对一交互通信**
* **全双工通信**，TCP允许通信双方的应用进程在任何时候都能发送数据，两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。
* **面向字节流**，虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据当做一连串无结构的字节流，TCP并不理解字节流的含义。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系(例如，发送方应用程序交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付上层的应用程序)，但接收方应用程序收到的字节流必须和发送方应用程序发送的字节流完全一样。
* **有拥塞控制**，当网络出现拥塞的时候，TCP能够减少向网络中注入数据的速率和数量，缓解拥塞

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/1.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

### 1. TCP报文首部格式

TCP是面向字节流的，但TCP传送的数据单元却是报文段，一个报文段分为首部和数据两部分，TCP报文首部的前20个字节是固定的，后面4n个字节就是根据需求增加的。固定部分的字段及其含义分别是：

* **源端口和目的端口**：各占`2字节`
* **报文段序号SEQ**：占`4字节`，TCP是面向字节流的，传输的每个字节都会有自己的顺序编号，整个要传输的字节流的起始序号必须要在建立连接的时候设置，首部中的序号字段指的是本报文段所发送的数据的第一个字节的序号。例如，一个报文段的序号字段值是301，报文长度为100，那最后一个字节的序号是400，下一个报文段的序号字段值应该就是401
* **确认号ACK**：占`4字节`，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了来自A的一个报文段，报文段序号值为501，数据长度为200，最后一个字节的序号为700，那么B期望收到的下一个数据序号就是701，于是B在发送给A的确认报文段中把确认号设为701。
* **数据偏移**：占`4位`，TCP报文段的首部长度，数据偏移的最大值为60字节。
* **保留**：占`6位`，保留为今后所用
  * **URG**：紧急，当`URG = 1`时，表明紧急指针字段有效，它告诉系统此报文段中有紧急数据，应该尽快传送。例如命令中的ctrl+c
  * **ACK**：确认，当`ACK = 1`时，确认号有效，在连接建立后ACK都要为1
  * **PSH**：推送，当两个应用进程进行交互通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这种情况下TCP就可以使用推送操作，当接收方收到PSH = 1的报文段，就尽快交付，而不是等缓存满了之后再交付
  * **RST**：复位，当`RST = 1`时，表明TCP出现差错，必须释放连接，重新建立连接。`RST = 1`也可以用来拒绝一个非法报文段或者拒绝打开一个连接
  * **SYN**：同步，在建立连接时用来同步序号。当`SYN = 1`而`ACK = 0`时，表明这是一个连接请求报文段，如果同意则会时`SYN = 1`和`ACK = 1`。SYN置为1就标识这是一个连接请求，或是连接接受报文
  * **FIN**：终止，当`FIN = 1`标识发送方已发完数据，要求释放连接
* **窗口**：占`2字节`，是指发送本报文段的一房的接收窗口，窗口值告诉对方，从本报文段首部中的确认号算起，接收方允许发送的数据量。
* **检验和**：占`2字节`，检验范围包含首部和数据两部分
* **紧急指针**：占`2字节`，紧急指针仅在`URG = 1`时有效，指出本报文段中的紧急数据的字节数。窗口值为0也可以发送紧急报文

选项部分唯一定义的字段是最大报文字节数，就是MSS

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/5.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

### 2. TCP连接

应用程序在传送数据前，必须要先建立TCP连接，在传送完数据之后，必须释放已经建立的连接。像下图描述的一样，A要与B建立连接，需要经过**三次握手**：

* A首先向B发出连接请求报文段，首部中的同步位`SYN=1`，同时选择一个厨师序号`seq = x`，不能携带数据
* B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文中`SYN = 1`且`ACK = x + 1`，同时也为自己选择一个`seq = y`，也不能携带数据
* A收到B的确认后，给出应答，`SYN = 1`且`ACK = y + 1`，且`seq = x + 1`，此时A进入`ESTABLISHED`状态，B收到A的确认后，也进入`ESTABLISHED`状态，连接已建立完成

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/4.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

**为什么A还要发送一次确认？**
为了避免建立无效连接。例如A发出连接请求，但因网络延迟没有收到确认，于是A重传连接请求，B发回了确认，此时延迟的连接到达了B，此时B会认为是新的请求，就会再次发出确认，如果没有三次握手，那这里就会建立两条连接，但其中一条是无效的连接

应用程序在传输完数据之后，要释放建立的连接，像下图描述的一样，`ESTABLISHED`状态的A和B要释放连接，要经历**4次挥手**：

* A首先向B发出释放连接报文，并停止发送数据，主动关闭TCP连接，A的报文首部`FIN = 1`，序号位置为`seq = u`，此报文不能携带数据，会消耗掉一个序号
* B收到连接释放报文之后立即发出确认，确认号是`ACK = u + 1`，这个报文段自己的`seq = v`，等于B前面已传送的数据最后一个字节的序号+1，此时连接处于半关闭状态，此时A已经没有数据要发送了，但B如果还要发送，A还是要继续接收的。
* A收到B的确认之后，等待B发送的释放报文段，如果B没有数据继续发送，就会发送连接释放报文段，`FIN = 1`，`ACK = u + 1`，`seq = w`，B就等待A的确认
* A收到B的释放连接报文后，对此发出确认，在确认报文段内`ACK = w + 1`，自己的序号`seq = u + 1`，此时连接等待时间等待计时器计时结束就可以彻底释放了，时间计时器的时间设置根据当前的网络状态的具体情况来确定，这个计时是为了等待B收到ACK确认报文

**如果客户端宕机，服务端是否持续保持连接？**
会有保活机制，如果服务端没收到客户端一次报文数据，就设置新的计时器，一般为2小时，若2小时没有收到客户端的数据时，就发送一个探测报文段，之后每隔75分钟发送一次，连发10次都没有回应，就会自动断开连接

**套接字**
TCP把连接作为最基本的抽象，每条连接唯一地被通信两端的两个端点所确定。TCP连接的两个端点叫做套接字/插口，即端口号拼接到IP地址即形成了套接字。套接字的表示方法就是在点分十进制的IP地址后面写上端口号，中间用冒号隔开。例如`192.3.4.5:8080`就是一个套接字

### 3. 可靠传输

#### 可靠传输的原理

TCP之后的网络都是不可靠传输，TCP的可靠传输的工作原理是：

* **停止等待**：每发送完一个分组就停止发送，等待对方的确认通知，在收到确认通知后再发送下一个分组
<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/2.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

* **超时重传**：如果设计A发送数据给B，A只要超过一段时间仍然没有收到确认，就认为刚刚发送的分组丢失了，会重传前面发送的分组。要实现超时重传，首先需要发送数据的副本，以备重传之需；发送的数据的seq，能够标识报文段；超时的倒计时计时器应当大于正常数据往返时间。
* **确认丢失和确认迟到**：上面图片中，A发送数据给B，A超过一段时间没有收到确认，此时有A-B数据传送延迟/丢失，或是B-A确认传送延迟/丢失。如果是前者，A重发之后，B会丢弃重复数据，用最新的数据，并发送确认；如果是后者，A重发之后，收到确认之后又收到了确认，则会什么都不做
<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/3.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

TCP需要等待请求确认，需要长时占用通信成本，因此TCP采用流水线传输，发送方可连续发送多个分组，不必每发完一个分组就等待确认。

#### 可靠传输中的滑动窗口

假设A收到B的确认报文，窗口值为20字节，`ACK = 31`，表示30及之前的数据都收到了，此时A就会调整其发送窗口为31 - 50，滑动窗口的设置有几个要点：

* 在没有收到确认之前，A可以连续把窗口内的数据都发送出去，在未收到确认前这些数据都必须保留，以便超时重传
* 没有按序到达的字节，接受方收到之后会暂存在接收窗口，等待缺少的字节全部收到后，再交付应用层。接收方也可在首部定义SACK选项去说明缺失的片段边界，让发送方重传缺失的片段。

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/6.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

同时滑动窗口也是TCP实现流量控制的关键核心，发送方发送的数据长度不能超过接收方给出的接收的窗口值，接收方可以通过窗口值控制接收数据的大小，实现流量控制。

### 4. 拥塞控制

网络拥塞往往是许多因素引起的，网络拥塞的监测指标有很多：由于缺少缓存空间而被丢失的分组的百分比，平均队列长度，超时重传的分组数，平均分组时延，分组时延的标准差等。控制拥塞是一个动态的过程，非常复杂，1999年公布的因特网建议标准RFC 2581定义了进行拥塞控制的四种算法：慢开始、拥塞避免、快重传和快恢复。为更好的解释拥塞控制的算法原理，我们先假定数据单方向传输，并且接收方具备足够大的缓存空间，发送窗口的大小由网络的拥塞程度决定

#### （1）慢开始和拥塞避免

发送方维持一个叫拥塞窗口的状态变量，拥塞窗口的大小取决于网络的拥塞程度并且动态地在变化，发送方让自己的发送窗口等于拥塞窗口。当发送方没有按时收到确认报文，就推测可能出现网络拥塞，此时发送方就可以将拥塞窗口调整小，减轻网络负担。

**慢开始算法**减小拥塞窗口的思路是：最开始我们不知道网络的负荷情况，可以从小到大逐渐增大拥塞窗口数值(cwnd)，所谓的“慢”就是指最开始发送方只发一个报文段，拥塞窗口值设为1，之后每收到一次确认报文，就把cwnd加倍，逐次增大（这个1是指1个报文段，报文段的最大字节数就是MSS，在TCP首部中有对应的定义）。

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/7.png" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

**拥塞避免算法**的思路是让拥塞窗口缓慢增大，没经过一个往返时间就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口cwnd就是线性增长，比慢开始算法的增长速率更为缓慢

**实际应用**中通常会设置一个慢开始门限，拥塞窗口小于慢开始门限时，采用慢开始算法逐次增大拥塞窗口值；等于慢开始门限时，两种方法都可以使用；大于慢开始门限时，采用拥塞避免算法增大拥塞门限。当遇到网络拥塞时，将慢开始门限设置为出现拥塞时发送方窗口值的一半，然后拥塞窗口值重置为1，继续采用前面的方法进行稳步增大拥塞窗口值。能够迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器能够有足够的时间处理积压的分组

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/8.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

#### （2）快重传和快恢复

如下图的描述，**快重传**的过程举例是发送方按序发送M1、M2、M3之后，M3丢失了，发送方继续发送M4~M6，接收方没收到一次就会重复发送M2的确认报文，提示发送方M3丢失，发送方连续三次收到相同的确认后，就会立即发送M3的重传，而不必等待超时重传的倒计时，可以使吞吐量提高20%。

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/9.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

与快重传搭配的还有**快恢复**，当发送方连续收到三个相同的确认之后，就会将慢开始门限减半，预防网络拥塞，但不会执行慢开始算法，因为连续收到确认报文，代表网络没有发生拥塞，而是会把拥塞窗口设为慢开始门限减半后的数值后开始执行拥塞避免算法。

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/10.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

**额外知识点**
* **发送窗口值**取决于拥塞窗口和接收窗口，一般取二者的最小值
* **流量控制和拥塞控制的区别**：流量控制仅为端到端，是说控制发送方发送数据的大小和速度，减小网络负荷，而拥塞控制则比较复杂，是设计网络的各个环节，我们常探讨的拥塞控制不仅包含发送方发送数据的机制调整，也包含接收方的接收确认的机制