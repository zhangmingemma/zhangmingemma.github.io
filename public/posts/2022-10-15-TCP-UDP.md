<!-- ---xx
title: 计算机网络系列之TCP与UDP
date: 2022-10-15
tags: 计算机网络
set: Network
--- -->

我们在<a href="https://zhangmingemma.github.io/#/post?file=2022-10-14-HTTP">《计算机网络系列之HTTP基础》</a>那一篇中讲到了传输层有两个代表性的协议就是TCP和UDP，接下来主要讲二者的概念以及主要区别。

## 一. UDP

用户数据报协议（User Datagram Protocol，UDP）的主要特点包含：

* **无连接**，即发送数据之前无需建立连接，减少了建立连接的时延和开销。在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据加一个UDP头标识，就传递给网络层了
* 尽最大努力交付，即**不保证可靠交付**。收到什么传递什么，也不会备份数据，也不关心对方是否正确接收到数据
* 支持一对一、一对多、多对一和多对多的交互通信
* **面向报文**，发送方的UDP对应用层传来的报文，直接添加首部就会交给IP层，既不合并，也不拆分，保留报文的边界。接收方收到IP层传来的报文，直接拆分首部就会返回给应用层，因此应用层必须选择合适大小的报文
* **没有拥塞控制**，当实时视频会议要求源主机以恒定的频率发送数据，并且允许在网络发生拥塞的时候丢失一部分数据，UDP就很适合
* **UDP首部开销比较小**，只有8个字节，包含4个字段，源端口、目的端口、长度和检验和，长度为数据报文的长度，检验和为数据报文是否出错，出错则会丢弃

## 二. TCP 

传输控制协议(Transmission Control Protocol, TCP)的主要特点包含：

* **面向连接**，即应用程序在传送数据前，必须要先建立TCP连接，在传送完数据之后，必须释放已经建立的连接
* **提供可靠交付的服务**，通过TCP传送的数据，无差错、不丢失、不重复，并且按序到达。TCP判断丢包、误码靠的是TCP的段编号以及确认号，为了保证可靠传输，给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。
* **一对一交互通信**
* **全双工通信**，TCP允许通信双方的应用进程在任何时候都能发送数据，两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。
* **面向字节流**，虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据当做一连串无结构的字节流，TCP并不理解字节流的含义。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系(例如，发送方应用程序交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块就把收到的字节流交付上层的应用程序)，但接收方应用程序收到的字节流必须和发送方应用程序发送的字节流完全一样。
* **有拥塞控制**，当网络出现拥塞的时候，TCP能够减少向网络中注入数据的速率和数量，缓解拥塞

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/1.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

### 1. TCP报文首部格式

TCP是面向字节流的，但TCP传送的数据单元却是报文段，一个报文段分为首部和数据两部分，TCP报文首部的前20个字节是固定的，后面4n个字节就是根据需求增加的。固定部分的字段及其含义分别是：

* **源端口和目的端口**：各占`2字节`
* **报文段序号SEQ**：占`4字节`，TCP是面向字节流的，传输的每个字节都会有自己的顺序编号，整个要传输的字节流的起始序号必须要在建立连接的时候设置，首部中的序号字段指的是本报文段所发送的数据的第一个字节的序号。例如，一个报文段的序号字段值是301，报文长度为100，那最后一个字节的序号是400，下一个报文段的序号字段值应该就是401
* **确认号ACK**：占`4字节`，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B正确收到了来自A的一个报文段，报文段序号值为501，数据长度为200，最后一个字节的序号为700，那么B期望收到的下一个数据序号就是701，于是B在发送给A的确认报文段中把确认号设为701。
* **数据偏移**：占`4位`，TCP报文段的首部长度，数据偏移的最大值为60字节。
* **保留**：占`6位`，保留为今后所用
  * **URG**：紧急，当`URG = 1`时，表明紧急指针字段有效，它告诉系统此报文段中有紧急数据，应该尽快传送。例如命令中的ctrl+c
  * **ACK**：确认，当`ACK = 1`时，确认号有效，在连接建立后ACK都要为1
  * **PSH**：推送，当两个应用进程进行交互通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这种情况下TCP就可以使用推送操作，当接收方收到PSH = 1的报文段，就尽快交付，而不是等缓存满了之后再交付
  * **RST**：复位，当`RST = 1`时，表明TCP出现差错，必须释放连接，重新建立连接。`RST = 1`也可以用来拒绝一个非法报文段或者拒绝打开一个连接
  * **SYN**：同步，在建立连接时用来同步序号。当`SYN = 1`而`ACK = 0`时，表明这是一个连接请求报文段，如果同意则会时`SYN = 1`和`ACK = 1`。SYN置为1就标识这是一个连接请求，或是连接接受报文
  * **FIN**：终止，当`FIN = 1`标识发送方已发完数据，要求释放连接
* **窗口**：占`2字节`，是指发送本报文段的一房的接收窗口，窗口值告诉对方，从本报文段首部中的确认号算起，接收方允许发送的数据量。
* **检验和**：占`2字节`，检验范围包含首部和数据两部分
* **紧急指针**：占`2字节`，紧急指针仅在`URG = 1`时有效，指出本报文段中的紧急数据的字节数。窗口值为0也可以发送紧急报文

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/5.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

### 2. TCP连接

应用程序在传送数据前，必须要先建立TCP连接，在传送完数据之后，必须释放已经建立的连接。像下图描述的一样，A要与B建立连接，需要经过三次握手：

* A首先向B发出连接请求报文段，首部中的同步位`SYN=1`，同时选择一个厨师序号`seq = x`，进入`SYN-SENT`状态，不能携带数据
* B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文中`SYN = 1`且`ACK = x + 1`，同时也为自己选择一个`seq = y`，也不能携带数据，此时进入`SYN-RCVD`状态
* A收到B的确认后，给出应答，`SYN = 1`且`ACK = y + 1`，且`seq = x + 1`，此时A进入`ESTABLISHED`状态，B收到A的确认后，也进入`ESTABLISHED`状态，连接已建立完成

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/4.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

> 为什么A还要发送一次确认？
> 为了避免建立无效连接。例如A发出连接请求，但因网络延迟没有收到确认，于是A重传连接请求，B发回了确认，此时延迟的连接到达了B，此时B会认为是新的请求，就会再次发出确认，如果没有三次握手，那这里就会建立两条连接，但其中一条是无效的连接

应用程序在传输完数据之后，要释放建立的连接，像下图描述的一样，`ESTABLISHED`状态的A和B要释放连接，要经历4次挥手：

* A首先向B发出释放连接报文，并停止发送数据，主动关闭TCP连接，A的报文首部`FIN = 1`，序号位置为`seq = u`，进入`FIN-WAIT-1`状态，此报文不能携带数据，会消耗掉一个序号














### 1. 可靠传输

TCP提供可靠传输，为保证可靠传输，TCP有一些措施可以实现：

* **停止等待**：每发送完一个分组就停止发送，等待对方的确认通知，在收到确认通知后再发送下一个分组
<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/2.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

* **超时重传**：如果设计A发送数据给B，A只要超过一段时间仍然没有收到确认，就认为刚刚发送的分组丢失了，会重传前面发送的分组。要实现超时重传，首先需要发送数据的副本，以备重传之需；发送的数据必须要有一个编号，才能确认重传的数据和传送方；超时的倒计时计时器应当大于正常数据往返时间。
* **确认丢失和确认迟到**：上面图片中，A发送数据给B，A超过一段时间没有收到确认，此时有A-B数据传送延迟/丢失，或是B-A确认传送延迟/丢失。如果是前者，A重发之后，B会丢弃重复数据，用最新的数据，并发送确认；如果是后者，A重发之后，收到确认之后又收到了确认，则会什么都不做
<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-15/3.jpeg" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

### 2. 传输效率

TCP需要等待请求确认，需要长时占用通信成本，因此TCP采用流水线传输，发送方可连续发送多个分组，不必每发完一个分组就等待确认。

### 1. TCP连接

TCP把连接作为最基本的抽象，每条连接唯一地被通信两端的两个端点所确定。TCP连接的两个端点叫做套接字/插口，即端口号拼接到IP地址即形成了套接字。套接字的表示方法就是在点分十进制的IP地址后面写上端口号，中间用冒号隔开。例如`192.3.4.5:8080`就是一个套接字










