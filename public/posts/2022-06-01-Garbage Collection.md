<!-- ---
title: JS 垃圾回收
date: 2022-06-01
tags: JavaScript
--- -->

## 什么是垃圾回收？
程序运行过程中会产生`非活动对象`，这些对象没有被引用，占用着内存，需要被清除。这个清除的过程就是`垃圾回收(GC)`，让空间可以被再利用。对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则硬性系统性能，重则导致进程崩溃。自带垃圾回收机制的语言包括`Python`、 `Java`、 `JavaScript`等。

## 垃圾如何产生？
Javascript的引用类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用。所以，`Javascript`中对引用类型的操作都是操作对象的引用而不是实际的对象。举例：
```
let test = {
  name: 'test'
}
test = [1,2]
```

上面的代码，声明了变量`test`，引用了对象`{name: 'test'}`，接着对这个变量重新赋值为数组，即引用了另一个数组，之前的引用关系就没有了，对象`{name: 'test'}`就是没有引用关系的`垃圾`，需要被回收。
<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/1.png">

## 垃圾回收机制
垃圾回收机制，就是定期找出无用内存，并释放的机制。之所以为`定期`，而不是`实时`，是因为`实时`开销太大。常见的垃圾回收机制有`标记清除法`和`引用计数法`。

### 一. 标记清除法
标记清除法，是目前`JavaScript引擎`里最常用的算法，目前为止的大多数浏览器都采用的是`标记清除法`，只是各大浏览器厂商对算法进行了优化加工，并且不同浏览器在运行垃圾回收的频率上有所差异。

#### 1. 方案
标记清除法，分为`标记`和`清除`两个阶段，`标记`阶段为所有`活动对象`做上标记，`清除`阶段则把`非活动对象`销毁掉。

* 标记：从指针对象的起点开始，遍历全部对象，对可触达对象进行标记。下图分别是标记前、标记后内存中堆的状态
<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/2.png">
<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/3.png">

* 清除：遍历整个堆，回收没有标记的对象，使其内存能够被再次利用。回收对象就是把对象作为分块，连接到`空闲链表`的单向链表，之后再分配控件的时候只需要遍历这个空闲链表，就可以找到可用的分块了
<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/4.png">


#### 2. 优点：实现简单

#### 3. 缺点

* 碎片化严重，容易产生小的分块，可能会导致分配所需内存较大时找不到合适的分块
<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/5.png">

* 分配速度慢，由于空闲分块是用链表实现，分块可能都不连续，每次分配都需要遍历空闲链表，极端情况下需要遍历整个链表
<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/6.png">

> 分配策略
* First-Fit，找到大于等于`size`的快立刻返回（最为明智的选择）
* Best-Fit，遍历整个空闲链表，返回大于等于`size`的最小分块（分配效率略逊色）
* Worst-Fit，遍历整个空闲链表，找到最大分块，切成两部分，一部分`size`大小，并将该部分返回（会产生很多小碎片）

> 分配速度慢的解决方案：制造多个空闲链表，分别存储不同size的回收对象分块，减少再次分配时的遍历次数

#### 4. 标记整理法

在`标记清除法`之后，将`活动对象`向内存的一端移动，最后清理掉边界的内存
<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/7.png">

### 二. 引用计数法

引用计数法，把`对象是否不再需要`简化定义为`对象有没有其他对象在引用`，如果零引用，则将被垃圾回收。

#### 1. 方案

* 当声明了一个变量，并且将一个引用类型赋值给该变量的时候，这个值的引用次数就为1
* 如果同一个值又被赋给另外一个变量，那么引用数加1
* 如果该变量的值被其他的值覆盖了，那么引用数就减一
* 当这个值的引用数变为0时，垃圾回收器运行的时候就会清理掉引用数为0的值所占用的内存

#### 2. 优点：可以立即回收垃圾，相比之下算法思路也更加清晰
#### 3. 缺点
* 首先需要一个计数器，占用很大的位置，因为我们无法估计被引用数量的上限
* 循环引用的问题，下面的例子中对象`A`、`B`互相引用，他们的引用数量都是2，但是在`test`函数执行之后，对象`A`、`B`是应该被清理的，导致内存不会被释放

```
function test() {
  let A = new Object()
  let B = new Object()
  A.b = B
  B.a = A
}
```

上面的例子用`标记清除法`的思路来看的话，`test`执行之后，两个对象不在作用域中，`A`、`B`都是非活动对象，会被清除掉。

## V8的垃圾回收

V8针对GC过程做了自己的一系列优化策略，首先是将内存对象划分为`新生代`和`老生代`两类，执行`分代式垃圾回收`，针对`新生代`的垃圾回收并进一步采用`并行回收`的策略进行优化，针对`老生代`的垃圾回收采用`增量标记`和`惰性清理`配合进行优化，此外，针对`老生代`的垃圾回收还有`并发回收`这种优化方式，每种方式的具体实现细节和优缺点接下来会展开进行详细陈述。

### 一. 分代式垃圾回收

如果垃圾回收算法在每次回收时都要检查内存中所有的对象，对大、老、存活时间长的对象和小、新、存活时间短的对象采用相同的频率去检查，是损耗性能的。因为前者检查一次耗损较大，且并不需要频繁清理，而后者刚好相反。`分代式回收机制`就是将堆内存分为新生代和老生代两区域，采用不同的策略管理垃圾回收。`新生代`是指存活时间较短的对象，只支持`1~8M`的容量，`老生代`是指存活时间较长、常驻内存的对象，容量较大。

#### 1. 新生代垃圾回收

将堆内存一分为二，一是`使用区`，即处于使用状态的空间，另一个是`空闲区`，即处于闲置状态的空间。

<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/8.png">

* 新加入的对象都会存放在`使用区`，使用区快写满的时候，会执行一次垃圾清理。
* 当开始垃圾回收时，新生代垃圾回收器会对`使用区`的对象进行标记，标记完成后将`使用区`的活动对象复制到`空闲区`并进行排序，随后进入垃圾清理阶段，将非活动对象都清理掉，最后进行角色互换，`使用区`变`空闲区`，`空闲区`变`使用区`。
* 当一个对象经过多次复制后仍旧存货，则被认为是`老生代`，将移入`老生代`内存中进行管理。当复制对象时`空闲区`空间占用超过25%，则直接移入`老生代`，否则将影响后续的内存分配。

#### 2. 老生代垃圾回收

老生代大多数占用空间较大，不适合来回复制，采用标准的标记清除法进行垃圾回收。
* 标记阶段，从一组根元素开始，递归遍历，不可触达的对象即为非活动对象，进行清理
* 为避免产生碎片化内存，采用`标记整理法`优化空间

### 二. 并行回收 - 新生代

JS是单线程的语言，进行垃圾回收会阻塞到JS脚本的执行，需要等待垃圾回收结束后恢复，因此，V8引入了`并行回收机制`去优化`新生代垃圾回收`。

<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/9.png">

并行回收就是启动多个线程来负责垃圾回收，这些线程同时将`使用区`中的数据移动到`空闲区`，这个过程中由于数据地址发生变化，还需要同步更新引用这些对象的指针。

### 三. 增量标记与惰性清理 - 老生代

对于`老生代垃圾回收`仍旧会完全阻塞JS脚本的执行，为了减少全停顿的时间，V8进行优化，将全停顿标记切换为`增量标记`

#### 1. 增量标记

增量标记，就是将以此GC标记过程，分成很多小步，没执行一步就让JS脚本执行一会儿，交替多次完成一轮GC

<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/10.png">

增量标记遇到的一个问题就是，在一次标记之后，执行JS程序，而后如何恢复？如何继续上次的标记？中间已经标记过的对象的引用关系发生了修改，该怎么办呢？

##### 1). 三色标记法 - 恢复增量标记

针对上面`增量标记`中提到的，暂停标记执行JS程序后，无法恢复标记的问题，V8采用的应对方案是`三色标记法`。`三色标记法`即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三个颜色：白、灰、黑
* 白色指未标记的对象
* 灰色指自身被标记，成员变量未被标记
* 黑色指自身和成员变量皆被标记

<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/11.png">

最初所有对象均为白色，回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色推入标记工作表中，当回收器从标记工作表弹出对象并访问它的引用对象时，自身由灰色转黑色，并将自身的下一个引用对象转为灰色。直到没有可标记的灰色对象，剩下的所有白色对象都是非活动对象，可等待回收。

三色标记法在恢复执行时可以通过内存中是否有灰色节点来判断整个标记流程是否完成，如没有直接进行清理，如有则直接从灰色节点开始继续标记进程，能够很好的配合`增量标记`执行GC

##### 2). 写屏障 - 已标记对象被修改

针对上面`增量标记`中提到的，暂停标记执行JS程序后，已标记对象被修改的问题，V8采用的方案是`写屏障`。

<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/12.png">

比如例子中`B`的指向由`C`改为`D`，在进行下一次GC时，对象`C`已经无引用关系了，但它是黑色的，不会在此次GC中被回收，但会在下一轮的GC清理掉。但对象`D`此时是白色的，已经没有灰色对象，白色对象就会被清理掉，引用关系被回收，导致问题。`写屏障`的机制，就是一旦有黑色对象引用白色对象，会强制将引用的对象改为灰色，从而保证下一次GC时可以继续正确标记。

#### 2. 惰性清理

`增量标记`是针对标记过程的优化策略，能够不全停顿阻塞JS执行进程。`惰性清理`是针对清理过程的，当当前内存足以快速执行代码时，会延迟清理过程，这就是惰性清理。二者结合能够大大减少主线程的停顿时间，让用户与浏览器的交互变得流畅。但并没有减少主线程的停顿总时长，甚至会增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量。

### 四. 并发回收

主线程在执行JS的过程中，辅助线程在后台完成回收垃圾的操作，让主线程不被挂起。但缺点是并发回收的过程中，主线程JS逻辑还在执行，对象的引用关系随时都会发生变化，因此需要额外的一些读写锁机制来控制。