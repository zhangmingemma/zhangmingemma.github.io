<!-- ---
title: 计算机网络系列之HTTP基础
date: 2022-10-17
tags: 计算机网络
set: Network
--- -->

HTTP(Hypertext Transfer Protocol)，超文本传输协议，Web使用HTTP规范从客户端到服务端等一系列运转流程。HTTP协议定义了Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。

## 一. URL

在认识HTTP之前，我们需要先了解URL(Universal Resource Locator，统一资源定位符)是什么，以及是如何构成的？这里我们还要了解一个概念URI(Uniform Resource Identifier，统一资源标识符)。URI是指由某个协议方案标识的资源的定位标识符，协议就是指访问资源所需要的协议类型，例如http就是协议的一种。URL是URI的子集，表示的是资源的地点

**URL的组成**

* **scheme**：访问服务器所需资源的协议，如http、https
* **host**：http服务器的IP地址或者域名
* **port**：http服务器的默认端口是80，https的默认端口是443，默认情况下可省略，否则需要定义端口
* **path**：访问资源的路径
* **queryString**：发送http服务器的数据，查询参数
* **anchor**：锚点

## 二. HTTP报文

用于HTTP协议交互的信息被称为HTTP报文，请求端发送的报文叫请求报文，接收端发送的报文叫响应报文，报文大致构成可以划分为首部和主体两部分，首部通常包含服务端或客户端处理的请求/响应的内容和属性，主体通常包含传输的数据，可以没有

<div style="display:flex;justify-content:center;">
  <img src="https://zhangmingemma.github.io/dist/images/2022-10-17/1.png" style="display:inline-block; margin-bottom:16px; width:50%; height: 200px;">
  <img src="https://zhangmingemma.github.io/dist/images/2022-10-17/2.png" style="display:inline-block; margin-bottom:16px; width:50%;">
</div>

**报文的构成包含**
* 请求行：存在于请求报文，包含请求的方法，HTTP的版本
* 状态行：存在于响应报文，包含表明响应结果的状态码，原因短语和HTTP版本
* 首部字段：包含通用首部字段、请求首部字段、实体首部字段等

**常见的通用首部字段**
* Date: 服务器产生响应的日期
* Cache-Control：控制缓存的行为

**常见的请求首部字段**
* HOST：请求资源所在服务器
* Accept：用户代理可处理的媒体类型
* Accept-Charset：优先的字符集
* Accept-Encoding：优先的内容编码
* Accept-Language：优先的语言
* Authorization：web认证信息
* 缓存相关：If-Match / If-Modified-Since / If-None-Match / If-Unmodified-Since
* User-Agent：HTTP客户端程序的信息
* Referer：请求中URI的原始获取方
* Range: 实体的字节范围请求

**常见的响应首部字段**
* Accept-Range: 是否接受字节范围请求
* Age: 推算资源创建时间
* Etag: 资源匹配信息
* Location: 令客户端定向至指定URL
* Retry-After: 对再次发起请求的时机要求

**常见的实体首部字段**
* Content-Encoding: 实体的编码方式
* Content-Length: 实体的内容长度
* Content-Location: 资源URL
* Content-Type: 实体的媒体类型
* Allow: 支持的HTTP方法
* Expires: 实体的过期时间
* Last-Modified: 资源的最后修改时间 
  
## 三. HTTP方法

**HTTP包含很多中请求方法：**

* **GET**：用来访问已被URI标识的资源
* **POST**：传输实体的主体
* **PUT**：用来上传文件，存在安全性问题，一般不采用
* **HEAD**：用来获取报文头部
* **DELETE**：用来删除文件
* **OPTIONS**：询问支持的方法
* **TRACE**：跟踪路径
* **CONNECT**：要求用隧道协议连接代理。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输

**GET和POST的区别**
* 定义不同：GET用来请求数据资源，POST用来传输数据资源
* 数据传输方式不同：GET方法的传输参数在URL中，而POST方法的传输参数在请求体中
* 参数长度不同：由于浏览器地址的长度限制，GET方法的请求数据会有长度限制，而POST没有
* 安全性不同：因为POST将传输的数据放在请求体内，所以要更安全
* 回退无害：GET方法刷新、后退等浏览器操作是无害的，POST会导致重新提交表单
* 收藏：GET可以作为书签被收藏，POST不可以
* 数据包：GET方法在请求中产生一个TCP数据包，而POST方法在请求中产生HEADER和数据体两个TCP数据包，在发送HEADER，收到服务器确认后，再发送数据体的数据包

## 四. HTTP状态码

状态码的职责是当客户端向服务端发送请求时，描述返回的请求结果的请求状态

* 1XX：接收的请求正在处理
* 2XX：请求正常处理完毕
* 3XX：需要附加操作以完成请求
  * 301：永久重定向
  * 302：临时重定向
  * 304：Not Modified，可以使用浏览器缓存
* 4XX：服务器无法处理请求
  * 400：请求体存在语法错误
  * 401：需要认证
  * 403：拒绝访问
  * 404：资源未找到
* 5XX：服务器处理请求出错
  * 500：服务器内部发生错误

## 五. HTTP缓存

**强缓存**

根据HTTP首部的`Expires`和`Cache-Control`判断是否命中强缓存，`Expires`代表资源的过期时间，是一个绝对时间，由服务器端返回，浏览器会根据`Expires`判断资源是否过期，如果过期会直接使用缓存资源。但浏览器时间和服务器的时间会有差异，可能会不提准确。`Cache-Control`就是为了解决这个问题，包含几个响应首部字段：

* max-age：缓存的最大时间
* private：只针对单个用户或实体进行缓存资源
* public：任何途径的缓存者都可以无条件缓存资源
* no-store：不缓存任何数据，下次直接向服务器请求数据
* no-cache：缓存在本地缓存中，只是在与服务器再度验证之前，缓存不能直接提供给浏览器使用

**协商缓存**

当浏览器没有命中强缓存，就需要向服务器发起请求，验证协商缓存是否命中，命中则返回`304状态码`，否则返回新的数据资源：

* 浏览器第一次发起请求，服务端的响应报文携带`Last-Modified`，表示资源的最后修改时间；下一次请求报文中携带`If-Modified-Since`，值为`Last-Modified`的值，服务端比较资源的更新时间，做出应答
* 浏览器第一次发起请求，服务端的响应报文携带`Etag`，表示自愿的唯一标识；下一次请求报文中携带`If-Not-Match`，值是`Etag`的值，服务端比较资源的ID，做出应答。相比第一种方式而言，弥补了资源内容没变化，但修改时间发生变化的情况。

**实际应用**

在访问页面的四种方式中：
* 地址栏回车、页面链接跳转、打开新窗口/标签页、history前进后退：从强缓存开始判断
* 点击刷新按钮、页面右键重新加载、f5、ctrl+R：会跳过强缓存，从协商缓存开始判断
* 硬性重新加载、ctrl+f5、ctrl+shift+R、勾选disable cache后点刷新：直接发起真实的请求，这种方式会在Request Header里添加`Cache-Control: no-cache`和`Pragma: no-cache`，也是浏览器自己的行为

**Cache-Control**

在客户端与服务端的交互中，请求报文、响应报文中都可能会包含`Cache-Control`字段，请求头中的`Cache-Control`影响的是当前这一次的请求，响应头里的`Cache-Control`是告诉浏览器这样存储，下次按照这样来，影响的是下一次请求。

请求头中的`Cache-Control`只有在浏览器刷新、硬性重新加载才会添加，只有两个值：
* max-age = 0：这个值表示，这个请求按照协商缓存的规则走，一定会发出真实的请求，如果缓存未过期，则返回304，否则返回200
* no-cache：表示这次请求不会读缓存资源，即便缓存没有过期或者资源并没有修改，要发出真实的请求

**disk cache和memory cache**

在Chrome的网络请求的`Size`字段中会出现三种情况`from disk cache(磁盘缓存)`、`from memory cache(内存缓存)`和资源大小数值，是强缓存的两种存储位置。
* from memory cache：从提取速度上来讲，memory cache 比disk cache要快得多。但容量小且时效性短，一旦浏览器Tab页关闭，memory cache都将被清空。
* from disk cache：是存在硬盘中的缓存，存储空间大，时间长，网站中绝大多数资源都是存在磁盘中的。


## 六. HTTP版本

**HTTP 1.0**
* 任何格式的内容都可以发送，不止可以传输文字，还可以传输图片、视频和二进制文件
* 除了`GET`之外，还支持`POST`和`HEAD`
* 短连接模式，每次发送数据都需要建立连接，且每次都只能传送全部的页面数据
* 只使用首部的`Expires`和`If-Modified-Since`作为缓存失效的标准
<br/>

**HTTP 1.1**
* 引入持久连接，默认不关闭，复用连接，不用声明`connect:keep-alive`，连接时长通过首部的`keep-alive`来设置
* 引入管道机制，同一个连接内，客户端可以同时发送多个请求
* 新增`E-tag`、`If-Match`、`If-Not-Match`来控制缓存失效
* 支持断点续传，通过`Range`来实现
* 使用虚拟网络，一台物理机可能存在多个虚拟主机，并且共享一个IP地址，首部需要指定`HOST`
* 新增`PUT`、`PATCH`、`OPTIONS`、`DELETE`

**HTTP 2.0**
HTTP2.0两个非常重要的概念，分别是帧和流，帧代表数据传输的最小单位，每个帧都有序列标识属于哪个流；流就是多个帧组成的数据流，一个流标识一个请求。HTTP2.0的主要特征：

* **二进制分帧**：HTTP 1.x的解析是基于文本的，存在天然缺陷，需要兼容的场景必然很多，二进制则只识别0和1，HTTP 2.0开始协议的解析使用二进制格式，方便且强大
* **多路复用**：HTTP 2.0支持多路复用，一个TCP连接可以存在多条流，也就是多个请求，服务端可以通过帧的标识判断属于哪个请求，通过重新排序还原请求。多路复用允许并发多个请求，每个请求及该请求的响应不需要等待其他的请求或响应，避免了队头阻塞的问题，不会因为一个请求耗时严重就影响到其他的请求
* **头部压缩**：HTTP 1.x头部带有大量的信息，每次请求都需要重复发送，HTTP 2.0使用encoder减少传输的头部大小，通讯双方各自cache一份头部的field表，避免重复头部的传输，减少传输的大小
* **服务端推送**：会将客户端需要的js、img、css伴随index.html一起发送的客户端

**HTTP 3.0**
HTTP 3.0是Google在UDP协议的基础上增加流量控制、有序交付、重传、多路复用、TSL加密等功能构成QUIC协议，用在了HTTP 3.0

* **避免包阻塞**：多个流的数据包在TCP连接上传输的时候，若一个流的数据包传输出现，问题，整个TCP连接都需要等待重传，影响其他流的数据传输。但QUIC协议实现了不同流数据的互不干扰
* **快速重启会话**：基于TCP的链接是通过两端的IP和端口和协议来建立的，在切换网络环境之后要重新建立连接，QUIC协议使用UUID来标识连接，在网络环境变化后，只要UUID不变，不必握手建立连接

## 七. HTTP特点

**优点**
* 灵活可扩展：一个语法只规定了基本格式，内容上不仅可以传输文本，还可以传输图片、文件、视频等
* 可靠传输：是TCP中的一种，能够提供可靠传输
* 无状态：不记忆连接内容，会减少网络开销

**缺点**
* 无状态：不记忆连接内容，有些场景下需要保存顾客信息等
* 明文传输：报文使用文本形式，给攻击者带来便利
* 安全问题：不验证通信方的身份，可能会遭遇伪装；无法证明报文的完整性，所以有可能遭遇篡改
* 队头阻塞：当http开启长连接之后，共用一个TCP连接，请求时间过长时，其他请求只能处于阻塞状态

> 长连接的开启，可以在首部添加`connection: keep-alive`
> 队头阻塞的解决办法：
> * 并发连接：增加队列任务，并发进行多个连接
> * 域名分片：在域名上分出多个二级域名，处理多个任务队列

## 八. 代理

代理服务器就是客户端和服务端之间的“中间商”，即HTTP请求通过代理服务器转发给服务器，再将服务器的响应返回给客户端的行为。代理服务器可以用来作为缓存服务器，也可以用来隐藏用户身份（正向代理）或者服务器身份（反向代理）增加安全性。

* **正向代理**：客户为从源服务器获取内容，向代理服务器发起请求，指定目标访问服务器，转交请求获得内容后返回给客户端
* **反向代理**：客户端向代理服务器发起请求，代理服务器收到需求后判断请求的目标服务器，得到结果后将数据反馈给客户端。Nginx就是优秀的反向代理服务器，用户不需要知道服务端是谁，只需要获得最后的数据结果就可以了

## 九. HTTP和HTTPS的区别

上面有提到过HTTP协议没有任何安全校验逻辑，存在数据被篡改、伪装身份等安全问题，HTTPS就是为了解决这些问题的，HTTPS其实就是将通信层替换成TSL/SSL协议的HTTP。HTTP直接和TCP通信，而HTTPS变成先和SSL通信，再由SSL和TCP进行通信，由此拥有了SSL的HTTPS加密、证书和完整性保护的能力。

**两种加密机制**
* **对称密钥加密**：对称密钥加密，就是加密密钥和解密密钥是相同的密码体制。如果密钥具有固定长度，其可枚举范围是有限的，就可以计算出最终的密钥，其安全性有待考量。但如果密钥长度足够长，穷举破解就是不可能的了。但双方共用相同的密钥，密钥泄露的风险很高。
* **非对称密钥加密**：非对称密钥加密，有两把密钥，一把叫做私有密钥，一把叫做公开密钥。整个加密过程是发送密文的一方使用对方的公钥进行加密处理，对方收到加密的信息后，使用自己的私有密钥进行解密。

<div style="display:flex;justify-content:center;"><img src="https://zhangmingemma.github.io/dist/images/2022-10-17/3.png" style="display:inline-block; margin-bottom:16px; width:500px;"></div>

**密钥**
两种加密方式都涉及到公钥，似乎每个用户都知道所有用户的公钥，那是不是就可以有人伪装身份达到不法的目的。这里就要依赖认证机构，每个实体都可以向认证机构CA申请证书，证书里面包含其公钥及其拥有者的信息、数字签名Hash值和Hash算法。EV SSL证书就是一种典型的示例，通过认证的Web网站地址栏的背景色是绿色的，左侧还显示了SSL证书中记录的组织名称和颁发证书的认证机构的名称。

**CA证书校验步骤**
CA证书中的Hash值，其实就是证书的私钥加密后的值，客户端得到证书后，利用证书中的公钥去解密Hash的值，得到Hash-a；然后再利用证书内的签名Hash算法去生成一个Hash值Hash-b，如果相等，表明证书证书，服务端可被信任。

**HTTPS采用混合加密机制**

非对称加密相比对称加密更安全，但效率更低，因此HTTPS采用的是混合加密机制。就是采用对称加密的方式对以后要使用的密钥进行加密，确保交换的密钥安全的前提下，使用密钥进行通信。SSL的握手过程包含：

* 首先，客户端A访问服务端B时，会生成一个随机数1，把随机数1、自己支持的SSL版本号以及加密算法等信息告诉服务器B
* 服务器B收到后，记下加密算法，服务端B也会生成一个随机数2，并将随机数2、选择的加密算法和自己的CA证书一起返回给客户端A
* 客户端A收到后，会先校验CA证书的有效性，无效则发出警告；有效则会生成随机数3，然后用证书中的公钥加密随机数3发送给客户端B
* 服务端B收到后，会用证书中的私钥进行解密，得到真正的随机数3，双方通过随机数1、2、3生成一个对话密钥。之后的通信都是校验这个对话密钥，用到的就是对称加密，一般是AES算法
* 客户端A通知服务端B，指明以后要用对话密钥来完成通信，握手过程结束
* 服务端B通知客户端A，指明以后要用对话密钥来完成通信，握手过程结束
* SSL通道就建立好了，就可以开始进行通信了

**Fiddle抓包，如何截获https请求**

首先`fiddler`截获客户端浏览器发送给服务器的`https`请求，此时还未建立握手。
* `fiddler`向服务器发送请求进行握手，获取到服务器的CA证书，用根证书公钥进行解密，验证服务器的数据签名，获取到服务器CA证书公钥
* `fiddler`伪造自己的CA证书，冒充服务器证书传递给客户端浏览器，客户端浏览器也验证CA证书
* 客户端浏览器生成`https`通信用的对称密钥，用`fiddler`伪造的证书公钥加密后传递给服务器，被`fiddler`截获
* `fiddler`将截获的密文用自己伪造的证书的私钥解开，获取h`https`通信用的对称密钥
* `fiddler`将对称密钥用服务器证书公钥加密传递给服务器，服务器用私钥解开后建立信任，握手完成，开始用对称密钥进行加密通信
* `fiddler`收到服务器的密文，用对称密钥解开，获得服务器发送的铭文，再次加密传递给客户端

<b style="display:block;margin-top:48px">参考文献</b>
* <a href="https://juejin.cn/post/6844903844216832007" target="_blank">前端基础篇之HTTP协议</a>
* 图解HTTP
* 计算机网络 谢希仁著
* <a href="https://juejin.cn/post/6857287743966281736" target="_blank">查缺补漏 巩固你的HTTP知识体系</a>

