## 组件式开发

讲完数据双向绑定，可以再来理解一下Vue的组件式开发的概念:
> Vue允许小型、独立、可重复使用的组件构建大型应用，几乎任意类型的应用界面都可以抽象成一个组件树。Vue将组建抽象成一个高度封装过的函数，我们只需要在其中定义必要的属性，比如说父组件传入数据的prop，页面模板，交互逻辑之类的，就可以将一部分功能逻辑封装为一个可重复利用，独立的组件。

**那么Vue提供的组件封装和我们自己用原生JS封装组件之间有什么样的优势呢？**

Vue的组件封装：<br/>
<img style="height:160px;" src="https://zhangmingemma.github.io/dist/images/2018-10-15/vue-component1.png">
<img style="height:160px;" src="https://zhangmingemma.github.io/dist/images/2018-10-15/vue-component2.png">

JS原生组件封装：<br/>
<img style="width:400px;" src="https://zhangmingemma.github.io/dist/images/2018-10-15/vue-component3.png">

二者相比之下，Vue组件的优势就很明显了：<br/>
* **可读性：**我们可以看到原生语言封装的组件，页面模板的定义、DOM交互、数据请求都混杂在一起，可读性较差，而Vue的组件封装中页面模板、交互逻辑、CSS样式和我们单独写页面是很类似的，可读性较强;<br/>
* **可扩展性：**Vue的组件能够轻松的在页面模板或者交互逻辑中扩展新的功能，而原生语言封装的组件在扩展过程中则需要考虑会不会牵动其他的组件逻辑，以及对已有逻辑的更改，可扩展性较差；<br/>
* **可维护性：**Vue注册一个组件之后，组件的更新和渲染都是独立的，因此当我们对其中一个组件进行更改的时候，其他组件不会受到影响

## 生命周期

Vue的生命周期是指Vue从创建实例到实例销毁所经历的一系列过程，可以看到在vue一整个的生命周期中会有很多钩子函数提供给我们在vue生命周期不同的时刻进行操作, 我们一一详解:

| 钩子 | 状况 | 可进行的操作 | 
| ------ | ------ | ------ |
| beforecreate | 只是一个空壳，无法访问到数据和真实的dom | 添加loading |
| created | 实的DOM无法访问，已经可以访问数据，也可以更改数据，此时更改数据不会触发updated函数，不会触发其他的钩子函数 | 获取初始数据、结束loading |
| beforemount | 虚拟dom已经创建完成，还无法访问真实的DOM,此时更改数据也不会触发updated，不会触发其他的钩子函数，是渲染前最后一次更改数据的机会 | 初始数据的获取 |
| mounted | 组件已经出现在页面中，数据、真实dom、事件都挂载好了 | 操作真实dom |
| beforeupdate | 当组件或实例的数据更改之后，会立即执行beforeUpdate，因此这个时候数据已经更新，vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染 | 不做什么 |
| updated | 数据已经更改完成，dom也重新render完成 | 操作更新后的真实dom |
| beforedestroy | 调用$destroy方法后，立即执行beforeDestroy | 清除计时器、清除非指令绑定的事件等善后 |
| destroyed | Observer、Watcher都已经解绑，事件监听器都被移除，子实例也都会被销毁，修改数据得不到响应了，但原生DOM还存在 | 不做什么 |

备注：
* 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 **vm.$nextTick** 替换掉 mounted
* **Vue 异步执行 DOM 更新**。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。

## 小知识点

### v-if和v-show
* v-show中，元素是一直存在的，当v-show为false时，元素display:none只是隐藏了而已。
*  v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。

so，一般的，v-if有更高的切换消耗，而v-show有更多的初始化渲染消耗。
so，如果需要频繁的切换而对安全性无要求，使用v-show。如果在运行时，条件不可能改变，则使用v-if较好。

### vuex
vuex是一种状态管理模式，就是将所有的组件共享的状态集中进行管理，在数据更新之后就会统一的改变各个组件的状态。里面有一些关键的模块，
* state是用来存放共享的数据的，
* getters用来过滤数据，避免对庞大的数据中每一部分都要提交或者更新，
* mutation定义修改数据的逻辑，
* action用来提交修改，最终实现数据的统一更新

### Vue 与 React的区别

React 和 Vue 有许多相似之处，它们都有：

* 使用 Virtual DOM
* 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。
* 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。

React 和 Vue 之间的区别：

* 在 React应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上述的子树问题限制。
* 在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写JavaScript 的一种语法糖。Vue 也提供了渲染函数，甚至支持 JSX。然而，我们默认推荐的还是HTML模板。
* Vue 提供了 Vue-cli 脚手架，能让你非常容易地构建项目，包含了 Webpack，Browserify，甚至 no build system。React 在这方面也提供了 create-react-app，但是现在还存在一些局限性：它不允许在项目生成时进行任何配置，而 Vue 支持 Yeoman-like 定制。它只提供一个构建单页面应用的单一模板，而 Vue 提供了各种用途的模板。它不能用用户自建的模板构建项目，而自建模板对企业环境下预先建立协议是特别有用的。
* Vue 和 React 都提供了强大的路由来应对大型应用。Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。