<!-- ---
title: Vue基础系列之响应式原理
date: 2022-11-13
tags: Vue基础系列
set: BaseVue
--- -->

Vue会根据Vue模板生成`VDOM`结构，然后用原生的DOM方法依次创建VDOM结构中的每一个节点，然后将它们挂载成一棵DOM子树，并插入页面，就可以得到真正的HTML。这个过程中同时也要在这个生成真实DOM的过程中，Vue还注入了响应式系统，可以根据数据变化自动更新视图，以及根据视图自动更新数据。响应式系统的核心理念就是`Object.defineProperty`+`发布-订阅者`模式。

### 一. Vue实例初始化

Vue实例初始化的过程中主要包含以下几点：
* 初始化`$options`，这一步就是把组件配置`options`直接保存为实例的`$options`属性，以供后面的各种初始化使用
* 调用`initProxy`方法初始化`proxy`代理。如果浏览器支持proxy，Vue会为当前实例生成一个代理对象，以它作为render函数的调用者，以提高性能，如果不支持，则该代理就是当前实例自身。
* 调用`initLifecycle`初始化组件生命周期。这里主要是初始化一些与生命周期相关的实例属性，如`$children`、`_watcher`、`_isMounted`等
* 调用`initEvents`初始化组件化事件属性，主要是定义`_events`属性，该属性后面将用于存储与当前组件相关的事件监听，挂载阶段才会为其赋值
* 调用`initRender`初始化与渲染相关的实例属性和方法。包括初始化`_vnode`、`$slots`、`-c`、`$attrs`和`$listeners`等
    * `_vnode`将在挂载阶段保存当前组件对应的虚拟节点
    * `$slots`用于保存插槽内容
    * `_c`用于渲染真实DOM的方法，在浏览器环境下，它主要基于`document.createElement`实现
    * `$attrs`和`$listeners`用于保存来自父组件的属性和监听函数注入
* beforeCreate生命周期钩子函数被调用
* 调用`initInjections`初始化注入
* 调用`initState`初始化组件状态，这里分别调用了`initProps`、`initMethods`、`initData`、`initComputed`和`initWatch`来初始化配置的`props`、`methods`、`data`、`computed`和`watch`。这一步骤中会构建响应系统，为`data`生成一个`Observer`观察者对象，这样就能够对变量的变化进行观测。
* 调用`initProvide`初始化`provide`
* 初始化完毕，调用`created`钩子函数

### 二. Observer

在`initData`这一部分就会实现响应式，主要做两件事情，一是将data上面的数据代理到`vm`上，二是将通过执行`observer`将所有data绑定`defineProperty`，定义的每个属性进行`getter/setter`操作。

```javascript
export class Observer {
    value: any;
    dep: Dep;
    vmCount: number;
    constructor(value: any) {
        this.value = value
        this.dep = new Dep()
        this.vmCount = 0
        // observe的时候会先检测是否已经有__ob__对象存放Observer实例，防止重复绑定
        def(value, '__ob__', this)
        if (Array.isArray(value)) {
            // 如果是数组，先重写数组的变异方法如push/shift/pop/unshift/splice，达到监听数组数据变化响应的效果。
            const argument = hasProto ? protoAugment : copyAugment
            augment(value, arrayMethods, arrayKeys)
            // 如果是数组则需要遍历数组的每一个成员进行observe
            this.observeArray(value)
        } else {
            this.walk(value)
        },
        walk(obj: Object) {
            const keys = Object.keys(obj)
            for(let i=0; i<keys.length; i++) {
                defineReactive(obj, keys[i], obj[keys[i]])
            }
        }
    }
}
```

其中`defineReactive`就是核心的`Object.defineProperty`部分

```javascript
export function defineReactive (
    obj: Object,
    key: string,
    val: any,
    customSetter?: Function
) {
    const dep = new Dep() // 依赖收集
    const property = Object.getOwnPropertyDescriptor(obj, key)
    if (property && property.configurable === false) {
        return
    }
    // 如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter
    const getter = property && property.get
    const setter = property && property.set
    let childOb = observer(val)
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
            // 如果原有对象拥有getter方法则执行
            const value = getter ? getter.call(obj) : val
            if (Dep.target) {
                dep.depend()
                if (childOb) {
                    // 子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend
                    childOb.dep.depend()
                }
                if (Array.isArray(value)) {
                    // 是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归
                    dependArray(value)
                }
            }
            return value
        },
        set: function reactiveSetter(newVal) {
            // 通过getter方法获取当前值，与新值进行比较，不一致执行
            const value = getter ? getter.call(obj) : val
            if (newVal == value || (newVal !== newVal && value !== value)) {
                return 
            }
            if (setter) {
                // 如果原本对象拥有setter方法则执行setter
                setter.call(obj, newVal)
            } else {
                val = newVal
            }
            childOb = observer(newVal)
            dep.notify()
        }
    })
  
}
```

其中`getter`方法：
* 先为每个data声明一个`Dep`实例对象，被用于`getter`时执行`dep.depend()`进行收集相关的依赖
* 根据`Dep.target`来判断是否收集依赖，还是普通取值

其中`setter`方法：
* 获取新的值并进行`observer`，保证数据响应式
* 通过`dep`对象通知所有观察者去更新数据，从而达到响应式效果

<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-11-13/1.png">

### 三. Watcher

Watcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Dep的subs中，数据变动的时候Dep会通知Watcher实例，然后由Watcher实例回调cb进行视图的更新。

```javascript
export default class Watcher {
    constructor (
        vm: Component,
        expOrFn: string | Function,
        cb: Function,
        options?: Object
    ) {
        this.vm = vm
        vm._watchers.push(this)
        run() {
            if (this.active) {
                // get操作在获取在获取value本身会执行getter从而调用update更新视图
                const value = this.get()
                if (
                    value != this.value ||
                    isObject(value) ||
                    this.deep
                ) {
                    const oldValue = this.value
                    this.value = value
                    if (this.user) {
                        try {
                            this.cb.call(this.vm, value, oldValue)
                        } catch(e) {
                            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
                        }
                    } else {
                        this.cb.call(this.vm, value, oldValue)
                    }
                }
            }
        }
    }
}
```

### 四. Dep

被Observer的data在触发 getter 时，Dep 就会收集依赖的 Watcher ，其实 Dep 就像刚才说的是一个书店，可以接受多个订阅者的订阅，当有新书时即在data变动时，就会通过 Dep 给 Watcher 发通知进行更新。

```javascript
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;
  constructor () {
    this.id = uid++
    this.subs = []
  }
  /*添加一个观察者对象*/
  addSub (sub: Watcher) {
    this.subs.push(sub)
  }
  /*移除一个观察者对象*/
  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }
  /*依赖收集，当存在Dep.target的时候添加观察者对象*/
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }
  /*通知所有订阅者*/
  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}
```

### 总结

Vue 中初始化渲染时，视图上绑定的数据就会实例化一个 `Watcher`，依赖收集就是是通过属性的 `getter` 函数完成的，文章一开始讲到的 `Observer` 、`Watcher` 、`Dep` 都与依赖收集相关。其中 `Observer` 与 `Dep`是一对一的关系， `Dep` 与 `Watcher` 是多对多的关系，`Dep` 则是 `Observer` 和 `Watcher` 之间的纽带。依赖收集完成后，当属性变化会执行被 `Observer` 对象的 `dep.notify()` 方法，这个方法会遍历订阅者（`Watcher`）列表向其发送消息，`Watcher` 会执行 `run` 方法去更新视图，我们再来看一张图总结一下：

<img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-11-13/2.png">

* 在 Vue 中模板编译过程中的指令或者数据绑定都会实例化一个 `Watcher` 实例，实例化过程中会触发 `get()` 将自身指向 `Dep.target`;
* `data`在 `Observer` 时执行 `getter` 会触发 `dep.depend()` 进行依赖收集;依赖收集的结果：  1. `data`在 `Observer` 时闭包的`dep`实例的`subs`添加观察它的 `Watcher` 实例；2. `Watcher` 的`deps`中添加观察对象 `Observer`时的闭包`dep`；
* 当`data`中被 `Observer` 的某个对象值变化后，触发`subs`中观察它的`watcher`执行 `update()` 方法，最后实际上是调用`watcher`的回调函数`cb`，进而更新视图