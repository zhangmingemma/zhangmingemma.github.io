<!-- ---
title: JS基础系列之垃圾回收机制
date: 2022-10-28
tags: JS基础系列
set: BaseJS
--- -->

在任何程序语言中，内存的生命周期基本是一致的：
* 分配所需要的内存
* 使用分配到的内存
* 不需要使用时，释放内存

在`JS`中，创建变量(对象，字符串)的时候会自动进行内存分配，并且在不使用它们的时候自动释放，这个释放的过程就被称为**垃圾回收**。如果这些不使用的内存，没有被释放，就叫**内存泄漏**。

### 一. 内存泄漏

常见的内存泄漏的情况

#### 1. 意外声明的全局变量

意外声明全局变量是最常见但也最容易修复的内存泄漏问题。下面的例子，解释器会把变量`name`当做`window`属性来创建。不会消失，也不会被清理。解决办法就是在变量前加上声明符号`var`
、`let`、`const`

```javascript
function setName() {
    name="Gemma"
}
```

#### 2. 被遗忘的定时器

定时器也可能会悄悄导致内存泄漏。下面的例子中，在定时器内引用了外部变量，定时器一直在运行，`name`一直占用内存，垃圾回收就一直不会清理

```javascript
let name = 'Gemma'
setInterval(() => {
    console.log(name)
},100)
```

#### 3. 使用不当的闭包

下面的闭包只要`outer`函数存在，就不能清理变量`name`，因为一直被闭包引用，如果`name`的内容很大，那就会有很大的问题

```javascript
let outer = function() {
    let name = 'Gemma'
    return function() {
        return name
    }
}
```

#### 4. 未清理的DOM引用

DOM元素的生命周期正常情况下取决于是否挂载在`DOM`树上，当元素从`DOM`上移除的时候就可以被销毁了。但如果`DOM`元素在JS中持有引用，想要彻底删除这个元素，就需要把两个引用都清除才可以被正常回收

```javascript
let elements = {
    btn: document.getElementById('btn')
}
function doSomething() {
    elements.btn.click()
}
function removeBtn() {
    document.body.removeChild(document.getElementById('btn'))
}
```

正确的回收的方式：
```javascript
elements.btn = null
```

### 二. 垃圾回收机制

JS中的垃圾回收是自动的，这个就是垃圾回收机制，垃圾回收程序每隔一段时间就会自动运行，回收不会被再次使用的变量。垃圾回收机制常见的有两种，标记清理和引用计数

#### 1. 标记清理

是`JS`最常见的垃圾回收策略。当变量进入上下文，比如函数内部声明一个变量，这个变量就会被加上`存在于上下文`的标记，而不在上下文的变量，比如函数外部声明的全局变量，逻辑上讲永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能会被用到，当变量离开上下文的时候，也会被加上`离开上下文`的标记

垃圾回收程序运行的时候，就会标记内存中存储的所有变量。然后，它将所有在上下文的变量，以及被上下文中的变量引用的变量标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到他们了，随后垃圾回收的时候就会一次性清理。

#### 2. 引用计数法

另一种没那么常用的垃圾回收策略是引用计数法。其思路是每个值都记录它被引用的次数。声明变量并给她赋一个引用值时，这个值得引用数为1。如果同一个值又被赋给另一个变量，那么引用数+1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下运行的时候就会释放引用数为0的值得内存。

引用计数有一个比较严重的问题就是循环引用，在下面这个例子中`objA`和`objB`相互引用，引用数都是`2`。在函数结束后，他们的引用计数都不会变成`0`，因此永远不会被释放

```javascript
function problem() {
    let objA = new Object()
    let objB = new Object()
    objA.someOtherObj = objB
    objB.someOtherObj = objA
}
```
