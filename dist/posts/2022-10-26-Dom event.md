<!-- ---
title: JS基础系列之DOM事件
date: 2022-10-26
tags: JavaScript
set: BaseJS
--- -->

事件发生时会在元素节点与根节点之间按照特定的顺序传播，路径所经过的所有节点都会收到该事件，这个传播过程就是**DOM事件流**

### 1. 事件流

**事件流是事件在目标元素和顶层元素间的触发顺序**，事件流包含两种方式：
* **事件捕获**：事件由最顶层逐级向下传播，直至到达目标元素
* **事件冒泡**：事件由第一个被触发的元素接收，然后逐级向上传播

W3C采用的是折中的方式，规定先捕获再冒泡，一个事件就此分为了三个阶段：

* **捕获阶段**：事件从最顶层元素`window`一直传递到目标元素的父元素
* **目标阶段**：事件到达目标元素，如果事件指定不冒泡，那就会在这里终止
* **冒泡阶段**：事件从目标元素父元素向上逐级传递直到最顶层window

那事件是不是在路径上每个元素都会触发两次，`DOM`的`addEventListener()`中第三个参数就决定了事件是在捕获阶段生效，还是在冒泡阶段生效。

```javascript
element.addEventListener(event, function, useCapture)
```

* **event**：必须，字符串，指定事件名
* **function**：必须，指定事件触发时的执行函数
* **useCapture**：可选，布尔值，指定事件是否在捕获或冒泡阶段执行，true在捕获阶段执行，false是在冒泡阶段执行，也是默认值

### 2. 事件委托

事件委托就是利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件，例如说

```javascript
<ul id="myLinks">
    <li id="goSomewhere">Go somewhere</li>
    <li id="doSomething">Do something</li>
    <li id="sayHi">Say hi</li>
</ul>
```

上面的列表中如果要监听三个元素，并执行事件

```javascript
let item1 = document.getElementById("goSomewhere");
let item2 = document.getElementById("doSomething");
let item3 = document.getElementById("sayHi");
item1.addEventListener("click", (event) => {
    location.href = "http://www.wrox.com ";
});
item2.addEventListener("click ", (event) => {
    document.title = "I changed the document 's title";
});
item3.addEventListener("click", (event) => {
    console.log("hi");
});

```

但会有大量的雷同，去指定事件处理程序的代码，**使用事件委托，只要给所有元素共同的祖先节点添加一个事件处理程序，就可以解决问题。**

```javascript
let list = document.getElementById("myLinks");
list.addEventListener("click", (event) => {
    let target = event.target;
    switch (target.id) {
        case "doSomething":
            document.title = "I changed the document's title";
            break;
        case "goSomewhere":
            location.href = "http:// www.wrox.com";
            break;
        case "sayHi":
            console.log("hi");
            break;
    }
});
```

事件委托的优势是：

* `document`对象随时可用，任何时候都可以给它添加事件处理程序，这意味着只要页面渲染出可点击的元素，就可以无延迟起作用
* 节省花在设置页面事件处理程序上的事件，只指定一个事件处理程序既可以节省DOM引用，也可以节省事件
* 减少整个页面所需的内存，提升整体性能