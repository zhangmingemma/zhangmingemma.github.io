<!-- ---
title: JS基础系列之数据类型判断
date: 2022-10-26
tags: JavaScript
set: BaseJS
--- -->

JS中数据类型的判断有很多方法，常见的就有`typeof`和`instanceof`等

### 1. typeof

对于基本数据类型`null`、`undefined`、`number`、`string`、`boolean`，可以使用`typeof`来判断数据类型

```javascript
console.log(typeof 1)           // number
console.log(typeof '')          // string
console.log(typeof true)        // boolean
console.log(typeof null)        // object
console.log(typeof undefined)   // undefined
console.log(typeof {})          // object
console.log(typeof [])          // object
console.log(typeof (() => {}))  // function
```

### 2. instanceof

从上面的例子中，可以看到`typeof`的判断结果有些差强人意，部分数据类型没有办法用来区分，引用类型都会返回`object`。于是`instanceof`应运而生，用来判断一个变量是否是某个对象的实例，所以对于引用类型我们可以使用`instanceof`来判断。**`instanceof`本质上就是用来检测构造函数的`prototype`属性是否出现在某个实例对象的原型链上**

```javascript
console.log(1 instanceof Number)             // false
console.log('' instanceof String)            // false
console.log(true instanceof Boolean)         // false
console.log({} instanceof Object)            // true
console.log([] instanceof Array)             // true
console.log( (() => {}) instanceof Function) // true
```

我们可以看到前三个非常怪，后面三个可以得到正确的结果，但是用数据类型对象创建的实例就是对应的类型

```javascript
console.log(new Number(1) instanceof Number)        // true
console.log(new String('') instanceof String)       // true
console.log(new Boolean(true) instanceof Boolean)   // true
```

### 3. constructor

constructor的本质和`instanceof`差不多，是判断判断对象的构造函数
```javascript
console.log((1).constructor == Number)             // true
console.log(('').constructor == String)            // true
console.log((true).constructor == Boolean)         // true
console.log(({}).constructor == Object)            // true
console.log(([]).constructor == Array)             // true
console.log(( (() => {})).constructor == Function) // true
```

可以看到基本上可以准确地检验出最常见的数据类型

### 4. Object.prototype.toString.call()

```javascript
const a = Object.prototype.toString
console.log(a.call(1))          // [object Number]         
console.log(a.call(''))         // [object String]
console.log(a.call(true))       // [object Boolean]
console.log(a.call({}))         // [object Object]
console.log(a.call([]))         // [object Array]
console.log(a.call( (() => {})))// [object Function]
console.log(a.call(null))       // [object Null]
console.log(a.call(undefined))  // [object Undefined]

function Fn() {}
Fn.prototype = new Array()
var f = new Fn()
console.log(a.call(f) == Fn)    // false
console.log(a.call(f) == Array) // false
```
可以看到所有的数据类型都可以准确判断

### 5. 总结

最终总结出来：

* **typeof**，只能用来检测基本数据类型和函数，无法区分引用数据类型，对于`null`、`数组`、`对象`都会返回`Object`
* **instanceof**，可以使用`object instanceof constructor`用来检测构造函数的原型是否在参数`object`的原型链上。可以正常检测数组，对象和函数，不能检测对象字面量创建的基本类型，如字符串，数组和布尔值，通过`new`关键字创建的基本数据类型才能正常检测，也不能检测`null`和`undefined`
* **constructor**，返回对象的构造函数，可以检测基本数据类型和引用数据类型，但改变原型指向后，属性会跟着改变，检测也会变得不严谨，也不能检测`null`和`undefined`
* **Object.prototype.toString.call**，可以检测所有数据类型，包含`null`和`undefined`，并不会向`constructor`那样随着对象原型指向的改变而改变