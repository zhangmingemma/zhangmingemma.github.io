<!-- ---
title: Vue基础系列之Vue2和Vue3的区别
date: 2022-11-12
tags: Vue基础系列
set: BaseVue
--- -->

Vue3是Vue2重构后的版本，有很多地方都是不同的，这篇文章主要分析Vue2和Vue3的区别：

### 一. 生命周期
二者的生命周期大致的方法和功能是相同的，只是有一部分会存在差异
* `beforeCreate`和`created`被`setup`取代
* `beforeMount`更名为`onBeforeMount`
* `mounted`更名为`onMounted`
* `beforeUpdate`更名为`onBeforeUpdate`
* `updated`更名为`onUpdated`
* `beforeDestroy`更名为`onBeforeUnmount`
* `destroyed`更名为`onUnmounted`
* `onRenderTracked`，状态跟踪，是Vue3新引入的钩子函数，只有在开发环境有用，用于跟踪所有的响应式变量和方法，一旦页面有update，就会跟踪他们并返回一个event对象
* `onRenderTriggered`，状态触发，是Vue3新引入的钩子函数，只有在开发环境有用，用于跟踪发生改变的数据，同样返回一个event对象

### 二. 响应式原理
Vue2是使用`发布-订阅式` + `Object.defineProperty`实现的，存在的缺点就每次渲染是将`data`中的数据通过`Object.defineProperty`进行响应式或者双向绑定上，之后加的属性时不会被绑定上的，不会触发更新渲染。

Vue3是使用`发布-订阅式` + `Proxy`实现的，`Object.defineProperty`只能响应首次渲染时的属性，`Proxy`需要的是整体，不需要关心里面有什么属性，可以做更细致的事情，是`defineProperty`无法达到的。

**兼容性**
* `vue2.x`之所以只能兼容到IE8就是因为`defineProperty`无法兼容IE8,其他浏览器也会存在轻微兼容问题
* `proxy`的话除了IE，其他浏览器都兼容，这次vue3还是使用了它，说明vue3直接放弃了IE的兼容考虑，个人感觉已经没人用IE了

### 三. diff算法的提升

#### 1. 静态节点
在没有动态改变节点结构的模板指令（例如`v-if`和`v-for`）的情况下，节点结构保持完全静态。如果我们将一个模板分成由这些结构指令分隔的嵌套“块”，则每个块中的节点结构将再次完全静态。当我们更新块中的节点时，我们不再需要递归遍历DOM树 - 该块内的动态绑定可以在一个平面数组中跟踪。这种优化通过将需要执行的树遍历量减少一个数量级来规避虚拟DOM的大部分开销。

编译器积极地检测模板中的静态节点、子树甚至数据对象，并在生成的代码中将它们提升到渲染函数之外。这样可以避免在每次渲染时重新创建这些对象，从而大大提高内存使用率并减少垃圾回收的频率。

#### 2. 具体diff算法

**Vue2的diff算法**的详细步骤在<a href="https://zhangmingemma.github.io/#/post?file=2022-11-13-View%20Render">《Vue基础系列之视图渲染》</a>中有详细的介绍。大概可以分为4种情况：更新节点、新增节点、删除节点、移动节点位置。对比新老两个虚拟DOM，通过循环，每循环到一个新节点，，就去老节点列表里面找到和当前新节点相同的旧节点。如果在旧节点列表中找不到，说明当前节点是需要新增的节点，我们就需要进行创建节点并插入视图的操作；如果找到了，就做更新操作；如果找到的旧节点与新节点位置不同，则需要移动节点等。为了加快对比过程，有4种优化策略：
* 老数组的开始与新数组的开始
* 老数组的结尾与新数组的结尾
* 老数组的开始与新数组的结尾
* 老数组的结尾与新数组的开始

**Vue3的diff算法**的整体概念是首先从左往右进行比对，如果是相同的就进行更新比对，如果不相同则停止比对，并且记录停止的下标。再从右往左进行比对，如果是相同的就进行更新比对，如果不相同也停止比对，也进行记录停止的下标。通过这样左右进行比对，最后就可以把真正复杂部分进行范围锁定了。左右比对完之后，如果新节点已经比对完了，老节点列表还存在节点未比对，则删除老节点列表上的未比对的节点，如果老节点已经比对完了，新节点列表还存在未比对的节点则进行创建。如果新节点未比对完，老节点也未比对完，则进行最后最复杂的处理。
* 先把剩下的新节点处理成节点的 key 为 key, 节点下标为 value 的 Map；接着初始化一个长度为剩下未比对的新节点的长度的数组 newIndexToOldIndexMap，初始化每个数组的下标的默认值为 0。再循环剩下的旧节点，通过旧节点的 key 去刚刚创建的 Map 中查找，看看旧节点有没有在新节点中，如果旧节点没有 key 则需要通过循环剩下的新节点进行查找。如果旧节点在新节点中没找到，则说明该旧节点需要进行删除。如果找到了，则把找到的新节点的下标对应存储到上述的数组 newIndexToOldIndexMap 中，然后更新比对匹配到的新老节点。
* 把所有的旧节点比对完成后，就会得到一个刚刚收集的新节点的下标数组，然后对这个新节点的下标数组进行进行**最长递增子序列**查找得到一个最长递增子序列的下标数据。然后再进行循环左右对比完之后剩余新节点的下标，然后判断循环的下标是否被上述的数组newIndexToOldIndexMap 进行收集了，如果没被收集到则说明这个新节点需要进行创建，如果已经被收集了则判断该循环的下标是否在上面计算得到的最长递增子序列中，如果不在则需要对该循环节点进行移动操作。

因此Vue3相比Vue2的`diff`算法效率更高，速度更快

#### 3. typescript的支持

vue3提出`Composition API`不需要通过指定一长串选项来定义组件，允许用户像编写函数一样自由地表达、组合和重用有状态的组件逻辑，同时提供出色的`ts`支持

#### 4. 编译包的大小

vue2官方说的运行时打包师23k，但这只是没安装依赖的时候，随着依赖包和框架特性的增多，有时候不必要的，未使用的代码文件都被打包了进去，所以后期项目大了，打包文件会特别多还很大。在Vue 3中，我们通过将大多数全局API和内部帮助程序移动到Javascript的module.exports属性上实现这一点。这允许现代模式下的module bundler能够静态地分析模块依赖关系，并删除与未使用的module.exports属性相关的代码。模板编译器还生成了对`tree shaking`友好的代码，只有在模板中实际使用某个特性时，该代码才导入该特性的帮助程序。尽管增加了许多新特性，但Vue 3被压缩后的基线大小约为10 KB，不到Vue 2的一半。

#### 5. 响应式

Vue3定义响应式变量需要了解几个关键词，`ref`、`reactive`、`toRefs`、`toRef`。
* `ref`：当做简单的响应式变量
* `toRef`：把不是响应的对象转化为响应式
* `toRefs`：把响应式的`reactive`对象，分解成无数的响应式`Ref`

