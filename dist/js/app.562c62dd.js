(function(e){function t(t){for(var c,n,i=t[0],j=t[1],o=t[2],r=0,h=[];r<i.length;r++)n=i[r],Object.prototype.hasOwnProperty.call(a,n)&&a[n]&&h.push(a[n][0]),a[n]=0;for(c in j)Object.prototype.hasOwnProperty.call(j,c)&&(e[c]=j[c]);b&&b(t);while(h.length)h.shift()();return l.push.apply(l,o||[]),s()}function s(){for(var e,t=0;t<l.length;t++){for(var s=l[t],c=!0,n=1;n<s.length;n++){var i=s[n];0!==a[i]&&(c=!1)}c&&(l.splice(t--,1),e=j(j.s=s[0]))}return e}var c={},n={app:0},a={app:0},l=[];function i(e){return j.p+"js/"+({}[e]||e)+"."+{"chunk-14436ac0":"dfe8da39","chunk-a7c54b84":"896ebe9b","chunk-fb6f7452":"1641c6db"}[e]+".js"}function j(t){if(c[t])return c[t].exports;var s=c[t]={i:t,l:!1,exports:{}};return e[t].call(s.exports,s,s.exports,j),s.l=!0,s.exports}j.e=function(e){var t=[],s={"chunk-14436ac0":1,"chunk-a7c54b84":1,"chunk-fb6f7452":1};n[e]?t.push(n[e]):0!==n[e]&&s[e]&&t.push(n[e]=new Promise((function(t,s){for(var c="css/"+({}[e]||e)+"."+{"chunk-14436ac0":"e0a97d1c","chunk-a7c54b84":"67d0d1f2","chunk-fb6f7452":"9006a644"}[e]+".css",a=j.p+c,l=document.getElementsByTagName("link"),i=0;i<l.length;i++){var o=l[i],r=o.getAttribute("data-href")||o.getAttribute("href");if("stylesheet"===o.rel&&(r===c||r===a))return t()}var h=document.getElementsByTagName("style");for(i=0;i<h.length;i++){o=h[i],r=o.getAttribute("data-href");if(r===c||r===a)return t()}var b=document.createElement("link");b.rel="stylesheet",b.type="text/css",b.onload=t,b.onerror=function(t){var c=t&&t.target&&t.target.src||a,l=new Error("Loading CSS chunk "+e+" failed.\n("+c+")");l.code="CSS_CHUNK_LOAD_FAILED",l.request=c,delete n[e],b.parentNode.removeChild(b),s(l)},b.href=a;var p=document.getElementsByTagName("head")[0];p.appendChild(b)})).then((function(){n[e]=0})));var c=a[e];if(0!==c)if(c)t.push(c[2]);else{var l=new Promise((function(t,s){c=a[e]=[t,s]}));t.push(c[2]=l);var o,r=document.createElement("script");r.charset="utf-8",r.timeout=120,j.nc&&r.setAttribute("nonce",j.nc),r.src=i(e);var h=new Error;o=function(t){r.onerror=r.onload=null,clearTimeout(b);var s=a[e];if(0!==s){if(s){var c=t&&("load"===t.type?"missing":t.type),n=t&&t.target&&t.target.src;h.message="Loading chunk "+e+" failed.\n("+c+": "+n+")",h.name="ChunkLoadError",h.type=c,h.request=n,s[1](h)}a[e]=void 0}};var b=setTimeout((function(){o({type:"timeout",target:r})}),12e4);r.onerror=r.onload=o,document.head.appendChild(r)}return Promise.all(t)},j.m=e,j.c=c,j.d=function(e,t,s){j.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},j.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},j.t=function(e,t){if(1&t&&(e=j(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(j.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var c in e)j.d(s,c,function(t){return e[t]}.bind(null,c));return s},j.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return j.d(t,"a",t),t},j.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},j.p="/dist/",j.oe=function(e){throw console.error(e),e};var o=window["webpackJsonp"]=window["webpackJsonp"]||[],r=o.push.bind(o);o.push=t,o=o.slice();for(var h=0;h<o.length;h++)t(o[h]);var b=r;l.push([0,"chunk-vendors"]),s()})({0:function(e,t,s){e.exports=s("cd49")},"02cc":function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])('<p>之前的博客是用jekyll写的，总觉得用起来很不顺手，所以重构了一遍，用vue3来写博客，没有后台，文章存储在项目文件夹内，逻辑简单。之所以没有用VuePress、Jekyll之类的模板，是为了更多能力能够自己定制，也是拿Vue3.0来练手一个项目。本篇主要讲解第一部分，从项目文件夹内读取文章列表，并抽析单篇文章的标题、时间戳、标签、摘要等信息，作为首页文章列表展示。本系列其他文章：</p><ul><li><a href="https://zhangmingemma.github.io/#/post?file=2021-07-04-Blog%202">Vue3.0搭建博客 (二)：文章html渲染, 抽取目录</a></li><li><a href="https://zhangmingemma.github.io/#/post?file=2021-07-05-Blog%203">Vue3.0搭建博客 (三)：添加评论，部署github</a></li></ul><p>博客源码github: <a href="https://github.com/zhangmingemma/zhangmingemma.github.io" target="_blank">博客仓库地址</a>，读取列表的代码写在<code>ListHanlder.ts</code>中，文章标题解析写在<code>PostHandler.ts</code>中</p><h3>1. 获取文章列表</h3><p>我们封装一个整体的函数来获取文章列表信息，先用<code>require.context</code>获得文件夹内的文章列表文件名；再通过<code>axios</code> 来发起请求，获取本地文件，拿到Markdown文件的文本内容；最后通过函数<code>getPostInfo</code>解析获得单篇文章的基本信息。</p>',5),a=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" getAllPostContent = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"()"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" state = reactive({\n        "),Object(c["i"])("span",{class:"hljs-attr"},"postList"),Object(c["h"])(": [] "),Object(c["i"])("span",{class:"hljs-keyword"},"as"),Object(c["h"])(" IPost[]\n    })\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" files = "),Object(c["i"])("span",{class:"hljs-built_in"},"require"),Object(c["h"])(".context("),Object(c["i"])("span",{class:"hljs-string"},'"../../../public/posts"'),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])(", /\\.md/)\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (files && files.length) {\n        "),Object(c["i"])("span",{class:"hljs-built_in"},"Promise"),Object(c["h"])(".all(files.keys().map("),Object(c["i"])("span",{class:"hljs-keyword"},"async"),Object(c["h"])(" (path:string) => {\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" paths:string[] = path.split("),Object(c["i"])("span",{class:"hljs-string"},"'/'"),Object(c["h"])(")\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" fileName:string = paths.pop()!.replace("),Object(c["i"])("span",{class:"hljs-regexp"},"/\\.\\w+$/"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-string"},"''"),Object(c["h"])(")\n            "),Object(c["i"])("span",{class:"hljs-comment"},"// 博客部署到github后，访问的是域名根目录，因此这里需要重新定义线上环境访问dist/posts"),Object(c["h"])("\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" baseUrl:string = process.env.NODE_ENV === "),Object(c["i"])("span",{class:"hljs-string"},'"production"'),Object(c["h"])(" ? "),Object(c["i"])("span",{class:"hljs-string"},'"./dist/posts"'),Object(c["h"])(" : "),Object(c["i"])("span",{class:"hljs-string"},'"./posts"'),Object(c["h"])(" \n            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" info:IPost = "),Object(c["i"])("span",{class:"hljs-keyword"},"await"),Object(c["h"])(" getSinglePost(fileName)\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" info\n        })).then("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"res"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n            state.postList = res\n        })\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" {\n            ...toRefs(state)\n        }\n    }\n}\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" getSinglePost = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"fileName:string"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" post:AxiosResponse = "),Object(c["i"])("span",{class:"hljs-keyword"},"await"),Object(c["h"])(" axios.get("),Object(c["i"])("span",{class:"hljs-string"},[Object(c["h"])("`"),Object(c["i"])("span",{class:"hljs-subst"},"${getPostPath()}"),Object(c["h"])("/"),Object(c["i"])("span",{class:"hljs-subst"},"${fileName}"),Object(c["h"])(".md`")]),Object(c["h"])(")\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" info:IPost = getPostInfo(post.data)\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" info\n}\n")])],-1),l=Object(c["g"])("<p>关于Markdown的文件路径，有两点需要注意：</p><ul><li>Vue仅把 <code>public</code> 路径下的文件当做对外公开的目录，因此markdown文件必须要放在 <code>public</code> 文件夹下， <code>axios</code> 访问的文件根目录就是<code>public</code>。我这里所有的Markdown文件都放在了<code>public/posts</code>文件夹内。</li><li>博客<code>build</code>之后，<code>public</code>内的文件都会编译到<code>dist</code>文件夹内，部署到线上后，<code>axios</code>访问的根目录即项目文件，文章会访问不到。因此这里需要定义一下线上环境和生产环境的基础路径，线上为<code>./dist/posts</code>。</li></ul><h3>2. 解析文章标题、时间戳、标签</h3><p>首先，我们需要在markdown文件头部按照既定格式定义好标题、时间戳、标签，并注释掉，避免在文章渲染时将这些内容渲染出来</p>",4),i=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-markdown"},[Object(c["i"])("span",{class:"xml"},[Object(c["i"])("span",{class:"hljs-comment"},"\x3c!-- ---\ntitle: Test Title\ndate: 2016-11-20 \ntags: Vue3.0, Javascript\n--- --\x3e")]),Object(c["h"])("\n\n"),Object(c["i"])("span",{class:"hljs-section"},"### 标题1"),Object(c["h"])("\n内容1\n\n"),Object(c["i"])("span",{class:"hljs-section"},"### 标题2"),Object(c["h"])("\n内容2\n")])],-1),j=Object(c["i"])("p",null,"接下来要做的就是用正则规则把头部的内容提取出来了",-1),o=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" getPostInfo = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"data:string, fileName:string"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (!data) "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" {}\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" info:IPost = { "),Object(c["i"])("span",{class:"hljs-attr"},"name"),Object(c["h"])(": fileName }\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" content:string = data.split("),Object(c["i"])("span",{class:"hljs-string"},"'\\n'"),Object(c["h"])(").map("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"s"),Object(c["h"])(" =>")]),Object(c["h"])(" s.trim()).join("),Object(c["i"])("span",{class:"hljs-string"},"''"),Object(c["h"])(")\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" layout:RegExpMatchArray|"),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(" = content.match("),Object(c["i"])("span",{class:"hljs-regexp"},"/-+title: (.*?)date: (.*?)tags: (.*?)-+/"),Object(c["h"])(")\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (layout && layout.length >= "),Object(c["i"])("span",{class:"hljs-number"},"4"),Object(c["h"])(") {\n        info["),Object(c["i"])("span",{class:"hljs-string"},"'title'"),Object(c["h"])("] = layout["),Object(c["i"])("span",{class:"hljs-number"},"1"),Object(c["h"])("]\n        info["),Object(c["i"])("span",{class:"hljs-string"},"'date'"),Object(c["h"])("] = layout["),Object(c["i"])("span",{class:"hljs-number"},"2"),Object(c["h"])("]\n        info["),Object(c["i"])("span",{class:"hljs-string"},"'tags'"),Object(c["h"])("] = layout["),Object(c["i"])("span",{class:"hljs-number"},"3"),Object(c["h"])("].split("),Object(c["i"])("span",{class:"hljs-string"},"','"),Object(c["h"])(").map("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"s"),Object(c["h"])(" =>")]),Object(c["h"])(" s.trim())\n    }\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// 解析文章摘要"),Object(c["h"])("\n    info["),Object(c["i"])("span",{class:"hljs-string"},"'abstract'"),Object(c["h"])("] = getPostAbstract(data)\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" info\n}\n")])],-1),r=Object(c["g"])('<h3>3. 解析文章摘要</h3><p>解析文章摘要主要用到的库是<a href="https://github.com/pdubroy/marked-ast" target="_blank">marked-ast</a>,它能够通过正则表达式将文章转换为AST语法树，文本类型包含<code>list</code>、<code>heading</code>、<code>paragraph</code>、<code>code</code>、<code>blockquote</code>等</p><blockquote><p>引用内容</p></blockquote>',3),h=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-markdown"},[Object(c["i"])("span",{class:"hljs-section"},"### 标题1"),Object(c["h"])("\n文本内容\n"),Object(c["i"])("span",{class:"hljs-bullet"},"* "),Object(c["h"])("条目1\n\nconst a = 1 //代码块\n"),Object(c["i"])("span",{class:"hljs-quote"},"> 引用内容"),Object(c["h"])("\n")])],-1),b=Object(c["i"])("p",null,[Object(c["i"])("code",null,"marked-ast"),Object(c["h"])("解析后的AST语法树变成")],-1),p=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["h"])("[{\n    "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'heading'"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"text"),Object(c["h"])(": ["),Object(c["i"])("span",{class:"hljs-string"},"'标题1'"),Object(c["h"])("],\n    "),Object(c["i"])("span",{class:"hljs-attr"},"level"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"3"),Object(c["h"])("\n}, {\n    "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'paragraph'"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"text"),Object(c["h"])(": ["),Object(c["i"])("span",{class:"hljs-string"},"'文本内容'"),Object(c["h"])("]\n}, {\n    "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'list'"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"ordered"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-literal"},"false"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"body"),Object(c["h"])(": [{\n        "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'listitem'"),Object(c["h"])(",\n        "),Object(c["i"])("span",{class:"hljs-attr"},"text"),Object(c["h"])(": ["),Object(c["i"])("span",{class:"hljs-string"},"'条目1'"),Object(c["h"])("]\n    }]\n}, {\n    "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'code'"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"code"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'const a = 1'"),Object(c["h"])("\n}, {\n    "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'blockquote'"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"quote"),Object(c["h"])(": [{\n        "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'paragraph'"),Object(c["h"])(",\n        "),Object(c["i"])("span",{class:"hljs-attr"},"text"),Object(c["h"])(": ["),Object(c["i"])("span",{class:"hljs-string"},"'引用内容'"),Object(c["h"])("]\n    }]\n}]\n")])],-1),O=Object(c["i"])("p",null,"整理清楚之后，抽取摘要就非常容易了，我这里摘要限制500字，摘要内不展示代码，你也可以按照你的要求去解析语法树。",-1),d=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" markedAST = "),Object(c["i"])("span",{class:"hljs-built_in"},"require"),Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-string"},"'marked-ast'"),Object(c["h"])(")\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" getPostAbstract = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"text:string"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" ast:object[] = markedAST.parse(text.trim())\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" abstract:string = parseMarkAst(ast).slice("),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-number"},"500"),Object(c["h"])(")\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" abstract\n}\n\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" parseMarkAst = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"ast:IAst[]"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" result:string = "),Object(c["i"])("span",{class:"hljs-string"},"''"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (ast && ast.length) {\n        ast.map("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"astItem:IAst"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n            "),Object(c["i"])("span",{class:"hljs-comment"},"// 解析平铺的文本段落"),Object(c["h"])("\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (["),Object(c["i"])("span",{class:"hljs-string"},"'paragraph'"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-string"},"'heading'"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-string"},"'strong'"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-string"},"'em'"),Object(c["h"])("].indexOf(astItem.type) >= "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(") {\n                "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (astItem.text && astItem.text.length) {\n                    astItem.text.map("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"textItem:IAst"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n                        "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-keyword"},"typeof"),Object(c["h"])(" textItem === "),Object(c["i"])("span",{class:"hljs-string"},"'string'"),Object(c["h"])(") {\n                            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" noSpaceText = text.replaceAll("),Object(c["i"])("span",{class:"hljs-string"},"'\\n'"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-string"},"''"),Object(c["h"])(").trim()\n                            result += noSpaceText.replace("),Object(c["i"])("span",{class:"hljs-regexp"},"/<[^>]+>/g"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-string"},"' '"),Object(c["h"])(")\n                        } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-keyword"},"typeof"),Object(c["h"])(" textItem === "),Object(c["i"])("span",{class:"hljs-string"},"'object'"),Object(c["h"])(") {\n                            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" text = textItem?.text?.["),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])("]\n                            "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])("( text && "),Object(c["i"])("span",{class:"hljs-keyword"},"typeof"),Object(c["h"])(" text === "),Object(c["i"])("span",{class:"hljs-string"},"'string'"),Object(c["h"])(") {\n                                result += text.replaceAll("),Object(c["i"])("span",{class:"hljs-string"},"'\\n'"),Object(c["h"])(","),Object(c["i"])("span",{class:"hljs-string"},"''"),Object(c["h"])(").trim()\n                            }\n                        }\n                    })\n                }\n            }\n            "),Object(c["i"])("span",{class:"hljs-comment"},"// 解析嵌套列表"),Object(c["h"])("\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (astItem.type === "),Object(c["i"])("span",{class:"hljs-string"},"'list'"),Object(c["h"])(" && astItem.body && astItem.body.length) {\n                astItem.body.map("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"listItem:IAst"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n                    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (listItem.type === "),Object(c["i"])("span",{class:"hljs-string"},"'listitem'"),Object(c["h"])(") {\n                        result += parseMarkAst(astItem)\n                    }\n                })\n            } \n        })\n    }\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" result\n}\n")])],-1),u=Object(c["i"])("p",null,[Object(c["h"])("最终我们就可以获得摘要啦，图片展示的便是文件夹内的文章列表，抽取标题、时间戳、标签之后渲染为文章列表，进一步抽取摘要后渲染首页文章Block展示的效果~~~ "),Object(c["i"])("img",{src:"https://zhangmingemma.github.io/dist/images/2021-07-03/1.png",alt:""}),Object(c["h"])(" 以首页文章Block的展示为例")],-1),m=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-html"},[Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"template"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"v-for"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"(post, index) in postList"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},":key"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"index"'),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"article"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"v-if"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"post"'),Object(c["h"])(">")]),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"h1"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"@click"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"tapPost(post.name)"'),Object(c["h"])(">")]),Object(c["h"])("{{post.title}}"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"h1"),Object(c["h"])(">")]),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"abstract"'),Object(c["h"])(">")]),Object(c["h"])("{{post.abstract}}"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(">")]),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"@click"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"tapPost(post.name)"'),Object(c["h"])(">")]),Object(c["h"])("点我阅读更多..."),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(">")]),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"footer"'),Object(c["h"])(">")]),Object(c["h"])("\n            "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"footer-tags"'),Object(c["h"])(">")]),Object(c["h"])("\n                "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"blog-tag"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"v-for"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"tag in post.tags"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},":key"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"tag"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},":tag"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"tag"'),Object(c["h"])(">")]),Object(c["h"])("{{tag}}"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(">")]),Object(c["h"])("\n            "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(">")]),Object(c["h"])("\n            "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"span"),Object(c["h"])(">")]),Object(c["h"])("{{post.date}}"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"span"),Object(c["h"])(">")]),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"article"),Object(c["h"])(">")]),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"template"),Object(c["h"])(">")]),Object(c["h"])("\n")])],-1),g=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"default"),Object(c["h"])(" defineComponent({\n    setup() {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" router = useRouter()\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" listHandler = getAllPostContent()\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" tapPost = (name:string) {\n            setTimeout("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"()"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n                "),Object(c["i"])("span",{class:"hljs-built_in"},"window"),Object(c["h"])(".scrollTo({ "),Object(c["i"])("span",{class:"hljs-attr"},"top"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-attr"},"behavior"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'smooth'"),Object(c["h"])("})\n            })\n            router.push("),Object(c["i"])("span",{class:"hljs-string"},[Object(c["h"])("`/post?file="),Object(c["i"])("span",{class:"hljs-subst"},"${name}"),Object(c["h"])("`")]),Object(c["h"])(")\n        }\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" {\n            ...listHandler\n        }\n    }\n})\n")])],-1);function f(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n,a,l,i,j,o,r,h,b,p,O,d,u,m,g])}const v={};v.render=f;t["default"]=v},"256c":function(e,t,s){"use strict";s("ce75")},2863:function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])('<h3>聚类算法介绍</h3><p>聚类是将数据对象的集合分成相似的对象类的过程。使得同一个簇（或类）中的对象之间具有较高的相似性，而不同簇中的对象具有较高的相异性。按照聚类的尺度，聚类方法可被分为以下三种：基于距离的聚类算法、基于密度的聚类方法、基于互连性的聚类算法。其中基于距离的聚类算法是用各式各样的距离来衡量数据对象之间的相似度。基于密度的聚类算法主要是依据合适的密度函数等。基于互连性的聚类算法通常基于图或超图模型，将高度连通的对象聚为一类。</p><p>本文介绍的是Alex Rodriguez和Alessandro Laio在Science上发表的<a href="http://science.sciencemag.org/content/344/6191/1492" target="_blank">《Clustering by fast search and find of density peaks》</a>所提出的一种新型的基于密度的聚类算法。</p><h3>算法思想</h3><p>该算法的假设类簇的中心由一些局部密度比较低的点围绕, 并且这些点距离其他有高局部密度的点的距离都比较大.首先定义两个值：局部密度ρi以及到高局部密度点的距离δi，这两个值仅仅取决于两点之间的距离dij，且该距离满足三角不等式<br><img src="https://zhangmingemma.github.io/dist/images/2016-11-20/image1.png" alt></p><p>其中dc是一个截断距离, 是一个超参数.所以ρi相当于距离点i的距离小于dc的点的个数.由于该算法只对ρi的相对值敏感, 所以对dc的选择比较鲁棒, δi用于描述点i到其他较高密度点之间的最小距离：<br><img src="https://zhangmingemma.github.io/dist/images/2016-11-20/image2.png" alt></p><p>对于密度最大的点, 设置δi=maxj(dij).只有那些密度是局部或者全局最大的点才会远大于正常的相邻点间距.因此聚类中心被视为是δi值异常最大的点。</p><h3>聚类过程</h3><p>那些有着比较大的局部密度ρi和很大的δi的点被认为是类簇的中心. 局部密度较小但是δi较大的点是异常点.在确定了类簇中心之后, 所有其他点属于距离其最近的类簇中心所代表的类簇.具体的聚类过程可以从图1中看到，A图标识二维空间内的28个点，可以看到1和10两个点的密度最大，因此1和10被定义为聚类中心。右图是以ρi和为横坐标, 以δi为纵坐标, 这种图称作决策图。其中9和10两个点ρi值相似，但δi值却差异很大，因此9被归为点1的类簇，而10被归为另一类簇。所以，只有较高δi值和相对较高ρi值的点才会被视为聚类中心。26, 27, 28三个点的δi也比较大, 但是ρi较小, 所以是异常点. <img src="https://zhangmingemma.github.io/dist/images/2016-11-20/image3.png" alt></p><p>聚类中心确定之后，剩余点被分配给与其具有较高密度的最近邻居相同的类簇。与其他迭代优化的聚类算法不同，类簇分配在单个步骤中执行。在聚类分析中, 通常需要确定每个点划分给某个类簇的可靠性. 在该算法中, 可以首先为每个类簇定义一个边界区域(border region), 亦即划分给该类簇但是距离其他类簇的点的距离小于dc的点. 然后为每个类簇找到其边界区域的局部密度最大的点, 令其局部密度为 . 该类簇中所有局部密度大于 的点被认为是类簇核心的一部分(亦即将该点划分给该类簇的可靠性很大), 其余的点被认为是该类簇的光晕, 亦即可以认为是噪音 <img src="https://zhangmingemma.github.io/dist/images/2016-11-20/image4.png" alt></p><p>图A表示点分布，其中包含非球形点集和双峰点集。B和C分别表示4000和1000个点按照A中模式的分布，其中点根据其被分配的不同类簇着色，黑色的点属于类簇光晕。D和E是对应的决策图，而F表示的是不同点量下不正确聚类点的比率，误差线代表平均值的标准差</p><h3>聚类结果</h3><p>图3是分别利用点集和Olivetti脸部图片集的聚类结果 <img src="https://zhangmingemma.github.io/dist/images/2016-11-20/image5.png" alt></p><h3>算法特点</h3><p>算法具有以下特点：</p><p>A． 该算法是一种基于密度的聚类算法，核心思想是认为类簇的中心由一些局部密度比较低的点围绕, 并且这些点距离其他有高局部密度的点的距离都比较大。</p><p>B． 该算法将非聚类中心点的聚类过程分离成一个单独的进程。使得聚类中心的选择和非聚类点的归类分离开来，增大了聚类精度。</p><p>C． 该算法适用于图片、非球形点集的聚类。</p>',18);function a(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n])}const l={};l.render=a;t["default"]=l},"2efe":function(e,t,s){"use strict";s("b0c0");var c=s("7a23"),n=Object(c["G"])("data-v-075ec1b1");Object(c["u"])("data-v-075ec1b1");var a={key:0},l={class:"abstract"},i={class:"footer"},j={class:"footer-tags"};Object(c["s"])();var o=n((function(e,t,s,n,o,r){return e.post?(Object(c["r"])(),Object(c["e"])("article",a,[Object(c["i"])("h1",{onClick:t[1]||(t[1]=function(t){return e.tapPost(e.post.name)})},Object(c["A"])(e.post.title),1),Object(c["i"])("div",l,Object(c["A"])(e.post.abstract),1),Object(c["i"])("a",{onClick:t[2]||(t[2]=function(t){return e.tapPost(e.post.name)})},"点我阅读更多..."),Object(c["i"])("div",i,[Object(c["i"])("div",j,[(Object(c["r"])(!0),Object(c["e"])(c["a"],null,Object(c["x"])(e.post.tags,(function(t){return Object(c["r"])(),Object(c["e"])("div",{class:"blog-tag",key:t,tag:t,onClick:function(s){return e.tapTag(t)}},Object(c["A"])(t),9,["tag","onClick"])})),128))]),Object(c["i"])("span",null,Object(c["A"])(e.post.date),1)])])):Object(c["f"])("",!0)})),r=s("a7bb"),h=s("6c02"),b=Object(c["j"])({props:["post"],setup:function(){var e=Object(h["e"])(),t=function(t){t&&(Object(r["f"])(),e.push("/post?file=".concat(t)))},s=function(t){t&&(Object(r["f"])(),e.push("/tag?tag=".concat(t)))};return{tapTag:s,tapPost:t}}});s("5765");b.render=o,b.__scopeId="data-v-075ec1b1";t["a"]=b},"30df":function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["i"])("p",null,"title: Vue2.0原理理解 (一)：数据驱动 date: 2022-06-15 tags: JavaScript, Vue",-1);function a(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n])}const l={};l.render=a;t["default"]=l},3209:function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])('<p>上篇主要解释了如何从项目文件夹内读取文章，并解析文章的标题、时间、摘要等基本内容，渲染为文章列表，单项可以携带文章文件名跳转到文章内页。本篇主要解释在文章内页如何将Markdown渲染为Html，并抽取文章目录，实现文章锚点，本文主要用到的库是<a href="https://github.com/markedjs/marked">marked</a>，marked能够通过正则表达式将markdown文件解析为<code>html</code>文本。本系列其他文章：</p><ul><li><a href="https://zhangmingemma.github.io/#/post?file=2021-07-03-Blog%201">Vue3.0搭建博客 (一)：读取文章列表，解析标题信息</a></li><li><a href="https://zhangmingemma.github.io/#/post?file=2021-07-05-Blog%203">Vue3.0搭建博客 (三)：添加评论，部署github</a></li></ul><p>博客源码github: <a href="https://github.com/zhangmingemma/zhangmingemma.github.io" target="_blank">博客仓库地址</a>，目录抽取的代码写在<code>CatalogHanlder.ts</code>中</p><h3>1. 文章html渲染</h3><p>首先获取单篇文章文本，处理思路有很多种，因为上篇我们已经解释了如何拿到文章文本，这里不做赘述：</p><ul><li>在<code>main.ts</code>中执行文章列表获取的方法，获得文章列表，存储全局数据，在文章内页通过文件名拿到当前文章的文本内容；</li><li>根据文章文件名，通过<code>axios</code>单独获取</li></ul><p>其次是将文本渲染为html：</p>',7),a=Object(c["i"])("ul",null,[Object(c["i"])("li",null,[Object(c["i"])("p",null,[Object(c["h"])("使用"),Object(c["i"])("code",null,"marked"),Object(c["h"])("将markdown文本转换生成"),Object(c["i"])("code",null,"html"),Object(c["h"])("，在页面中通过"),Object(c["i"])("code",null,"v-html"),Object(c["h"])("标签引入即可。")])]),Object(c["i"])("li",null,[Object(c["i"])("p",null,[Object(c["h"])("再添加样式库让文章内容美观呈现，markdown格式化使用的样式库是"),Object(c["i"])("code",null,"github-markdown-css"),Object(c["h"])("，代码高亮使用的样式库是"),Object(c["i"])("code",null,"highlight.js"),Object(c["h"])("。如果代码仍旧不能高亮，需要在"),Object(c["i"])("code",null,"main.ts"),Object(c["h"])("中"),Object(c["i"])("code",null,"import 'highlight.js/styles/github.css'"),Object(c["h"])("，原因是Vue中"),Object(c["i"])("code",null,"v-html"),Object(c["h"])("中的"),Object(c["i"])("code",null,"html"),Object(c["h"])("文本只能应用全局样式")]),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'github-markdown-css'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" hljs "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'highlight.js'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" { useRoute } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'vue-router'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" marked = "),Object(c["i"])("span",{class:"hljs-built_in"},"require"),Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-string"},"'marked'"),Object(c["h"])(")\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" { defineComponent, Ref, watchEffect } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'@vue/runtime-core'"),Object(c["h"])("\n\n"),Object(c["i"])("span",{class:"hljs-comment"},"// marked需要设置一下高亮引用样式库，否则代码不会高亮"),Object(c["h"])("\nmarked.setOptions({\n    "),Object(c["i"])("span",{class:"hljs-attr"},"renderer"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-keyword"},"new"),Object(c["h"])(" marked.Renderer(),\n    "),Object(c["i"])("span",{class:"hljs-attr"},"gfm"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-comment"},"//默认为true。 允许 Git Hub标准的markdown."),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"tables"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-comment"},"//默认为true。 允许支持表格语法。该选项要求 gfm 为true。"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"breaks"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-comment"},"//默认为false。 允许回车换行。该选项要求 gfm 为true。"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"pedantic"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-literal"},"false"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-comment"},"//默认为false。 尽可能地兼容 markdown.pl的晦涩部分。不纠正原始模型任何的不良行为和错误。"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"smartLists"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"smartypants"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-comment"},"//使用更为时髦的标点，比如在引用语法中加入破折号。"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"highlight"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-params"},"code:any"),Object(c["h"])(") ")]),Object(c["h"])("{\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" hljs.highlightAuto(code).value;\n    },\n});\n\n"),Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"default"),Object(c["h"])(" defineComponent({\n    setup() {\n        "),Object(c["i"])("span",{class:"hljs-comment"},"// 从路由参数中获取markdown文件名"),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" route = useRoute()\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" fileName = route.query.fileName\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" postHtml:Ref<string> = ref("),Object(c["i"])("span",{class:"hljs-string"},"''"),Object(c["h"])(")\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" { res } = getPostInfo(fileName) "),Object(c["i"])("span",{class:"hljs-comment"},"// 获取单个文章文本"),Object(c["h"])("\n        \n        watchEffect("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"()"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (res.value) {\n                postHtml = marked(res.value)\n            }\n        })\n\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" {\n            postHtml\n        }\n    }\n})\n")])]),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-html"},[Object(c["i"])("span",{class:"hljs-comment"},"\x3c!-- 样式库定义为类名为markdown-body，所以这里markdown容器的类名必须有markdown-body --\x3e"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"markdown-body"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"v-html"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"postHtml"'),Object(c["h"])("/>")]),Object(c["h"])("\n")])])])],-1),l=Object(c["g"])('<h3>2. 文章目录抽取</h3><p>文章目录抽取的实现过程大致可以划分为三个步骤，第一步就是获取标题节点，得到标题树；第二步是根据标题树的标题等级、文本组成目录html；第三步就是展示目录实现锚点定位</p><h4>1) 获取标题节点</h4><p>获取标题节点的方式有两种</p><ul><li>第一种是基于<code>marked-ast</code>从AST语法树中抽取<code>heading</code>标签</li><li>第二种是从已渲染的文章<code>html</code>中根据正则规则抽取<code>h</code>标签，比较感兴趣的话可以移步这篇文章，讲解的还是很清楚的：<a href="https://juejin.cn/post/6844904007069089805" target="_blank">《实现一个掘金Style的markdown目录》</a>。</li></ul><p>这里我们主要讲解第一种从AST语法树中抽取标题节点。上篇<a href="https://zhangmingemma.github.io/#/post?file=2021-07-03-Blog%201">Vue3.0搭建博客 (一)：文章html渲染, 抽取目录</a>我们讲过如何使用<code>marked-ast</code>解析markdown文本为AST语法树，通过语法树可以拿到标题<code>type=heading</code>，level代表标题层级~~~</p>',6),i=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" getPostCatalog = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"markdownText:string"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" ast:object[] = markedAST.parse(markdownText.trim())\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" headingArr = ast.filter("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"astItem"),Object(c["h"])(" =>")]),Object(c["h"])(" astItem.type==="),Object(c["i"])("span",{class:"hljs-string"},"'heading'"),Object(c["h"])(")\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" headingArr\n}\n")])],-1),j=Object(c["i"])("p",null,"例如下面的标题列表",-1),o=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-markdown"},[Object(c["i"])("span",{class:"hljs-section"},"## 标题1 "),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-section"},"### 标题1.1"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-section"},"#### 标题1.1.1"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-section"},"## 标题2"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-section"},"### 标题2.1"),Object(c["h"])("\n")])],-1),r=Object(c["i"])("p",null,"会抽析出结果",-1),h=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["h"])("[{\n    "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'heading'"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"level"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"2"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"text"),Object(c["h"])(": ["),Object(c["i"])("span",{class:"hljs-string"},"'标题1'"),Object(c["h"])("]\n},{\n    "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'heading'"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"level"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"3"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"text"),Object(c["h"])(": ["),Object(c["i"])("span",{class:"hljs-string"},"'标题1.1'"),Object(c["h"])("]\n},{\n    "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'heading'"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"level"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"4"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"text"),Object(c["h"])(": ["),Object(c["i"])("span",{class:"hljs-string"},"'标题1.1.1'"),Object(c["h"])("]\n},{\n    "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'heading'"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"level"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"2"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"text"),Object(c["h"])(": ["),Object(c["i"])("span",{class:"hljs-string"},"'标题2'"),Object(c["h"])("]\n},{\n    "),Object(c["i"])("span",{class:"hljs-attr"},"type"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'heading'"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"level"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"3"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"text"),Object(c["h"])(": ["),Object(c["i"])("span",{class:"hljs-string"},"'标题2.1'"),Object(c["h"])("]\n}]\n")])],-1),b=Object(c["i"])("h4",null,"2) 组合目录html",-1),p=Object(c["i"])("p",null,"拿到标题节点树之后，就可以组合目录html了",-1),O=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["h"])("getCatalogHtml(markdownText:string) {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" CatalogMaxLevels:number = "),Object(c["i"])("span",{class:"hljs-number"},"3"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-comment"},"// 我这里设置最多显示三层目录"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" headingArr:IAst[] = getPostCatalog(markdownText)\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" levelStack:string[] = [] \n    "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" htmlResult:string = "),Object(c["i"])("span",{class:"hljs-string"},"''"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])("(!headingArr || !headingArr.length) {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" htmlResult\n    }\n    headingArr.forEach("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"item:IAst, index:number"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" itemText:string = item?.text?.["),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])("]\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" itemLabel:string = "),Object(c["i"])("span",{class:"hljs-string"},[Object(c["h"])("`h"),Object(c["i"])("span",{class:"hljs-subst"},"${item?.level}"),Object(c["h"])("`")]),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" levelIndex:number = levelStack.indexOf(itemLabel)\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (levelIndex < "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(" ) {\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (levelStack.length < CatalogMaxLevels) {\n                levelStack.unshift(itemLabel)\n                htmlResult += "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".addStartUl()\n                htmlResult += "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".addLi(itemText, index)\n            }\n        } \n        "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (levelIndex === "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(") {\n            htmlResult += "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".addLi(itemText, index)\n        }\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(" {\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"while"),Object(c["h"])("(levelIndex--) {\n                levelStack.shift()\n                htmlResult += "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".addEndUl()\n            }\n            htmlResult += "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".addLi(itemText, index)\n        }\n    })\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"while"),Object(c["h"])("(levelStack.length) {\n        levelStack.shift()\n        htmlResult += "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".addEndUl()\n    }\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" htmlResult\n}\n\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" addStartUl = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"()"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},'`<ul class="catalog-list">`'),Object(c["h"])("\n}\n\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" addEndUl = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"()"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"`</ul>\\n`"),Object(c["h"])("\n}\n\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" addLi = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"text:string, index:number"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},[Object(c["h"])('`<li class="item"><a href="#heading-'),Object(c["i"])("span",{class:"hljs-subst"},"${index}"),Object(c["h"])('" title="'),Object(c["i"])("span",{class:"hljs-subst"},"${text}"),Object(c["h"])('">'),Object(c["i"])("span",{class:"hljs-subst"},"${text}"),Object(c["h"])("</a></li>\\n`")]),Object(c["h"])("\n}\n")])],-1),d=Object(c["i"])("p",null,"执行之后",-1),u=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-markdown"},[Object(c["i"])("span",{class:"hljs-section"},"## 标题1 "),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-section"},"### 标题1.1"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-section"},"#### 标题1.1.1"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-section"},"## 标题2"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-section"},"### 标题2.1"),Object(c["h"])("\n")])],-1),m=Object(c["i"])("p",null,"上面的markdown文件，解析后获得的目录html会变成",-1),g=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-html"},[Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"ul"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalog-list"'),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"li"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"item"'),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"href"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"#heading-0"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"title"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"标题1"'),Object(c["h"])(">")]),Object(c["h"])("标题1"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"li"),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"ul"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalog-list"'),Object(c["h"])(">")]),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"li"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"item"'),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"href"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"#heading-1"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"title"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"标题1.1"'),Object(c["h"])(">")]),Object(c["h"])("标题1.1"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"li"),Object(c["h"])(">")]),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"ul"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalog-list"'),Object(c["h"])(">")]),Object(c["h"])("\n            "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"li"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"item"'),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"href"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"#heading-2"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"title"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"标题1.1.1"'),Object(c["h"])(">")]),Object(c["h"])("标题1.1.1"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"li"),Object(c["h"])(">")]),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"ul"),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"ul"),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"li"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"item"'),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"href"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"#heading-3"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"title"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"标题2"'),Object(c["h"])(">")]),Object(c["h"])("标题2"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"li"),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"ul"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalog-list"'),Object(c["h"])(">")]),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"li"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"item"'),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"href"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"#heading-4"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"title"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"标题2.1"'),Object(c["h"])(">")]),Object(c["h"])("标题2.1"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"a"),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"li"),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"ul"),Object(c["h"])(">")]),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"ul"),Object(c["h"])(">")]),Object(c["h"])("\n")])],-1),f=Object(c["i"])("p",null,"在页面中展示html，设置样式即可得到掘金样式的目录啦~我这里做了一个额外的处理，页面滚动的时候设置了目录吸顶。除此之外，博客的浏览场景大概率是PC Web，因此浏览器可视范围的尺寸改变，会影响到目录展示的位置，也需要监听窗口尺寸的改变，来修正目录吸顶时的展示位置。",-1),v=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"default"),Object(c["h"])(" defineComponent({\n    setup() {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" route = useRoute()\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" router = useRouter()\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" fileName:any = route.query.file "),Object(c["i"])("span",{class:"hljs-comment"},"//从路由参数中拿到文章的文件名"),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" markdownText:string =  getSinglePost(fileName) "),Object(c["i"])("span",{class:"hljs-comment"},"// 获取单个文章的markdown文本"),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" isCatalogFixed = ref<boolean>("),Object(c["i"])("span",{class:"hljs-literal"},"false"),Object(c["h"])(")\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" catalogHtml = ref<string>("),Object(c["i"])("span",{class:"hljs-string"},"''"),Object(c["h"])(")\n        catalogHtml.value = getCatalogHtml()\n\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" state = reactive({\n            "),Object(c["i"])("span",{class:"hljs-attr"},"CatalogOffset"),Object(c["h"])(":"),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(" | {\n                "),Object(c["i"])("span",{class:"hljs-attr"},"left"),Object(c["h"])(":number, \n                "),Object(c["i"])("span",{class:"hljs-attr"},"top"),Object(c["h"])(":number, \n                "),Object(c["i"])("span",{class:"hljs-attr"},"width"),Object(c["h"])(":number\n            } = "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])("\n        })\n        "),Object(c["i"])("span",{class:"hljs-built_in"},"window"),Object(c["h"])(".onresize = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"()"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" catalogEle:HTMLElement|"),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(" = "),Object(c["i"])("span",{class:"hljs-built_in"},"document"),Object(c["h"])(".getElementById("),Object(c["i"])("span",{class:"hljs-string"},"'js-catalog'"),Object(c["h"])(")\n            state.catalogOffset = {\n                "),Object(c["i"])("span",{class:"hljs-attr"},"left"),Object(c["h"])(": catalogEle?.offsetLeft || "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(",\n                "),Object(c["i"])("span",{class:"hljs-attr"},"top"),Object(c["h"])(": catalogEle?.offsetTop || "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(",\n                "),Object(c["i"])("span",{class:"hljs-attr"},"width"),Object(c["h"])(": catalogEle?.offsetWidth || "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])("\n            }\n        }\n        "),Object(c["i"])("span",{class:"hljs-built_in"},"window"),Object(c["h"])(".addEventListener("),Object(c["i"])("span",{class:"hljs-string"},"'scroll'"),Object(c["h"])(", ()=> {\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" pageY:number = "),Object(c["i"])("span",{class:"hljs-built_in"},"window"),Object(c["h"])(".pageYOffset\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" catalogEle:HTMLElement|"),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(" = "),Object(c["i"])("span",{class:"hljs-built_in"},"document"),Object(c["h"])(".getElementById("),Object(c["i"])("span",{class:"hljs-string"},"'js-catalog'"),Object(c["h"])(")\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" targetY:number = catalogEle?.offsetTop\n            isCatalogFixed.value = pageY > targetY\n        }, "),Object(c["i"])("span",{class:"hljs-literal"},"false"),Object(c["h"])(")\n\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" {\n            catalogHtml\n        }\n    }\n})\n")])],-1),y=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-html"},[Object(c["i"])("span",{class:"hljs-comment"},"\x3c!--吸顶时占位--\x3e"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"post-catalog"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},":id"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},"\"`${isCatalogFixed? 'js-catalog':''}`\""),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"v-if"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"isCatalogFixed && catalogHtml"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},":style"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"`width:${catalogOffset.width}px`"'),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(">")]),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"post-catalog"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},":id"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},"\"`${isCatalogFixed? '':'js-catalog'}`\""),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},":class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"{fixed: isCatalogFixed}"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},":style"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},"\"`${isCatalogFixed ? 'left:'+catalogOffset.left+'px':''}`\""),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"v-if"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalogHtml"'),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalog-title"'),Object(c["h"])(">")]),Object(c["h"])("目录"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalog-body"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"v-html"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalogHtml"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"@click.prevent"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"anchor($event)"'),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(">")]),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(">")]),Object(c["h"])("\n")])],-1),w=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-scss"},[Object(c["i"])("span",{class:"hljs-selector-class"},".post-catalog"),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-attribute"},"max-width"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$aside-width"),Object(c["h"])(";\n    "),Object(c["i"])("span",{class:"hljs-attribute"},"box-sizing"),Object(c["h"])(": border-box;\n    "),Object(c["i"])("span",{class:"hljs-attribute"},"flex-shrink"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(";\n    "),Object(c["i"])("span",{class:"hljs-attribute"},"padding-left"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"4.5rem"),Object(c["h"])(";\n    "),Object(c["i"])("span",{class:"hljs-attribute"},"padding-top"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"2rem"),Object(c["h"])(";\n    &"),Object(c["i"])("span",{class:"hljs-selector-class"},".fixed"),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"position"),Object(c["h"])(": fixed;\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"z-index"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"2"),Object(c["h"])(";\n        -webkit-"),Object(c["i"])("span",{class:"hljs-attribute"},"font"),Object(c["h"])("-smoothing: subpixel-antialiased;\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"top"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"left"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"969px"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"padding-top"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"2rem"),Object(c["h"])(";\n    }\n    "),Object(c["i"])("span",{class:"hljs-selector-class"},".catalog-title"),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"font-size"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$font-size-h1-excerpt"),Object(c["h"])(";\n    }\n    "),Object(c["i"])("span",{class:"hljs-selector-class"},".catalog-body"),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"margin"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"1rem"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(";\n    }\n}\n"),Object(c["i"])("span",{class:"hljs-comment"},"// catalog-list为v-html模板中的样式，因此需要定义为全局样式"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-selector-class"},".catalog-list"),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-attribute"},"position"),Object(c["h"])(": relative;\n    "),Object(c["i"])("span",{class:"hljs-attribute"},"padding"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(";\n    "),Object(c["i"])("span",{class:"hljs-attribute"},"margin"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(";\n    @include before-line();\n    "),Object(c["i"])("span",{class:"hljs-selector-class"},".item"),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"margin"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"padding"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"font-size"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$font-size-h1-excerpt"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"line-height"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$line-height"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"list-style"),Object(c["h"])(": none;\n        "),Object(c["i"])("span",{class:"hljs-selector-tag"},"a"),Object(c["h"])(" {\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"text-decoration"),Object(c["h"])(": none;\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"color"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$font-dark-grey"),Object(c["h"])(";\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"font-weight"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$font-weight-bold"),Object(c["h"])(";\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"margin"),Object(c["h"])(": ."),Object(c["i"])("span",{class:"hljs-number"},"4rem"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(";\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"padding"),Object(c["h"])(": ."),Object(c["i"])("span",{class:"hljs-number"},"2rem"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(" ."),Object(c["i"])("span",{class:"hljs-number"},"2rem"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-number"},"1.3rem"),Object(c["h"])(";\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"display"),Object(c["h"])(": block;\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"position"),Object(c["h"])(": relative;\n            @include singleLine;\n            @include item-dot(6px, 50%);\n            &"),Object(c["i"])("span",{class:"hljs-selector-pseudo"},":hover"),Object(c["h"])(" {\n                "),Object(c["i"])("span",{class:"hljs-attribute"},"background"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$line-catalog-grey"),Object(c["h"])(";\n                "),Object(c["i"])("span",{class:"hljs-attribute"},"border-radius"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"3px"),Object(c["h"])(";\n            }\n            &"),Object(c["i"])("span",{class:"hljs-selector-pseudo"},":active"),Object(c["h"])(", &"),Object(c["i"])("span",{class:"hljs-selector-pseudo"},":focus"),Object(c["h"])(" {\n                "),Object(c["i"])("span",{class:"hljs-attribute"},"color"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$link-red"),Object(c["h"])(";\n                "),Object(c["i"])("span",{class:"hljs-attribute"},"background"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$line-catalog-grey"),Object(c["h"])(";\n                "),Object(c["i"])("span",{class:"hljs-attribute"},"border-radius"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"3px"),Object(c["h"])(";\n            }\n        }\n    }\n\n    "),Object(c["i"])("span",{class:"hljs-selector-class"},".catalog-list"),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"margin-left"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"2rem"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-selector-tag"},"a"),Object(c["h"])(" {\n            @include item-dot(5px, 0);\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"font-weight"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$font-weight"),Object(c["h"])(";\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"font-size"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$font-size-h3-excerpt"),Object(c["h"])(";\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"margin"),Object(c["h"])(": ."),Object(c["i"])("span",{class:"hljs-number"},"1rem"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(";\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"padding"),Object(c["h"])(": ."),Object(c["i"])("span",{class:"hljs-number"},"1rem"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(" ."),Object(c["i"])("span",{class:"hljs-number"},"1rem"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-number"},"1.3rem"),Object(c["h"])(";\n        }\n    }\n\n    "),Object(c["i"])("span",{class:"hljs-selector-class"},".catalog-list"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-selector-class"},".catalog-list"),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-selector-tag"},"a"),Object(c["h"])(" {\n            @include item-dot(5px, 50%);\n            "),Object(c["i"])("span",{class:"hljs-attribute"},"font-size"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$font-size-h5-excerpt"),Object(c["h"])(";\n        }\n    }\n}\n")])],-1),k=Object(c["i"])("p",null,"样式中有用到一些混入和变量",-1),x=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-scss"},[Object(c["i"])("span",{class:"hljs-variable"},"$font-size-h1-excerpt"),Object(c["h"])(":   "),Object(c["i"])("span",{class:"hljs-number"},"1rem"),Object(c["h"])(";\n"),Object(c["i"])("span",{class:"hljs-variable"},"$font-size-h3-excerpt"),Object(c["h"])(":   ."),Object(c["i"])("span",{class:"hljs-number"},"95rem"),Object(c["h"])(";\n"),Object(c["i"])("span",{class:"hljs-variable"},"$font-size-h5-excerpt"),Object(c["h"])(":   ."),Object(c["i"])("span",{class:"hljs-number"},"9rem"),Object(c["h"])(";\n"),Object(c["i"])("span",{class:"hljs-variable"},"$line-height"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"1.6"),Object(c["h"])(";\n"),Object(c["i"])("span",{class:"hljs-variable"},"$font-weight"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"400"),Object(c["h"])(";\n"),Object(c["i"])("span",{class:"hljs-variable"},"$font-weight-bold"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"600"),Object(c["h"])(";\n"),Object(c["i"])("span",{class:"hljs-variable"},"$font-dark-grey"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"#333"),Object(c["h"])(";\n"),Object(c["i"])("span",{class:"hljs-variable"},"$link-red"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"#fc4d50"),Object(c["h"])(";\n"),Object(c["i"])("span",{class:"hljs-variable"},"$line-catalog-grey"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"#f2f3f4"),Object(c["h"])(";\n"),Object(c["i"])("span",{class:"hljs-variable"},"$aside-width"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"310px"),Object(c["h"])(";\n@mixin singleLine() {\n    "),Object(c["i"])("span",{class:"hljs-attribute"},"white-space"),Object(c["h"])(": nowrap;\n    "),Object(c["i"])("span",{class:"hljs-attribute"},"text-overflow"),Object(c["h"])(": ellipsis;\n    "),Object(c["i"])("span",{class:"hljs-attribute"},"overflow"),Object(c["h"])(": hidden;\n}\n@mixin item-dot("),Object(c["i"])("span",{class:"hljs-variable"},"$size"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-variable"},"$border-radius"),Object(c["h"])(":"),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-variable"},"$left"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"5px"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-variable"},"$top"),Object(c["h"])(":"),Object(c["i"])("span",{class:"hljs-number"},"50%"),Object(c["h"])(") {\n    &::before {\n        content: "),Object(c["i"])("span",{class:"hljs-string"},"''"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"position"),Object(c["h"])(": absolute;\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"top"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$top"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"left"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$left"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"margin-top"),Object(c["h"])(": -#{"),Object(c["i"])("span",{class:"hljs-variable"},"$size"),Object(c["h"])("}/"),Object(c["i"])("span",{class:"hljs-number"},"2"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"width"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$size"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"height"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$size"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"background"),Object(c["h"])(": currentColor;\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"border-radius"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$border-radius"),Object(c["h"])(";\n    }\n}\n@mixin before-line("),Object(c["i"])("span",{class:"hljs-variable"},"$color"),Object(c["h"])(":"),Object(c["i"])("span",{class:"hljs-variable"},"$line-catalog-grey"),Object(c["h"])(") {\n    &::before {\n        content: "),Object(c["i"])("span",{class:"hljs-string"},"''"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"position"),Object(c["h"])(": absolute;\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"top"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"left"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"7px"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"bottom"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"width"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-number"},"2px"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"background"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-variable"},"$color"),Object(c["h"])(";\n        "),Object(c["i"])("span",{class:"hljs-attribute"},"opacity"),Object(c["h"])(": ."),Object(c["i"])("span",{class:"hljs-number"},"5"),Object(c["h"])(";\n    } \n}\n")])],-1),V=Object(c["g"])("<h4>3) 目录锚定页面</h4><p>目录锚定页面其实基于的原理就是<code>&lt;a href=&quot;#id1&quot;&gt;text&lt;/a&gt;</code>中的<code>href</code>为标题行的<code>id</code>，如<code>&lt;h1 id=&quot;id1&quot;&gt;text&lt;/h1&gt;</code>。基于<code>marked</code>渲染的markdown页面，标题的h标签都携带了<code>id</code>属性，为标题文本，这样会存在一个问题，当标题文本包含特殊标点符号的时候，例如我们常用的<code>1. 标题</code>这种类型，会导致锚定失效。我们在上一节已经在生成目录html的时候，设定了单行目录为<code>&lt;a href=&quot;#heading-2&quot; title=&quot;标题1.1.1&quot;&gt;标题1.1.1&lt;/a&gt;</code>，只需要在对应的标题行修正<code>id=heading-index</code>的样式即可。</p><ul><li>修正h标签id</li></ul>",3),C=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" setHId = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"markdownText:string"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" headingArr:IAst[] = getPostCatalog(markdownText)\n    headingArr.map("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"item:IAst, index:number"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" itemText:string = item?.text?.["),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])("]\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" tagEle = "),Object(c["i"])("span",{class:"hljs-built_in"},"document"),Object(c["h"])(".getElementById(itemText)\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (tagEle) {\n            tagEle.setAttribute("),Object(c["i"])("span",{class:"hljs-string"},"'id'"),Object(c["h"])(", id)\n        }\n    })\n}\n")])],-1),S=Object(c["i"])("ul",null,[Object(c["i"])("li",null,[Object(c["h"])("vue-router环境下锚定冲突处理 处理完"),Object(c["i"])("code",null,"h"),Object(c["h"])("标签的id之后，实际发现，并不能够锚定，原因是锚定会与vue-router的路由跳转冲突，需要手动处理锚定跳转。上一节目录页面中我们已经为目录绑定了"),Object(c["i"])("code",null,"anchor"),Object(c["h"])("事件。")])],-1),I=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-html"},[Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"post-catalog"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},":class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"{hide: isCatalogFixed}"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"id"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"js-catalog"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"v-if"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalogHtml"'),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalog-title"'),Object(c["h"])(">")]),Object(c["h"])("目录"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(">")]),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"class"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalog-body"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"v-html"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"catalogHtml"'),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"@click.prevent"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"anchor($event)"'),Object(c["h"])(">")]),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(">")]),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"div"),Object(c["h"])(">")]),Object(c["h"])("\n")])],-1),_=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["h"])("anchor(event:any) {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])("(event?.target.nodeName === "),Object(c["i"])("span",{class:"hljs-string"},"'A'"),Object(c["h"])(") {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" href:string = event.target.attributes?.href?.value\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" anchorName:string = href.substring("),Object(c["i"])("span",{class:"hljs-number"},"1"),Object(c["h"])(", href.length)\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" anchorEle = "),Object(c["i"])("span",{class:"hljs-built_in"},"document"),Object(c["h"])(".getElementById(anchorName)\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" ( anchorEle ) {\n            anchorEle.scrollIntoView({"),Object(c["i"])("span",{class:"hljs-attr"},"behavior"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},'"smooth"'),Object(c["h"])("})\n        }\n    }\n}\n")])],-1),E=Object(c["i"])("p",null,"至此，可以锚定的目录就已经做好啦~~~",-1),P=Object(c["i"])("img",{src:"https://zhangmingemma.github.io/dist/images/2021-07-04/2.jpg",style:{border:"1px solid #ededed"}},null,-1);function A(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n,a,l,i,j,o,r,h,b,p,O,d,u,m,g,f,v,y,w,k,x,V,C,S,I,_,E,P])}const T={};T.render=A;t["default"]=T},"32d2":function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])('<p><span style="color:blue;">|导语</span> 微信小程序生态日益完善，小程序提供的功能服务越来越多，类目覆盖面越来越广，服务共享成为小程序生态中必不可少的一环。小程序自 1.9.6 基础库版本开始支持插件支持服务功能的封装和共享，在小程序官方文档中，给出了插件的具体定义：</p><blockquote><p>插件是一组对js接口、自定义组件或页面的封装，用于嵌入到小程序中使用。</p></blockquote><p>对于开发者，插件调用方在使用插件时，无法看到插件的代码，插件能够用来封装功能或服务，提供给第三方小程序进行展示或者使用，扩大服务使用场景和受众范围。对于使用者，无需特殊申请类目资质，或搭建全套服务架构，就能够通过插件调用开发者所提供的服务丰富自身能力，例如接入好物推荐，在线客服，名片分享，接入WIFI等插件服务。那么开发者又该如何着手插件的开发，开发中又有什么地方需要特别关注呢？</p><h3>一. 插件的开发</h3><h4>1. 插件的开发</h4><p>开发者开发插件前需要在已经注册号的小程序管理后台开通插件功能，填写插件基本信息、插件开发信息后，在开发者工具“开发类型”中选择“插件”即可创建插件项目<a href="https://developers.weixin.qq.com/miniprogram/introduction/plugin.html#%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6" target="_blank">[插件开通及创建项目指引]</a>，新建后的插件项目将包含三个目录，以好物圈提供的“好物推荐”插件为例，创建的插件项目包含的目录及主要内容如下图所示：</p><p><img src="https://zhangmingemma.github.io/dist/images/2019-07-16/20190716image1.png" alt="好物推荐插件 (2)"></p><p>可以看到插件项目包含<code>doc</code>、<code>miniProgram</code>、<code>plugin</code>三个目录：</p><ul><li><p><code>doc</code>目录：插件开发文档</p><ul><li>插件文档必须放置在插件项目根目录中的 <code>doc</code> 目录下，入口文件是 <code>doc/README.md</code></li><li>插件开发文档需要详细列明插件使用者需知的内容，对插件申请条件、插件提供的自定义组件、页面、接口等进行必要的描述和解释，方便第三方小程序正确使用插件；</li><li>插件引用到的图片资源不能是网络图片，且必须放到doc目录下，同时为保证插件安全，文档中的链接只能链接到微信开发者社区、微信公众平台、GitHub。</li></ul></li><li><p><code>miniProgram</code>目录：示例小程序，方便调试插件、预览和审核</p><ul><li>示例小程序中需要引用插件，并在页面中引用插件中的组件来调用插件提供的能力服务；</li><li>除非<code>miniprogramRoot</code>指定目录为miniProgram，否则miniProgram中的文件内容不会上传</li></ul></li><li><p><code>plugin</code>目录：插件代码目录</p><ul><li>插件中组件和页面的编写方式与自定义组件相同，包含<code>json</code>、<code>js</code>、<code>wxss</code>、<code>wxml</code>四个文件组成；</li><li>插件中可以定义任意数量的自定义组件，这些组件在插件内可以相互引用，但提供给第三方小程序使用的组件必须在配置文件中给出；</li><li>插件也可以export一些js接口，但提供给第三方小程序使用的接口也必须在配置文件中给出；</li><li><strong>插件开发者需要提供插件调用失败、插件调用参数错误、插件调用参数疏漏等特殊情况的错误码和错误信息，以便插件使用者正确使用插件</strong>。</li><li>插件包会计入小程序总包的大小，所以插件开发者需要尽量控制插件的大小，避免不必要的逻辑和样式</li></ul></li><li><p><code>project.config.json</code>文件：</p><ul><li><code>miniprogramRoot</code>中指定的目录内容将会在插件上传时作为插件使用Demo一起上传，这个Demo会覆盖到插件的所有使用场景，便于插件的审核</li><li><code>compileType</code>字段表示项目编译类型，只有当<code>compileType == &#39;plugin&#39;</code> 时才能正常使用插件项目，<code>miniProgram</code>中引用的<code>plugin.version</code>才可以等于<code>dev</code></li></ul></li></ul><p>针对具体功能的开发实现，插件有其局限性，具体内容将在<span style="color:blue;">三. 插件的限制</span>中详细介绍。此外，插件的开发也有其需要特殊注意的地方，特别是在基础库版本、页面跳转、网络请求三个方面：</p><p><strong>1）基础库版本</strong></p><p>目前基础调试库版本已经更新至2.8.0，微信开发者工具针对2.2.2以下的版本会报错提示“🔥请将调试基础库上调到2.2.2以上”，因此插件的开发需要选择基础库 &gt; 2.2.2。</p><p><strong>2）页面跳转</strong></p><img src="https://zhangmingemma.github.io/dist/images/2019-07-16/20190716image2.png" style="height:450px;text-align:center;"><p>在插件的开发中常常会涉及到三种情况下的跳转，插件内跳转、插件间跳转和插件与小程序间跳转，都可以使用<a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html"><code>navigator</code></a>组件和<a href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html"><code>wx.navigateTo</code></a>API来实现，但<strong>只有页面栈顶是插件页面的时候才可以调用<code>wx.navigateTo</code>来实现，且页面栈内不得高于10层</strong></p>',15),a=Object(c["i"])("ul",null,[Object(c["i"])("li",null,[Object(c["i"])("p",null,"插件内跳转："),Object(c["i"])("ul",null,[Object(c["i"])("li",null,[Object(c["i"])("p",null,"基础库版本 < 2.1.0，插件内不支持使用页面")]),Object(c["i"])("li",null,[Object(c["i"])("p",null,[Object(c["h"])("基础库版本 2.1.0 ~ 2.2.2，插件内页面跳转需要设置目标页面的url，例如 "),Object(c["i"])("code",null,"plugin-private://PLUGIN_APPID/PATH_TO/PAGE")]),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["h"])("wx.navigateTo({\n    "),Object(c["i"])("span",{class:"hljs-attr"},"url"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},[Object(c["h"])("`plugin-private://"),Object(c["i"])("span",{class:"hljs-subst"},[Object(c["h"])("${"),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".data.pluginAppid}")]),Object(c["h"])("/pages/about/about`")]),Object(c["h"])(",\n})\n")])])]),Object(c["i"])("li",null,[Object(c["i"])("p",null,"基础库版本 > 2.2.2，插件内页面跳转可以使用相对路径作为目标页面的url"),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["h"])("wx.navigateTo({\n    "),Object(c["i"])("span",{class:"hljs-attr"},"url"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"`../about/about`"),Object(c["h"])(",\n})\n")])])])])]),Object(c["i"])("li",null,[Object(c["i"])("p",null,"插件间跳转"),Object(c["i"])("ul",null,[Object(c["i"])("li",null,[Object(c["i"])("p",null,"插件不能直接引用其他插件，也不能直接跳转至其他插件，但当小程序同时引用了插件A和插件B，插件A、B可以互相跳转与引用，使用方法如下："),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-json"},[Object(c["i"])("span",{class:"hljs-comment"},"// 小程序app.json引用两个插件"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-string"},'"plugins"'),Object(c["h"])(":  {\n  "),Object(c["i"])("span",{class:"hljs-attr"},'"APlugin"'),Object(c["h"])(": {\n    "),Object(c["i"])("span",{class:"hljs-attr"},'"version"'),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},'"dev"'),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},'"provider"'),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},'"wx046..."'),Object(c["h"])("\n  },\n  "),Object(c["i"])("span",{class:"hljs-attr"},'"BPlugin"'),Object(c["h"])(": {\n    "),Object(c["i"])("span",{class:"hljs-attr"},'"version"'),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},'"1.1.0"'),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},'"provider"'),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},'"wx047..."'),Object(c["h"])(" \n  }\n}\n\n"),Object(c["i"])("span",{class:"hljs-comment"},"// 插件A页面index要跳转到插件B pages/test/test，首先要在插件A index.json中定义"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-string"},'"usingComponents"'),Object(c["h"])(": {\n  "),Object(c["i"])("span",{class:"hljs-attr"},'"test"'),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},'"plugin-private://BPlugin_APPID/pages/test/test"'),Object(c["h"])("\n}\n")])]),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-html"},[Object(c["h"])("// 插件A页面index中定义\n"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-name"},"navigator"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-attr"},"url"),Object(c["h"])("="),Object(c["i"])("span",{class:"hljs-string"},'"plugin-private://BPlugin_APPID/pages/test/test"'),Object(c["h"])(" >")]),Object(c["h"])("跳转"),Object(c["i"])("span",{class:"hljs-tag"},[Object(c["h"])("</"),Object(c["i"])("span",{class:"hljs-name"},"navigator"),Object(c["h"])(">")]),Object(c["h"])("\n")])])]),Object(c["i"])("li",null,[Object(c["i"])("p",null,[Object(c["i"])("code",null,"navigator"),Object(c["h"])("组件和"),Object(c["i"])("code",null,"usingComponents"),Object(c["h"])("定义中必须严格指定插件页面的路径，否则将会报错"),Object(c["i"])("code",null,'Component is not found in path "plugin-private://BPlugin_APPID/pages/test/test"')])])])]),Object(c["i"])("li",null,[Object(c["i"])("p",null,"插件与小程序间跳转："),Object(c["i"])("ul",null,[Object(c["i"])("li",null,[Object(c["h"])("小程序跳转至插件：小程序页面的页面栈顶不是插件页面，不满足插件页面跳转的必要条件，因此无法调用"),Object(c["i"])("code",null,"wx.navigateTo"),Object(c["h"])("跳转至插件页面，可以使用"),Object(c["i"])("code",null,"navigator"),Object(c["h"])("组件实现跳转")]),Object(c["i"])("li",null,[Object(c["h"])("插件跳转至小程序：鉴于插件API的限制，不能调用"),Object(c["i"])("code",null,"wx.navigateToMiniProgram"),Object(c["h"])("实现插件跳转至小程序，可以使用"),Object(c["i"])("code",null,"navigator"),Object(c["h"])("组件或"),Object(c["i"])("code",null,"wx.navigateTo"),Object(c["h"])("实现跳转，若使用"),Object(c["i"])("code",null,"wx.navigateTo"),Object(c["h"])(" API时同样需要满足"),Object(c["i"])("strong",null,"页面栈顶是插件页面"),Object(c["h"])("的条件。")])])])],-1),l=Object(c["i"])("p",null,[Object(c["i"])("strong",null,"3） 网络请求")],-1),i=Object(c["i"])("p",null,[Object(c["h"])("插件在使用"),Object(c["i"])("a",{href:"https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html"},[Object(c["i"])("code",null,"wx.request")]),Object(c["h"])("API发送网络请求时，将会额外携带一个签名"),Object(c["i"])("code",null,"HostSign"),Object(c["h"])("，用于验证请求来源于小程序插件，这个签名位于请求头中，形如：")],-1),j=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-json"},[Object(c["h"])("X-WECHAT-HOSTSIGN: {\n  "),Object(c["i"])("span",{class:"hljs-attr"},'"noncestr"'),Object(c["h"])(":"),Object(c["i"])("span",{class:"hljs-string"},'"NONCESTR"'),Object(c["h"])(", \n  "),Object(c["i"])("span",{class:"hljs-attr"},'"timestamp"'),Object(c["h"])(":"),Object(c["i"])("span",{class:"hljs-string"},'"TIMESTAMP"'),Object(c["h"])(", \n  "),Object(c["i"])("span",{class:"hljs-attr"},'"signature"'),Object(c["h"])(":"),Object(c["i"])("span",{class:"hljs-string"},'"SIGNATURE"'),Object(c["h"])("\n}\n")])],-1),o=Object(c["i"])("p",null,[Object(c["h"])("其中，"),Object(c["i"])("code",null,"NONCESTR"),Object(c["h"])("是一个随机字符串，"),Object(c["i"])("code",null,"TIMESTAMP"),Object(c["h"])("是生成这个随机字符串和"),Object(c["i"])("code",null,"SIGNATURE"),Object(c["h"])("的UNIX时间戳，他们是生成"),Object(c["i"])("code",null,"SIGNATURE"),Object(c["h"])("的参数，签名算法为：")],-1),r=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["h"])("SIGNATURE = sha1([APPID, NONCESTR, TIMESTAMP, TOKEN].sort().join("),Object(c["i"])("span",{class:"hljs-string"},"''"),Object(c["h"])("))\n")])],-1),h=Object(c["g"])('<p>其中，主要参数：</p><ul><li><p><code>APPID</code>是所在小程序的AppId，可以从请求头的referrer中获得：</p><p>网络请求的referrer格式固定为<code>https://servicewechat.com/{appid}/{version}/page-frame.html</code>，其中{appid}为小程序的appid，{version}为小程序的版本号，版本号为0表示为开发版、体验版以及审核版本，版本号为<code>devtools</code>表示为开发者工具，其余为正式版本。</p></li><li><p><code>TOKEN</code>是插件TOKEN，可以在小程序插件 --&gt; 基本设置中找到。</p></li><li><p>自基础库版本 2.0.7 开始，小程序运行期间，网络状况正常时，<code>NONCESTR</code>和<code>TIMESTAMP</code>每10分钟变更一次，如有必要，可以通过判断<code>TIMESTAMP</code>判断当前的签名是否有效。</p></li></ul><p>插件开发者可以在服务器上按照以下步骤校验签名：</p><ul><li><code>sort</code>对<code>APPID</code>、<code>NONCESTR</code>、<code>TIMESTAMP</code>、<code>TOKEN</code>四个值表示成字符串形式，按照字典序排序</li><li><code>join</code>将排好序的四个字符串直接连接在一起</li><li>对连接结果使用<code>sha1</code>算法，结果即为<code>SIGNATURE</code></li></ul><p>插件开发者为保证插件的安全性，可以按照以下步骤校验调用方：</p><ul><li>服务器依据使用者小程序AppId判别是否具备插件调用权限，如不具备则拒绝调用</li><li>服务器依据签名判别请求签名是否有效，无效则拒绝返回错误码</li></ul><h4>2. 插件的发布</h4><p>通过微信开发者工具预览验证后即可准备发布，可以按照以下步骤上传和发布插件：</p><ul><li>**选择上传配置：**在微信开发者工具中配置&quot;上传代码时自动压缩混淆&quot;、“上传代码时进行代码保护”等项目，以压缩插件代码，及保护插件代码安全（TODO）</li><li>**上传代码：**在微信开发者工具中点击“上传”，填写版本号（即为使用者可以指定的插件版本号），即可上传插件代码</li><li>**上传开发文档：**在“编辑器”中打开开发文档，编辑完成后，可以使用编辑器底部的上传入口上传插件文档，上传后的文档不会立刻发布，需要使用账号密码登录插件管理后台，在 小程序插件 &gt; 基本设置 中预览、发布插件文档，文档发布后，可多次更新修改。</li><li>**提交审核：**上传后即可提交审核，提交审核时需要填写准确的插件服务类目、标签及功能描述，同时服务类目需要满足<a href="https://developers.weixin.qq.com/miniprogram/introduction/plugin.html#开放范围及服务类目" target="_blank">[官方开放的类目范围]</a>，审核周期一般为7个工作日，审核结果将会通过模板消息、站内信通知管理员。</li><li>**发布新版本：**审核通过后即可发布，发布时需要填写准确的版本更新信息，和支持的最低版本库</li></ul><p>需要注意的是插件没有体验版，可以发布多个线上版本，由使用者决定具体使用的版本号。上传后的插件由小程序框架对每个插件进行数据安全保护，保证他们之间不能窃取其他任何一方的数据，同时插件的逻辑代码也无法被使用方看法，这些都依赖于插件的安全隔离机制（TODO，安全隔离机制具体是啥，是否存在代码加密？）</p><h4>3. 插件的更新</h4><p>按照上一节插件的发布中的步骤，即可发布更新后的插件代码，需要特别注意的是，在发布时，需要关注选项“快速更新”，勾选快速更新后，系统会为插件使用者管理员统一下发模板消息，模板消息中包含快速更新的链接，支持插件版本的快速更新，该次快速更新免审核。</p><p>此外，在插件的更新中需要特别注意的是，为了保证插件更新的稳定性，插件开发者需要保持版本迭代过程中插件所调用数据接口的稳定性。</p><h3>二. 插件的使用</h3><h4>1. 插件的申请</h4><p><img src="https://zhangmingemma.github.io/dist/images/2019-07-16/20190716image3.png" alt="图片 2"></p><p><strong>任何注册的小程序</strong>都可以在小程序后台申请插件，申请后需要等待插件开发者小程序管理员通过后，方可使用插件，如果调用没有通过申请的插件，则使用者小程序白屏，并报错：<span style="color:red;">插件申请成功，待审核确认</span>，如果调用未申请的插件，则使用者小程序白屏，并会报错：<span style="color:red;">插件未授权</span>。</p><p>同时，插件使用者需要关注插件开发文档中的插件申请条件，若不满足申请条件，插件开发者一般不会通过插件申请。</p><p>一个小程序最多添加5个小程序插件。</p><h4>2. 插件的使用</h4><p><strong>1）插件基本使用方法</strong></p><p>以“好物推荐”插件为例，使用插件可以按照以下几个步骤：</p><ul><li><p>在小程序<code>app.json</code>文件中引用插件：</p></li><li><p>在引用插件组件的页面中引用插件组件：</p><img src="https://zhangmingemma.github.io/dist/images/2019-07-16/20190716image5.png" style="width:600px;border:1px solid #ededed;"></li><li><p>在引用插件组件的页面中写入插件组件：</p><img src="https://zhangmingemma.github.io/dist/images/2019-07-16/20190716image6.png" style="width:600px;border:1px solid #ededed;"></li><li><p>在引用插件组件的页面中定义插件所需参数，即可使用插件</p></li><li><p>为保证小程序正常运行，插件使用者需要针对插件调用失败等特殊情况做兜底逻辑</p></li></ul><p>如果插件只在一个分包内用到，可以将插件仅放在这个分包内，例如： <img src="https://zhangmingemma.github.io/dist/images/2019-07-16/20190716image7.png" style="width:600px;border:1px solid #ededed;"></p><p>但分包内使用插件有如下限制：</p><ul><li>在分包内使用的插件仅能在分包内使用；</li><li>同一个插件不能被多个分包同时引用；</li><li>不能从分包外的页面直接跳入分包内的插件页面，需要先跳入分包内的非插件页面，再跳入同一分包内的插件页面</li></ul><p><strong>2）依赖版本</strong></p><ul><li>引用的插件版本不被支持，即引用的插件版本号 &lt;最低可用版本号，或 &gt;最新版本号，使用者小程序白屏，并报错“插件版本不存在”</li><li>公共库版本 &lt; 2.2.2，无法正常使用插件，并调试工具报错“将版本更新至🔥请将调试基础库上调到2.2.2以上”</li><li>（TODO：真机测试公共库版本）</li></ul><p><strong>3）其他</strong></p><ul><li>插件使用方计算代码包大小时会合并计入引用的插件大小，因此如果插件只有一个分包使用，可以尽量将插件放在分包下</li><li>插件开发者可以获得因为引用插件而传入的数据，为保护数据安全，要关注插件开发文档中的参数要求，避免传入不必要的数据</li></ul><h4>3. 插件的更新</h4><p>若小程序开发者发布小程序时勾选了“快速更新”选项，则插件使用者小程序管理员会在微信收到模板消息，并附有“快速更新”的链接，可以实现一键更新小程序中引用的插件版本，同时该次更新不必审核。</p><h3>三. 插件的限制</h3><h4>1. 调用API的限制</h4><p>插件可以调用的 API 与小程序不同，主要有两个区别：</p><ul><li>插件的请求域名列表与小程序相互独立；</li><li>一些 API 不允许插件调用（这些函数不存在于 <code>wx</code> 对象下）。</li></ul><p>允许插件调用的API及其对应版本要求列表可参考<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/api-limit.html" target="_blank">[官方说明]</a>，若在插件中调用了不支持的API，监听fail回调，可获得错误信息为<code>getUserInfo:fail 系统错误，错误码：-12015,system error</code>。有些接口，例如<code>wx.login</code>、<code>wx.getUserInfo</code>、虽然在插件中不能使用，但可以通过插件功能页来达到目的，例如用户信息功能页、支付功能以及收货地址功能：</p><ul><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/user-info.html" target="_blank">[用户信息功能页]</a>：相当于调用<code>wx.login</code>和<code>wx.getUserInfo</code>，自基础库2.3.1开始，用户在功能页授权后，插件就可以直接调用<code>wx.login</code>和<code>wx.getUserInfo</code>无需再次进入功能页获取信息，自基础库版本2.6.3起，可以使用<code>wx.getSetting</code>查询用户是否授权过。用户信息功能页相关开发可按照如下步骤：</p><ul><li><p>在插件页面中引用<code>functional-page-navigator</code></p><img src="https://zhangmingemma.github.io/dist/images/2019-07-16/20190716image8.png" style="width:600px;border:1px solid #ededed;"></li><li><p>在插件页面中声明用户信息获取成功的回调</p><img src="https://zhangmingemma.github.io/dist/images/2019-07-16/20190716image9.png" style="width:600px;border:1px solid #ededed;"></li><li><p>即可使用用户信息 <img src="https://zhangmingemma.github.io/dist/images/2019-07-16/20190716image10.png" style="width:600px;border:1px solid #ededed;"></p></li></ul></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/request-payment.html" target="_blank">[支付功能页]</a>：相当于调用<code>wx.requestPayment</code>的功能，支付功能页的使用与用户信息功能页类似，<code>function-page-navigator</code>参数<code>name=requestPayment</code>。<strong>需要注意的是插件使用支付功能，需要在管理后台 小程序插件 -&gt; 基本设置 -&gt; 支付能力”设置项中。另外，无论是否通过申请，主体为个人小程序在使用插件时，都无法正常使用插件里的支付功能。</strong></p></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/plugin/functional-pages/choose-address.html" target="_blank">[收货地址功能页]</a>：相当于调用<code>wx.chooseAddress</code>的功能，支付功能页的使用与用户信息功能页类似，<code>function-page-navigator</code>参数<code>name=chooseAddress</code>。</p><p>​ <img src="https://zhangmingemma.github.io/dist/images/2019-07-16/20190716image11.png" style="width:600px;border:1px solid #ededed;"></p></li></ul><h4>2. 使用组件的限制</h4><p>在插件开发中，以下组件不能在插件页面中使用：</p><ul><li>开放能力（open-type）为以下之一的button： <ul><li>contact（打开客服会话）</li><li>getPhoneNumber（获取用户手机号）</li><li>getUserInfo（获取用户信息）</li></ul></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/open-data.html" target="_blank">[open-data]</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html" target="_blank">[web-view]</a></li></ul><p>以下组件的使用对基础库版本有要求：</p><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" target="_blank">[navigator]</a><a href></a> 需要基础库版本 [2.1.0]</li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/live-player.html" target="_blank">[live-player]</a> 和 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/live-pusher.html" target="_blank">[live-pusher]</a> 需要基础库版本 [2.3.0]</li></ul>',43);function b(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n,a,l,i,j,o,r,h])}const p={};p.render=b;t["default"]=p},"353e":function(e,t,s){},3548:function(e,t,s){},"3f9c":function(e,t,s){"use strict";s("6237")},"4ddc":function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["i"])("p",null,"文本预处理是要文本处理成计算机能识别的格式，是文本分类、文本可视化、文本分析等研究的重要步骤。具体流程包括文本分词、去除停用词、词干抽取(词形还原)、文本向量表征、特征选择等步骤，以消除脏数据对挖掘分析结果的影响。",-1),a=Object(c["i"])("p",null,"本文仅针对英文文本，中文文本暂时还没有研究过。介绍的全部都是基于Python2.7，利用NLTK库进行文本分类的过程。",-1),l=Object(c["i"])("h3",null,"文本分词",-1),i=Object(c["i"])("p",null,"文本分词即将文本拆解成词语单元，英文文本以英文单词空格连接成句，分词过程较为简单。以下介绍几种方法。",-1),j=Object(c["i"])("p",null,[Object(c["i"])("strong",null,"正则表达式分词")],-1),o=Object(c["i"])("p",null,"以空格进行分词",-1),r=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},">>> import re\n>>> text = 'I was just a kid, and loved it very much! What a fantastic song!'\n>>> print re.split(r' ',text)\n\n['I', 'was', 'just', 'a', 'kid,', 'and', 'loved', 'it', 'very', 'much!', 'What', 'a', 'fantastic', 'song!']\n")],-1),h=Object(c["i"])("p",null,"re匹配符号进行分词",-1),b=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},">>> print re.split(r'\\W+', text)\n\n['I', 'was', 'just', 'a', 'kid', 'and', 'loved', 'it', 'very', 'much', 'What', 'a', 'fantastic', 'song', '']\n")],-1),p=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},">>> print re.findall(r'\\w+|\\S\\w*', text)\n\n['I', 'was', 'just', 'a', 'kid', ',', 'and', 'loved', 'it', 'very', 'much', '!', 'What', 'a', 'fantastic', 'song', '!']\n")],-1),O=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},">>> print re.findall(r\"\\w+(?:[-']\\w+)*|'|[-.(]+|\\S\\w*\", text)\n\n['I', 'was', 'just', 'a', 'kid', ',', 'and', 'loved', 'it', 'very', 'much', '!', 'What', 'a', 'fantastic', 'song', '!']\n")],-1),d=Object(c["i"])("p",null,"NLTK正则表达式分词器",-1),u=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},">>> import re\n>>> import nltk\n>>> text = 'I was just a kid, and loved it very much! What a fantastic song!'\n>>> pattern = r\"\"\"(?x)                   # set flag to allow verbose regexps \n\t              (?:[A-Z]\\.)+           # abbreviations, e.g. U.S.A. \n\t              |\\d+(?:\\.\\d+)?%?       # numbers, incl. currency and percentages \n\t              |\\w+(?:[-']\\w+)*       # words w/ optional internal hyphens/apostrophe \n\t              |\\.\\.\\.                # ellipsis \n\t              |(?:[.,;\"'?():-_`])    # special characters with meanings \n\t            \"\"\" \n>>> print nltk.regexp_tokenize(text, pattern)\n\n['I', 'was', 'just', 'a', 'kid', ',', 'and', 'loved', 'it', 'very', 'much', 'What', 'a', 'fantastic', 'song']\n")],-1),m=Object(c["i"])("p",null,[Object(c["i"])("strong",null,"最大匹配算法（MaxMatch）分词")],-1),g=Object(c["i"])("p",null,"MaxMatch算法在中文自然语言处理中常常用来进行分词（或许从名字上你已经能想到它是基于贪婪策略设计的一种算法），算法从右侧开始逐渐减少字符串长度，以此求得可能匹配到nltk字库中词语的最大长度的字符串。这种方法其实更常用于中文文本分词，但是不排除某些英文文本并不以空格作为分隔符，特此介绍一下",-1),f=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},">>> import nltk\n>>> from nltk.corpus import words  \n>>> wordlist = set(words.words())   \n>>> def max_match(text):  \n    pos2 = len(text)  \n    result = ''  \n    while len(text) > 0:         \n        word = text[0:pos2]\n        if word in wordlist:  \n            result = result + text[0:pos2] + ' '  \n            text = text[pos2:]  \n            pos2 = len(text)  \n        else:  \n            pos2 = pos2-1                 \n    return result[0:-1]  \n>>> string = 'theyarebirds'  \n>>> print(max_match(string))\n\nthey are bird s\n")],-1),v=Object(c["i"])("h3",null,"停用词去除",-1),y=Object(c["i"])("p",null,"简单易懂，匹配词库中的停用词，去除！以消除冠词、连词等一些无意义无作用的词增加数据占用空间，并避免其为挖掘计算带来的干扰。",-1),w=Object(c["i"])("p",null,[Object(c["i"])("strong",null,"NLTK停用词库")],-1),k=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},">>> import nltk\n>>> from nltk.corpus import stopwords\n>>> stopworddic = set(stopwords.words('english'))  \n>>> text = ['I', 'was', 'just', 'a', 'kid',  'and', 'loved', 'it', 'very', 'much', 'What', 'a', 'fantastic', 'song']\n>>> text = [i for i in text if i not in stopworddic ]\n>>> print text\n　　\n['I', 'kid', 'loved', 'much', 'What', 'fantastic', 'song']\n")],-1),x=Object(c["i"])("p",null,[Object(c["i"])("strong",null,"自定义词库")],-1),V=Object(c["i"])("p",null,"方法同上，自定义停用词，或者下载网络上的停用词库进行停用词去除",-1),C=Object(c["i"])("h3",null,"词干抽取",-1),S=Object(c["i"])("p",null,"将文本列表中的词语抽取其词干，以统一特征表征形式，特征降维以减少计算量。NLTK中提供了三种最常用的词干提取器接口，即 Porter stemmer, Lancaster Stemmer 和 Snowball Stemmer。抽取词的词干或词根形式（不一定能够表达完整语义）",-1),I=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},">>> from nltk.stem.porter import PorterStemmer  \n>>> porter_stemmer = PorterStemmer()  \n\n>>> from nltk.stem.lancaster import LancasterStemmer  \n>>> lancaster_stemmer = LancasterStemmer()  \n\n>>> from nltk.stem import SnowballStemmer  \n>>> snowball_stemmer = SnowballStemmer(“english”)  \n\n>>> porter_stemmer.stem(‘maximum’)  \nu’maximum’  \n>>> lancaster_stemmer.stem(‘maximum’)  \n‘maxim’  \n>>> snowball_stemmer.stem(‘maximum’)  \nu’maximum’  \n\n>>> porter_stemmer.stem(‘presumably’)  \nu’presum’  \n>>> snowball_stemmer.stem(‘presumably’)  \nu’presum’  \n>>> lancaster_stemmer.stem(‘presumably’)  \n‘presum’  \n\n>>> porter_stemmer.stem(‘multiply’)  \nu’multipli’ \n>>> snowball_stemmer.stem(‘multiply’)  \nu’multipli’  \n>>> lancaster_stemmer.stem(‘multiply’)  \n‘multiply’ \n\n>>> porter_stemmer.stem(‘provision’)  \nu’provis’  \n>>> snowball_stemmer.stem(‘provision’)  \nu’provis’  \n>>> lancaster_stemmer.stem(‘provision’)  \nu’provid’  \n\n>>> porter_stemmer.stem(‘owed’)  \nu’owe’  \n>>> snowball_stemmer.stem(‘owed’)  \nu’owe’  \n>>> lancaster_stemmer.stem(‘owed’)  \n‘ow’   \n")],-1),_=Object(c["i"])("p",null,"各有优劣，看具体文本情况。对于分类、聚类这样对于特征词语的具体形态没有要求的情况下，进行词干抽取虽然抽取后的词干可能无实际意义但是却会大大减少计算时间，提高效率。",-1),E=Object(c["i"])("h3",null,"词形还原",-1),P=Object(c["i"])("p",null,"词形还原Lemmatization是把一个任何形式的语言词汇还原为一般形式（能表达完整语义）。相对而言，词干提取是简单的轻量级的词形归并方式，最后获得的结果为词干，并不一定具有实际意义。词形还原处理相对复杂，获得结果为词的原形，能够承载一定意义，与词干提取相比，更具有研究和应用价值。",-1),A=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},">>> from nltk.stem import WordNetLemmatizer  \n>>> wordnet_lemmatizer = WordNetLemmatizer()  \n>>> word = wordnet_lemmatizer.lemmatize('birds')  \n\nbird\n")],-1),T=Object(c["i"])("p",null,"nltk的lemmatization算法很鸡肋，基本可以理解为只有复数还原为单数形式，当然feet这样的非常态复数形式也可以实现，但是你要想形容词变名词，就不太怎么好使了，比如我在实验中geology，geography，geographic，geographical这几个词就无法还原成统一体。",-1),M=Object(c["i"])("h3",null,"文本向量表征以及TF-IDF权重表示",-1),N=Object(c["i"])("p",null,[Object(c["h"])("这一部分是基于Python的"),Object(c["i"])("a",{href:"http://radimrehurek.com/gensim/"},"Gensim"),Object(c["h"])("库将文本特征抽取为词袋，并将词袋表征为id,以特征id以及文档频率表征成文本向量。"),Object(c["i"])("a",{href:"http://baike.baidu.com/link?url=o8wTt7PnzFPnNWbP-sZ3Sn0kzpGVojCsbYQC3bx-86k5KQfVJo55Sxapb4l2ybnuozKf4KY2tSka5GLdrBooSa"},"TF-IDF"),Object(c["h"])("权重是很可靠的权重表征方式，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。TF-IDF加权的各种形式常被搜索引擎应用，作为文件与用户查询之间相关程度的度量或评级。")],-1),z=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},'#coding:utf-8\nfrom gensim import corpora, models, similarities\n\ndocuments = ["Shipment of gold damaged in a fire","Delivery of silver arrived in a silver truck","Shipment of gold arrived in a truck"]\n\n#分词#\ntexts = [[word for word in document.lower().split()] for document in documents]\nprint texts\n\n#抽取词袋，将token映射为id\ndictionary = corpora.Dictionary(texts)\nprint dictionary.token2id\n\n#由文档向量以及频率构成文档向量\ncorpus = [dictionary.doc2bow(text) for text in texts]\nprint corpus\n\n#计算tfidf权重,注意在gensim的tfidf算法中到文档频率的求解过程中对数之后+1了\ntfidf = models.TfidfModel(corpus)\ncorpus_tfidf = tfidf[corpus]\nfor doc in corpus_tfidf:\n\tprint doc\nprint tfidf.dfs\nprint tfidf.idfs\n')],-1),D=Object(c["i"])("p",null,"除此之外，最近导师推给我的一篇文章Word2vec也是文本向量表征的一种方式，考虑了上下文的语义联系，可以深入研究。",-1),$=Object(c["i"])("h3",null,"特征选择",-1),R=Object(c["i"])("p",null,"根据研究的需求进行特征的选择已达到特征降维，减小噪音的影响。常见的是根据词频（TF）、倒文档频率（IDF）、TFIDF权重等设定阈值进行筛选，无非是在TF/IDF/TFIDF权重计算结果的基础上设定阈值进行筛检。除此之外互信息、信息增益、X平方统计也是常见的方法。除此之外，如果你的研究是在给定类别名称的前提下进行语义文本分类，那么判断特征词与分类之间的语义相似度，从而进行筛选也是一种可行的方法。这里介绍的便是基于WordNet进行语义相似度的介绍。",-1),L=Object(c["i"])("p",null,"WordNet计算语义相似度常见的包括两种主要方法： path_similarity(sense1,sense2) # 词在词典层次结构中的最短路径 wup_similarity(sense1, sense2) # Wu-Palmer 提出的最短路径",-1),H=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"#coding:utf-8\nimport nltk\nfrom nltk.corpus import wordnet as wn\nfrom heapq import *  \nfrom itertools import product\n\nword1 = 'hen'\nword2 = 'chicken'\n\nsense1 = wn.synsets(word1)\nsense2 = wn.synsets(word2)\n\nsim_wup = max(word1.wup_similarity(word2) for (word1, word2) in product(sense1, sense2))\nprint sim_wup\n\nsim_path = max(word1.path_similarity(word2) for (word1, word2) in product(sense1, sense2))\nprint sim_path\n")],-1),B=Object(c["i"])("p",null,"运行结果",-1),F=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"0.962962962963\n0.5\n")],-1);function q(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n,a,l,i,j,o,r,h,b,p,O,d,u,m,g,f,v,y,w,k,x,V,C,S,I,_,E,P,A,T,M,N,z,D,$,R,L,H,B,F])}const W={};W.render=q;t["default"]=W},5765:function(e,t,s){"use strict";s("b601")},"597d":function(e,t,s){"use strict";var c=s("1da1"),n=s("5530"),a=s("d4ec"),l=s("bee2"),i=(s("96cf"),s("fb6a"),s("4de4"),s("4e82"),s("498a"),s("d3b7"),s("ddb0"),s("3ca3"),s("d81d"),s("a1e9")),j=s("5c40"),o=s("b81d"),r=s("a7bb"),h=function(){function e(){Object(a["a"])(this,e),this.TotalPost=[]}return Object(l["a"])(e,[{key:"listCompiler",value:function(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},s=t.tags,c=void 0===s?[]:s,a=t.banPagination,l=void 0!==a&&a,o=Object(i["k"])(0),h=Object(i["j"])({postList:[]}),b=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},s=t.tags,c=void 0===s?[]:s,n=t.startIndex,a=void 0===n?0:n,l=t.endIndex,i=void 0===l?0:l,j=e.filterPost({list:e.TotalPost.slice(),tags:c});o.value=j.length,h.postList=e.filterPost({list:j,startIndex:a,endIndex:i})},p=this.getAllPostContent(),O=p.res;return Object(j["P"])((function(){if(O.value){var t=O.value.slice().filter((function(e){return e.date&&e.title}));e.TotalPost=e.sortPost(t),b(l?{tags:c}:{tags:c,endIndex:r["b"].PageSie})}})),Object(n["a"])({total:o,reloadList:b},Object(i["r"])(h))}},{key:"filterPost",value:function(e){var t=e.list,s=e.tags,c=void 0===s?[]:s,n=e.startIndex,a=void 0===n?0:n,l=e.endIndex,i=void 0===l?0:l,j=i||t.length,o=t.slice();return c&&c.length&&(o=t.filter((function(e){return(null===e||void 0===e?void 0:e.tags)&&Object(r["d"])(e.tags,c).length}))),o.slice(a,j)}},{key:"sortPost",value:function(e){var t=e.slice();return t.sort((function(e,t){var s,c,n=((null===(s=e.date)||void 0===s?void 0:s.replaceAll("-",""))||"").trim(),a=((null===(c=t.date)||void 0===c?void 0:c.replaceAll("-",""))||"").trim();return parseInt(a)-parseInt(n)})),t}},{key:"getAllPostPath",value:function(){var e=s("83f3");return e.keys()}},{key:"getAllPostContent",value:function(){if(this.TotalPost.length){var e=Object(i["k"])([]);return e.value=this.TotalPost,{res:e}}var t=this.getAllPostPath();return Object(r["e"])(Promise.all(t.map(function(){var e=Object(c["a"])(regeneratorRuntime.mark((function e(t){var s,c;return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:return s=o["a"].getPostName(t),e.next=3,o["a"].getPostInfo(s);case 3:return c=e.sent,e.abrupt("return",c);case 5:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}())))}},{key:"getAllPostTag",value:function(){var e=[];return this.TotalPost.map((function(t){var s;null===t||void 0===t||null===(s=t.tags)||void 0===s||s.map((function(t){e.indexOf(t)<0&&e.push(t)}))})),e}}]),e}();t["a"]=new h},"61c0":function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])('<p>Vue是目前最常用的开发框架之一，要理解透彻其内在机理，还需要从学习源码入手，理解其中每一个关键设计的具体实现，感受尤大神的代码风格，这里整理了我顺着一些参考文章学习源码的读书笔记，为了节省篇幅，源码的粘贴会去掉部分对当前段落的理解无重要意义的片段。单个方法内会涉及到不同方面的功能逻辑，但是为了更加清晰，我期望能够划分初始化、组件、响应式原理、生命周期、事件、组件这几部分分成不同的文章来进行介绍，在对应内容中会详细介绍包含的逻辑，在其他部分则忽略不相关内容。</p><p>参考资料：</p><ul><li>Vue.js技术揭秘 <a href="https://ustbhuangyi.github.io/vue-analysis/" target="_blank">[资料原地址]</a></li><li>Vue.js 2.x源码 <a href="https://github.com/vuejs/vue" target="_blank">[源码地址]</a></li></ul><h1>一. Vue构建入口</h1><h2>1. 构建过程</h2><p>Vue.js的源码是基于<code>Rollup</code>构建的，<code>package.json</code>中配置了构建时是执行<code>script/build.js</code>文件</p>',6),a=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-json"},[Object(c["h"])("{\n    "),Object(c["i"])("span",{class:"hljs-attr"},'"scripts"'),Object(c["h"])(": {\n        "),Object(c["i"])("span",{class:"hljs-attr"},'"build"'),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},'"node scripts/build.js"'),Object(c["h"])(",\n        "),Object(c["i"])("span",{class:"hljs-attr"},'"build:ssr"'),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},'"npm run build -- runtime-cjs,server-renderer"'),Object(c["h"])(",\n    }\n}\n")])],-1),l=Object(c["g"])("<p>在<code>script/build.js</code>文件中就定义了整个构建的过程，从<code>./config</code>文件中读取所有的构建配置，通过命令行参数对构建配置进行过滤，再逐次进行不同用途<code>Vue.js</code>的构建。<code>build(builds)</code>函数就是整个构建过程，包含读取源文件、用<code>rollup</code>进行代码压缩、生成并写入输出目录中对应的文件三个主要步骤</p><blockquote><p>process是node中的一个模块，通过process.argv能够获取到命令执行node程序时所传入的参数，第一个参数是node.exe绝对路径，第二个参数是node执行的文件的绝对路径，其后的参数是命令行中所传的其他参数，例如上面的代码中<code>process.argv[2] = -- runtime-cjs,server-renderer</code></p></blockquote>",2),i=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-comment"},"// scripts/build.js"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" builds = "),Object(c["i"])("span",{class:"hljs-built_in"},"require"),Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-string"},"'./config'"),Object(c["h"])(").getAllBuilds()\n"),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (process.argv["),Object(c["i"])("span",{class:"hljs-number"},"2"),Object(c["h"])("]) { "),Object(c["i"])("span",{class:"hljs-comment"},"// 命令行参数"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" filters = process.argv["),Object(c["i"])("span",{class:"hljs-number"},"2"),Object(c["h"])("].split("),Object(c["i"])("span",{class:"hljs-string"},"','"),Object(c["h"])(")\n    builds = builds.filter("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"b"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" filters.some("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"f"),Object(c["h"])(" =>")]),Object(c["h"])(" b.output.file.indexOf(f) > "),Object(c["i"])("span",{class:"hljs-number"},"-1"),Object(c["h"])(" || b._name.indexOf(f) > "),Object(c["i"])("span",{class:"hljs-number"},"-1"),Object(c["h"])(")\n    })\n}\n\nbuild(builds)\n")])],-1),j=Object(c["g"])("<p>从<code>./config</code>中可以看到构建配置都是遵循<code>rollup</code>的语法定义的，<code>entry</code>代表构建入口文件，<code>dest</code>代表构建后的JS文件地址，<code>format</code>代表构建格式，<code>cjs</code>代表构建出来的文件遵循<code>CommonJS</code>规范，<code>es</code>代表构建出来的文件遵循<code>ES Module</code>规范，<code>umd</code>代表构建出来的文件遵循<code>umd</code>规范。<code>banner</code>代表在打包好的文件的块的外部最顶部插入一段内容。</p>",1),o=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-comment"},"// scripts/config.js"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" aliases = "),Object(c["i"])("span",{class:"hljs-built_in"},"require"),Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-string"},"'./alias'"),Object(c["h"])(")\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" resolve = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"p"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" base = p.split("),Object(c["i"])("span",{class:"hljs-string"},"'/'"),Object(c["h"])(")["),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])("]\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (aliases[base]) {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" path.resolve(aliases[base], p.slice(base.length + "),Object(c["i"])("span",{class:"hljs-number"},"1"),Object(c["h"])("))\n    } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" path.resolve(__dirname, "),Object(c["i"])("span",{class:"hljs-string"},"'../'"),Object(c["h"])(", p)\n    }\n}\n\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" builds = {\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-string"},"'runtime-cjs-dev'"),Object(c["h"])(": {\n        "),Object(c["i"])("span",{class:"hljs-attr"},"entry"),Object(c["h"])(": resolve("),Object(c["i"])("span",{class:"hljs-string"},"'web/entry-runtime.ts'"),Object(c["h"])("),\n        "),Object(c["i"])("span",{class:"hljs-attr"},"dest"),Object(c["h"])(": resolve("),Object(c["i"])("span",{class:"hljs-string"},"'dist/vue.runtime.common.dev.js'"),Object(c["h"])("),\n        "),Object(c["i"])("span",{class:"hljs-attr"},"format"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'cjs'"),Object(c["h"])(",\n        "),Object(c["i"])("span",{class:"hljs-attr"},"env"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'development'"),Object(c["h"])(",\n        banner\n    }\n}\n")])],-1),r=Object(c["g"])("<p><code>builds</code>定义的每一项路径中也都包含了<code>resolve</code>方法，<code>resolve</code>函数的实现是将传入的路径进行分割，取首位作为<code>base</code>，从<code>./alias</code>中的配置可以兑换得到一个别名，上面代码中的示例，入口为<code>src/platforms/web/entry-runtime.ts</code>，输出目录<code>dist/vue.runtime.common.dev.js</code></p>",1),h=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-comment"},"// scripts/alias.js"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-built_in"},"module"),Object(c["h"])(".exports = {\n    "),Object(c["i"])("span",{class:"hljs-attr"},"vue"),Object(c["h"])(": resolve("),Object(c["i"])("span",{class:"hljs-string"},"'src/platforms/web/entry-runtime-with-compiler'"),Object(c["h"])("),\n    "),Object(c["i"])("span",{class:"hljs-attr"},"compiler"),Object(c["h"])(": resolve("),Object(c["i"])("span",{class:"hljs-string"},"'src/compiler'"),Object(c["h"])("),\n    "),Object(c["i"])("span",{class:"hljs-attr"},"core"),Object(c["h"])(": resolve("),Object(c["i"])("span",{class:"hljs-string"},"'src/core'"),Object(c["h"])("),\n    "),Object(c["i"])("span",{class:"hljs-attr"},"shared"),Object(c["h"])(": resolve("),Object(c["i"])("span",{class:"hljs-string"},"'src/shared'"),Object(c["h"])("),\n    "),Object(c["i"])("span",{class:"hljs-attr"},"web"),Object(c["h"])(": resolve("),Object(c["i"])("span",{class:"hljs-string"},"'src/platforms/web'"),Object(c["h"])("),\n    "),Object(c["i"])("span",{class:"hljs-attr"},"server"),Object(c["h"])(": resolve("),Object(c["i"])("span",{class:"hljs-string"},"'packages/server-renderer/src'"),Object(c["h"])("),\n    "),Object(c["i"])("span",{class:"hljs-attr"},"sfc"),Object(c["h"])(": resolve("),Object(c["i"])("span",{class:"hljs-string"},"'packages/compiler-sfc/src'"),Object(c["h"])(")\n}\n")])],-1),b=Object(c["g"])('<blockquote><p>Runtime Only和Runtime Compiler版本的区别：</p><ul><li>Runtime Only: 通常需要借助webpack的vue-loader把Vue编译成JavaScript，因为是在编译阶段做的，所以它只包含运行时的Vue.js代码，相对轻量。在将.vue文件编译为JS文件的过程中，会将组件中的<code>template</code>通过<code>vue-template-compiler</code>编译为<code>render</code>函数，运行过程中不带编译，编译是在离线的时候做的</li><li>Runtime Compiler: 没有对代码进行预编译，在运行时，将组件中的<code>template</code>编译为<code>render</code>函数，相对更重，编译过程会对性能有损耗</li></ul><p>下面是通过两种版本生成的新Vue工程main.ts的截图，可以看到<code>Runtime-Only</code>版本中主要参数是<code>render</code>方法，而<code>Runtime-Compiler</code>版本中的主要参数是<code>components</code>和<code>template</code>。在运行过程中，通过<code>template</code>传入字符串，则需要<code>Runtime-Compiler</code>版本，如果<code>template</code>都定义在.vue文件中，则使用<code>Runtime-Only</code>版本即可 <img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-15/1.png"></p></blockquote><h1>二. new Vue</h1><h2>1. Vue初始化定义</h2><p>上一小节，我们可以从<code>scripts/alias.js</code>中看到，编译<code>vue.js</code>的入口文件是<code>src/platforms/web/entry-runtime-with-compiler</code></p>',4),p=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-comment"},"// src/platforms/web/entry-runtime-with-compiler.ts"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" Vue "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'./runtime-with-compiler'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" * "),Object(c["i"])("span",{class:"hljs-keyword"},"as"),Object(c["h"])(" vca "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'v3'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" { extend } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'shared/util'"),Object(c["h"])("\n\nextend(Vue, vca)\n\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" { effect } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'v3/reactivity/effect'"),Object(c["h"])("\nVue.effect = effect\n\n"),Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"default"),Object(c["h"])(" Vue\n")])],-1),O=Object(c["i"])("p",null,[Object(c["h"])("这个文件代码很简单，就是从"),Object(c["i"])("code",null,"src/platforms/web/runtime-with-compiler"),Object(c["h"])("目录引入了"),Object(c["i"])("code",null,"Vue"),Object(c["h"])("，在"),Object(c["i"])("code",null,"src/platforms/web/runtime-with-compiler"),Object(c["h"])("文件中，又从"),Object(c["i"])("code",null,"src/platforms/web/runtime/index.ts"),Object(c["h"])("中引入了"),Object(c["i"])("code",null,"Vue")],-1),d=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" Vue "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'./runtime/index'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" { compileToFunctions } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'./compiler/index'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" type { GlobalAPI } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'types/global-api'"),Object(c["h"])("\n\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" mount = Vue.prototype.$mount\nVue.prototype.$mount = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-params"}),Object(c["h"])(")")]),Object(c["h"])("{ ... }\nVue.compile = compileToFunctions\n"),Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"default"),Object(c["h"])(" Vue "),Object(c["i"])("span",{class:"hljs-keyword"},"as"),Object(c["h"])(" GlobalAPI\n")])],-1),u=Object(c["g"])("<p>一路追踪，最后可以看到<code>Vue</code>的定义文件是在<code>src/core/instance/index.js</code>，可以看到这里还有很多<code>mixin</code>将<code>Vue</code>作为参数传入，都是在<code>Vue</code>的<code>prototype</code>上扩展方法，可以分散到不同的模块去实现，而不是在同一个模块内实现所有，这种方式ES6的Class很难实现，方便代码的维护和管理。这些<code>mixin</code>分则负责不同的模块功能：</p><ul><li><code>initMixin</code>：定义了<code>_init</code>初始化Vue的方法，这个方法会在2.1中进行详细介绍</li><li><code>stateMixin</code>：数据相关的mixin，主要是<code>$data</code>、<code>$prop</code>的监听，初始化为<code>Vue.prototype</code>添加<code>$set</code>、<code>$delete</code>、<code>$watch</code>方法</li><li><code>eventsMixin</code>：初始化为<code>Vue.prototype</code>添加<code>$on</code>、<code>$once</code>、<code>$off</code>、<code>$emit</code>方法。</li><li><code>lifecycleMixin</code>：初始化为<code>Vue.prototype</code>添加<code>_update</code>、<code>$forceUpdate</code>、<code>$destroy</code>方法</li><li><code>renderMixin</code>：初始化渲染，将在3.1中进行详细介绍</li></ul>",2),m=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-comment"},"// src/core/instance/index.js"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" { initMixin } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'./init'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" { stateMixin } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'./state'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" { renderMixin } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'./render'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" { eventsMixin } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'./events'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" { lifecycleMixin } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'./lifecycle'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" type { GlobalAPI } "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'types/global-api'"),Object(c["h"])("\n\n"),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-title"},"Vue"),Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"options"),Object(c["h"])(") ")]),Object(c["h"])("{\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\n"),Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"default"),Object(c["h"])(" Vue "),Object(c["i"])("span",{class:"hljs-keyword"},"as"),Object(c["h"])(" unknown "),Object(c["i"])("span",{class:"hljs-keyword"},"as"),Object(c["h"])(" GlobalAPI\n")])],-1),g=Object(c["g"])("<h2>2. new Vue做了什么</h2><p>上一章中讲到<code>Vue</code>是一个用<code>Function</code>实现的类，新建<code>Vue</code>实例，就是通过<code>new Vue()</code>来实现的，这个时候会执行函数中的<code>this._init(options)</code>方法。这个方法是定义在<code>src/core/instance/init.ts</code>中的，可以看到<code>new Vue</code>的时候就是做了一系列的初始化，包含</p><ul><li>初始化组件 / 合并配置</li><li>初始化生命周期</li><li>初始化事件中心</li><li>初始化渲染</li><li>调用<code>beforeCreate</code>钩子</li><li>初始化<code>inject</code></li><li>初始化数据</li><li>初始化<code>provide</code></li><li>注册<code>create</code>钩子</li><li>挂载<code>vm</code></li></ul>",3),f=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-comment"},"// src/core/instance/init.ts"),Object(c["h"])("\nVue.prototype._init = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-params"},"options?: Record<string, any>"),Object(c["h"])(") ")]),Object(c["h"])("{\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" vm: Component = "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("\n    vm._uid = uid++ "),Object(c["i"])("span",{class:"hljs-comment"},"// 保证vue创建实例的唯一性"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// effect scope"),Object(c["h"])("\n    vm._scope = "),Object(c["i"])("span",{class:"hljs-keyword"},"new"),Object(c["h"])(" EffectScope("),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-comment"},"/* detached */"),Object(c["h"])(")\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// merge options"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (options && options._isComponent) {\n        "),Object(c["i"])("span",{class:"hljs-comment"},"// optimize internal component instantiation"),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-comment"},"// since dynamic options merging is pretty slow, and none of the"),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-comment"},"// internal component options needs special treatment."),Object(c["h"])("\n        initInternalComponent(vm, options "),Object(c["i"])("span",{class:"hljs-keyword"},"as"),Object(c["h"])(" any)\n    } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(" {\n        vm.$options = mergeOptions(\n            resolveConstructorOptions(vm.constructor "),Object(c["i"])("span",{class:"hljs-keyword"},"as"),Object(c["h"])(" any),\n            options || {},\n            vm\n        )\n    }\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, "),Object(c["i"])("span",{class:"hljs-string"},"'beforeCreate'"),Object(c["h"])(")\n    initInjections(vm) "),Object(c["i"])("span",{class:"hljs-comment"},"// resolve injections before data/props"),Object(c["h"])("\n    initState(vm)\n    initProvide(vm) "),Object(c["i"])("span",{class:"hljs-comment"},"// resolve provide after data/props"),Object(c["h"])("\n    callHook(vm, "),Object(c["i"])("span",{class:"hljs-string"},"'created'"),Object(c["h"])(")\n\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (vm.$options.el) { "),Object(c["i"])("span",{class:"hljs-comment"},"// 如果存在el则将vm挂载在el上，如果没有el，则需要手动挂载"),Object(c["h"])("\n        vm.$mount(vm.$options.el)\n    }\n}\n")])],-1),v=Object(c["g"])("<h2>3. vm挂载</h2><p>new Vue的过程中会挂载<code>vm</code>，其实挂载的过程就是将vue模板渲染为真实的DOM结构的过程。<code>$mount</code>的实现在<code>src/platforms/web/runtime-with-compiler.ts</code>。<code>$mount</code>需要传入两个参数，<code>el</code>代表的是挂载的元素，可以是字符串，也可以是DOM对象，如果是字符串在浏览器环境下会通过<code>query</code>方法转换为DOM对象。第二个参数<code>hydrating</code>与服务端渲染有关，在浏览器环境下我们不需要传第二个参数。</p>",2),y=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-comment"},"// src/platforms/web/runtime-with-compiler.ts"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" mount = Vue.prototype.$mount\nVue.prototype.$mount = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-params"},"\n    el?: string | Element,\n    hydrating?: boolean\n"),Object(c["h"])("): "),Object(c["i"])("span",{class:"hljs-title"},"Component"),Object(c["h"])()]),Object(c["h"])("{\n    el = el && query(el)\n\n    "),Object(c["i"])("span",{class:"hljs-comment"},"/* istanbul ignore if */"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (el === "),Object(c["i"])("span",{class:"hljs-built_in"},"document"),Object(c["h"])(".body || el === "),Object(c["i"])("span",{class:"hljs-built_in"},"document"),Object(c["h"])(".documentElement) {\n        __DEV__ &&\n        warn(\n            "),Object(c["i"])("span",{class:"hljs-string"},"`Do not mount Vue to <html> or <body> - mount to normal elements instead.`"),Object(c["h"])("\n        )\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("\n    }\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" options = "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".$options\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// resolve template/el and convert to render function"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (!options.render) {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" template = options.template\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (template) {\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-keyword"},"typeof"),Object(c["h"])(" template === "),Object(c["i"])("span",{class:"hljs-string"},"'string'"),Object(c["h"])(") {\n                "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (template.charAt("),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])(") === "),Object(c["i"])("span",{class:"hljs-string"},"'#'"),Object(c["h"])(") {\n                    template = idToTemplate(template) "),Object(c["i"])("span",{class:"hljs-comment"},"// 查找对应selector的节点作为template"),Object(c["h"])("\n                }\n            } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (template.nodeType) {\n                template = template.innerHTML\n            } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(" {\n                "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("\n            }\n        } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (el) {\n            template = getOuterHTML(el) "),Object(c["i"])("span",{class:"hljs-comment"},"// 找el的外层元素的innerHtml"),Object(c["h"])("\n        }\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (template) {\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" { render, staticRenderFns } = compileToFunctions(\n                template,\n                {\n                    "),Object(c["i"])("span",{class:"hljs-attr"},"outputSourceRange"),Object(c["h"])(": __DEV__,\n                    shouldDecodeNewlines,\n                    shouldDecodeNewlinesForHref,\n                    "),Object(c["i"])("span",{class:"hljs-attr"},"delimiters"),Object(c["h"])(": options.delimiters,\n                    "),Object(c["i"])("span",{class:"hljs-attr"},"comments"),Object(c["h"])(": options.comments\n                },\n                "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("\n            )\n            options.render = render\n            options.staticRenderFns = staticRenderFns\n        }\n    }\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" mount.call("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(", el, hydrating)\n}\n")])],-1),w=Object(c["g"])("<p>这段代码中，首先，缓存了原型上的<code>$mount</code>方法，对<code>el</code>做了限制，Vue不能挂在在<code>html</code>和<code>body</code>这样的根节点上。接下来就是挂载的核心逻辑，如果没有<code>render</code>方法，就会把<code>el</code>和<code>template</code>转换为<code>render</code>方法。转换的过程需要先获取<code>template</code>，是根据定义的<code>template</code>、通过<code>query</code>方法解析字符串、获取<code>el</code>的外层节点<code>html</code>三种途径来实现的，最后通过<code>compileToFunctions</code>将<code>template</code>转换为<code>render</code>方法。在Vue2中，所有组件的渲染最后都要依赖<code>render</code>方法，不论是用单文件<code>.vue</code>方式开发组件，还是定义了<code>el</code>和<code>template</code>属性，最终都会转换为<code>render</code>方法。</p><p>再看原本原型上的<code>$mount</code>方法，这部分方法定义在<code>src/platforms/web/runtime/index.ts</code>，该方法中引用了方法<code>mountComponent</code>，定义在<code>src/core/instance/lifecycle.ts</code>。可以看到<code>mountComponent</code>所做的事情主要包含：</p><ul><li>调用<code>beforeMount</code>钩子</li><li>实例化一个渲染<code>Watcher</code>，在回调中调用<code>updateComponent</code>方法，在该方法中调用<code>vm._render</code>方法生成虚拟Node，最终调用<code>vm._update</code>更新DOM，在更新之前调用<code>beforeUpdate</code>钩子。Watcher在初始化的时候会执行回调函数，在<code>vm</code>实例中监测的数据发生变化的时候也会执行回调函数。</li><li>watcher都执行过，调用<code>mounted</code>钩子。其中<code>vm.$vnode</code>标识Vue实例的父虚拟Node，它为Null则标识当前是根Vue的实例，表示已经挂载完成</li></ul>",3),k=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-comment"},"// src/platforms/web/runtime/index.ts"),Object(c["h"])("\nVue.prototype.$mount = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-params"},"\n    el?: string | Element,\n    hydrating?: boolean\n"),Object(c["h"])("): "),Object(c["i"])("span",{class:"hljs-title"},"Component"),Object(c["h"])()]),Object(c["h"])("{\n    el = el && inBrowser ? query(el) : "),Object(c["i"])("span",{class:"hljs-literal"},"undefined"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" mountComponent("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(", el, hydrating)\n}\n\n"),Object(c["i"])("span",{class:"hljs-comment"},"// src/core/instance/lifecycle.ts"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-title"},"mountComponent"),Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"\n    vm: Component,\n    el: Element | null | undefined,\n    hydrating?: boolean\n"),Object(c["h"])("): "),Object(c["i"])("span",{class:"hljs-title"},"Component"),Object(c["h"])()]),Object(c["h"])("{\n    vm.$el = el\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (!vm.$options.render) {\n        vm.$options.render = createEmptyVNode\n    }\n    callHook(vm, "),Object(c["i"])("span",{class:"hljs-string"},"'beforeMount'"),Object(c["h"])(")\n\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" updateComponent\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (__DEV__ && config.performance && mark) {\n        updateComponent = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"()"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" vnode = vm._render()\n            vm._update(vnode, hydrating)\n        }\n    } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(" {\n        updateComponent = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"()"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n            vm._update(vm._render(), hydrating)\n        }\n    }\n\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" watcherOptions: WatcherOptions = {\n        before() {\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (vm._isMounted && !vm._isDestroyed) {\n                callHook(vm, "),Object(c["i"])("span",{class:"hljs-string"},"'beforeUpdate'"),Object(c["h"])(")\n            }\n        }\n    }\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// we set this to vm._watcher inside the watcher's constructor"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// since the watcher's initial patch may call $forceUpdate (e.g. inside child"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// component's mounted hook), which relies on vm._watcher being already defined"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"new"),Object(c["h"])(" Watcher(\n        vm,\n        updateComponent,\n        noop,\n        watcherOptions,\n        "),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-comment"},"/* isRenderWatcher */"),Object(c["h"])("\n    )\n    hydrating = "),Object(c["i"])("span",{class:"hljs-literal"},"false"),Object(c["h"])("\n\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// manually mounted instance, call mounted on self"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// mounted is called for render-created child components in its inserted hook"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (vm.$vnode == "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(") {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" preWatchers = vm._preWatchers\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (preWatchers) {\n            "),Object(c["i"])("span",{class:"hljs-keyword"},"for"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" i = "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])("; i < preWatchers.length; i++) {\n                preWatchers[i].run()\n            }\n        }\n        vm._isMounted = "),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])("\n        callHook(vm, "),Object(c["i"])("span",{class:"hljs-string"},"'mounted'"),Object(c["h"])(")\n    }\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" vm\n}\n")])],-1),x=Object(c["g"])("<h1>三. 渲染</h1><p>初始化渲染的逻辑主要包含两个方面，一是<code>二.1</code>节中<code>new Vue</code>的<code>_init</code>方法中执行的<code>initRender</code>方法，二是上一节中挂载<code>vm</code>中调用的<code>vm._render</code>方法。</p><h2>1. initRender</h2><p>initRender方法定义在<code>src/core/instance/render.ts</code>中，这一部分做的主要的事情就是为vm绑定<code>$createElement</code>方法，这个方法会在我们下一小节中介绍的<code>_render</code>中调用到，其次就是处理插槽逻辑，绑定监听vm的<code>$attrs</code>和<code>$listeners</code></p>",4),V=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-comment"},"// src/core/instance/render.ts"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-title"},"initRender"),Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"vm: Component"),Object(c["h"])(") ")]),Object(c["h"])("{\n    vm._vnode = "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-comment"},"// the root of the child tree  // 存放虚拟Node"),Object(c["h"])("\n    vm._staticTrees = "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-comment"},"// v-once cached trees // 缓存静态节点，只渲染元素和组件一次"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" options = vm.$options\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" parentVnode = (vm.$vnode = options._parentVnode!) "),Object(c["i"])("span",{class:"hljs-comment"},"// the placeholder node in parent tree"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" renderContext = parentVnode && (parentVnode.context "),Object(c["i"])("span",{class:"hljs-keyword"},"as"),Object(c["h"])(" Component)\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// 插槽逻辑"),Object(c["h"])("\n    vm.$slots = resolveSlots(options._renderChildren, renderContext)\n    vm.$scopedSlots = emptyObject\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// 创建虚拟Node"),Object(c["h"])("\n    vm._c = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"a, b, c, d"),Object(c["h"])(") =>")]),Object(c["h"])(" createElement(vm, a, b, c, d, "),Object(c["i"])("span",{class:"hljs-literal"},"false"),Object(c["h"])(")\n    vm.$createElement = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"a, b, c, d"),Object(c["h"])(") =>")]),Object(c["h"])(" createElement(vm, a, b, c, d, "),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])(")\n\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// $attrs & $listeners are exposed for easier HOC creation."),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// they need to be reactive so that HOCs using them are always updated"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" parentData = parentVnode && parentVnode.data\n\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// 代理，监听绑定vm中的属性"),Object(c["h"])("\n    defineReactive(\n        vm,\n        "),Object(c["i"])("span",{class:"hljs-string"},"'$attrs'"),Object(c["h"])(",\n        (parentData && parentData.attrs) || emptyObject,\n        "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(",\n        "),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])("\n    )\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// 代理，监听绑定vm的事件监听器"),Object(c["h"])("\n    defineReactive(\n        vm,\n        "),Object(c["i"])("span",{class:"hljs-string"},"'$listeners'"),Object(c["h"])(",\n        options._parentListeners || emptyObject,\n        "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(",\n        "),Object(c["i"])("span",{class:"hljs-literal"},"true"),Object(c["h"])("\n    )\n}\n")])],-1),C=Object(c["g"])("<h2>2. _render</h2><h3>1). VNode</h3><p><code>_render</code>是实例的私有方法，作用是将实例渲染成一个虚拟Node。在正式了解渲染过程之前，首先需要掌握的是虚拟Node这个概念，其产生的前提是因为浏览器中的DOM是非常耗费成本的，更直观的感受是，打印一个<code>div</code>出来，会看到真正的DOM元素非常庞大，浏览器标准将DOM设计的非常复杂，频繁更新DOM会牵扯到性能问题。虚拟Node，Virtual Dom就是用一个原生的JS对象去描述一个DOM节点，所以比创建DOM代价要小，Vue中<code>VNode</code>的定义是在<code>src/core/vdom/vnode.ts</code>中，可以看到VNode的核心无非就是几个关键属性，但是要把虚拟Node映射到真实的DOM结构，还是需要经过<code>create</code>、<code>diff</code>、<code>patch</code>等过程，将在后续的文章内容中进行更加详细地解释和介绍。</p>",3),S=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"default"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-class"},[Object(c["i"])("span",{class:"hljs-keyword"},"class"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-title"},"VNode"),Object(c["h"])()]),Object(c["h"])("{\n    tag?: string\n    "),Object(c["i"])("span",{class:"hljs-attr"},"data"),Object(c["h"])(": VNodeData | "),Object(c["i"])("span",{class:"hljs-literal"},"undefined"),Object(c["h"])("\n    children?: "),Object(c["i"])("span",{class:"hljs-built_in"},"Array"),Object(c["h"])("<VNode> | "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])("\n    text?: string\n    "),Object(c["i"])("span",{class:"hljs-attr"},"elm"),Object(c["h"])(": Node | "),Object(c["i"])("span",{class:"hljs-literal"},"undefined"),Object(c["h"])("\n    ns?: string\n    context?: Component "),Object(c["i"])("span",{class:"hljs-comment"},"// rendered in this component's scope"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"key"),Object(c["h"])(": string | number | "),Object(c["i"])("span",{class:"hljs-literal"},"undefined"),Object(c["h"])("\n    componentOptions?: VNodeComponentOptions\n    componentInstance?: Component "),Object(c["i"])("span",{class:"hljs-comment"},"// component instance"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"parent"),Object(c["h"])(": VNode | "),Object(c["i"])("span",{class:"hljs-literal"},"undefined"),Object(c["h"])(" | "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-comment"},"// component placeholder node"),Object(c["h"])("\n\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// strictly internal"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"raw"),Object(c["h"])(": boolean "),Object(c["i"])("span",{class:"hljs-comment"},"// contains raw HTML? (server only)"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"isStatic"),Object(c["h"])(": boolean "),Object(c["i"])("span",{class:"hljs-comment"},"// hoisted static node"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"isRootInsert"),Object(c["h"])(": boolean "),Object(c["i"])("span",{class:"hljs-comment"},"// necessary for enter transition check"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"isComment"),Object(c["h"])(": boolean "),Object(c["i"])("span",{class:"hljs-comment"},"// empty comment placeholder?"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"isCloned"),Object(c["h"])(": boolean "),Object(c["i"])("span",{class:"hljs-comment"},"// is a cloned node?"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"isOnce"),Object(c["h"])(": boolean "),Object(c["i"])("span",{class:"hljs-comment"},"// is a v-once node?"),Object(c["h"])("\n    asyncFactory?: "),Object(c["i"])("span",{class:"hljs-built_in"},"Function"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-comment"},"// async component factory function"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"asyncMeta"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-built_in"},"Object"),Object(c["h"])(" | "),Object(c["i"])("span",{class:"hljs-keyword"},"void"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"isAsyncPlaceholder"),Object(c["h"])(": boolean\n    ssrContext?: "),Object(c["i"])("span",{class:"hljs-built_in"},"Object"),Object(c["h"])(" | "),Object(c["i"])("span",{class:"hljs-keyword"},"void"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-attr"},"fnContext"),Object(c["h"])(": Component | "),Object(c["i"])("span",{class:"hljs-keyword"},"void"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-comment"},"// real context vm for functional nodes"),Object(c["h"])("\n    fnOptions?: ComponentOptions | "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-comment"},"// for SSR caching"),Object(c["h"])("\n    devtoolsMeta?: "),Object(c["i"])("span",{class:"hljs-built_in"},"Object"),Object(c["h"])(" | "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-comment"},"// used to store functional render context for devtools"),Object(c["h"])("\n    fnScopeId?: string | "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-comment"},"// functional scope id support"),Object(c["h"])("\n\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// DEPRECATED: alias for componentInstance for backwards compat."),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-comment"},"/* istanbul ignore next */"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"get"),Object(c["h"])(" child(): Component | void {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".componentInstance\n    }\n}\n")])],-1),I=Object(c["g"])("<h3>2). _render</h3><p>讲回<code>_render</code>，该方法定义在<code>src/core/instance/render.ts</code>里，这个方法主要做的是：</p><ul><li>初始化<code>vm</code>的插槽节点</li><li>创建<code>vm</code>实例</li><li>用<code>$createElement</code>方法去生成<code>vm</code>的虚拟Node</li><li>兜底是创建空<code>VNode</code></li></ul>",3),_=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-comment"},"// src/core/instance/render.ts"),Object(c["h"])("\nVue.prototype._render = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-params"}),Object(c["h"])("): "),Object(c["i"])("span",{class:"hljs-title"},"VNode"),Object(c["h"])()]),Object(c["h"])("{\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" vm: Component = "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" { render, _parentVnode } = vm.$options\n\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(\n            vm.$parent!,\n            _parentVnode.data!.scopedSlots,\n            vm.$slots,\n            vm.$scopedSlots\n        )\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (vm._slotsProxy) {\n            syncSetupSlots(vm._slotsProxy, vm.$scopedSlots)\n        }\n    }\n\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// set parent vnode. this allows render functions to have access"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// to the data on the placeholder node."),Object(c["h"])("\n    vm.$vnode = _parentVnode!\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// render self"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" vnode\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"try"),Object(c["h"])(" {\n      "),Object(c["i"])("span",{class:"hljs-comment"},"// There's no need to maintain a stack because all render fns are called"),Object(c["h"])("\n      "),Object(c["i"])("span",{class:"hljs-comment"},"// separately from one another. Nested component's render fns are called"),Object(c["h"])("\n      "),Object(c["i"])("span",{class:"hljs-comment"},"// when parent component is patched."),Object(c["h"])("\n      setCurrentInstance(vm)\n      currentRenderingInstance = vm\n      vnode = render.call(vm._renderProxy, vm.$createElement)\n    } "),Object(c["i"])("span",{class:"hljs-keyword"},"catch"),Object(c["h"])(" (e: any) {\n      handleError(e, vm, "),Object(c["i"])("span",{class:"hljs-string"},"`render`"),Object(c["h"])(")\n    } "),Object(c["i"])("span",{class:"hljs-keyword"},"finally"),Object(c["h"])(" {\n        currentRenderingInstance = "),Object(c["i"])("span",{class:"hljs-literal"},"null"),Object(c["h"])("\n        setCurrentInstance()\n    }\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// if the returned array contains only a single node, allow it"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (isArray(vnode) && vnode.length === "),Object(c["i"])("span",{class:"hljs-number"},"1"),Object(c["h"])(") {\n        vnode = vnode["),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])("]\n    }\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// return empty vnode in case the render function errored out"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (!(vnode "),Object(c["i"])("span",{class:"hljs-keyword"},"instanceof"),Object(c["h"])(" VNode)) {\n        vnode = createEmptyVNode()\n    }\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// set parent"),Object(c["h"])("\n    vnode.parent = _parentVnode\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" vnode\n}\n")])],-1),E=Object(c["g"])("<p>这里使用到的<code>$createElement</code>的方法最终的定义是在<code>src/core/vdom/create-element.ts</code>中，可以看到这个方法共5个参数，<code>context</code>代表VNode的上下文环境，是<code>Component</code>类型，<code>tag</code>表示标签，可以是多种类型，<code>data</code>表示VNode的数据，是<code>VNodeData</code>类型，<code>children</code>代表VNode的子节点，<code>normalizationType</code>表示子节点规范的类型，类型不同规范的方法就不同，主要是参考<code>render</code>方法是用户定义的，还是自动编译生成的。</p>",1),P=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-title"},"_createElement"),Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"\n    context: Component,\n    tag?: string | Component | Function | Object,\n    data?: VNodeData,\n    children?: any,\n    normalizationType?: number\n"),Object(c["h"])("): "),Object(c["i"])("span",{class:"hljs-title"},"VNode"),Object(c["h"])(" | "),Object(c["i"])("span",{class:"hljs-title"},"Array"),Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-title"},"VNode"),Object(c["h"])("> ")]),Object(c["h"])("{\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (isDef(data) && isDef((data "),Object(c["i"])("span",{class:"hljs-keyword"},"as"),Object(c["h"])(" any).__ob__)) {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" createEmptyVNode()\n    }\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// object syntax in v-bind"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (isDef(data) && isDef(data.is)) {\n        tag = data.is\n    }\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (!tag) {\n        "),Object(c["i"])("span",{class:"hljs-comment"},"// in case of component :is set to falsy value"),Object(c["h"])("\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" createEmptyVNode()\n    }\n    "),Object(c["i"])("span",{class:"hljs-comment"},"// support single function children as default scoped slot"),Object(c["h"])("\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (isArray(children) && isFunction(children["),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])("])) {\n        data = data || {}\n        data.scopedSlots = { "),Object(c["i"])("span",{class:"hljs-attr"},"default"),Object(c["h"])(": children["),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])("] }\n        children.length = "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])("\n    }\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (normalizationType === ALWAYS_NORMALIZE) {\n        children = normalizeChildren(children)\n    } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (normalizationType === SIMPLE_NORMALIZE) {\n        children = simpleNormalizeChildren(children)\n    }\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" vnode, ns\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-keyword"},"typeof"),Object(c["h"])(" tag === "),Object(c["i"])("span",{class:"hljs-string"},"'string'"),Object(c["h"])(") {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" Ctor\n        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (config.isReservedTag(tag)) {\n            vnode = "),Object(c["i"])("span",{class:"hljs-keyword"},"new"),Object(c["h"])(" VNode(\n                config.parsePlatformTagName(tag),\n                data,\n                children,\n                "),Object(c["i"])("span",{class:"hljs-literal"},"undefined"),Object(c["h"])(",\n                "),Object(c["i"])("span",{class:"hljs-literal"},"undefined"),Object(c["h"])(",\n                context\n            )\n        } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (\n            (!data || !data.pre) &&\n            isDef((Ctor = resolveAsset(context.$options, "),Object(c["i"])("span",{class:"hljs-string"},"'components'"),Object(c["h"])(", tag)))\n        ) {\n            "),Object(c["i"])("span",{class:"hljs-comment"},"// component"),Object(c["h"])("\n            vnode = createComponent(Ctor, data, context, children, tag)\n        } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(" {\n            "),Object(c["i"])("span",{class:"hljs-comment"},"// unknown or unlisted namespaced elements"),Object(c["h"])("\n            "),Object(c["i"])("span",{class:"hljs-comment"},"// check at runtime because it may get assigned a namespace when its"),Object(c["h"])("\n            "),Object(c["i"])("span",{class:"hljs-comment"},"// parent normalizes children"),Object(c["h"])("\n            vnode = "),Object(c["i"])("span",{class:"hljs-keyword"},"new"),Object(c["h"])(" VNode(tag, data, children, "),Object(c["i"])("span",{class:"hljs-literal"},"undefined"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-literal"},"undefined"),Object(c["h"])(", context)\n        }\n    } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-comment"},"// direct component options / constructor"),Object(c["h"])("\n        vnode = createComponent(tag "),Object(c["i"])("span",{class:"hljs-keyword"},"as"),Object(c["h"])(" any, data, context, children)\n    }\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (isArray(vnode)) {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" vnode\n    } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (isDef(vnode)) {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (isDef(ns)) applyNS(vnode, ns)\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (isDef(data)) registerDeepBindings(data)\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" vnode\n    } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(" {\n        "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" createEmptyVNode()\n    }\n}\n")])],-1),A=Object(c["g"])("<p><code>createElement</code>做的主要事情可以概括为<code>children</code>的规范化、创建<code>VNode</code>实例两个主要部分。</p><h4>1. children规范化</h4><p>由于Virtual Dom实际上是一个树形结构，每一个VNode会有若干子节点，子节点应该也是VNode类型的，但<code>_createElement</code>中接收的<code>children</code>是任意类型的，因此需要规范化children为<code>VNode</code>类型。从<code>_createElement</code>代码中可以看到规范化children有两种方法，<code>normalizeChildren</code>和<code>simpleNormalizeChildren</code>，他们的定义都在<code>src/core/helpers/normalize-children.ts</code></p><p><code>simpleNormalizeChildren</code>方法调用的场景是<code>render</code>函数编译生成的，理论上编译生成的children已经是<code>VNode</code>类型的，但有一个例外是，<code>functional component</code>函数式组件返回的是一个数组而不是根节点，所以需要通过<code>concat</code>方法，把数组拍平，让它的深度只有1层</p>",4),T=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-comment"},"// 1. When the children contains components - because a functional component"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-comment"},"// may return an Array instead of a single root. In this case, just a simple"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-comment"},"// normalization is needed - if any child is an Array, we flatten the whole"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-comment"},"// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-comment"},"// because functional components already normalize their own children."),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-title"},"simpleNormalizeChildren"),Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"children: any"),Object(c["h"])(") ")]),Object(c["h"])("{\n  "),Object(c["i"])("span",{class:"hljs-keyword"},"for"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" i = "),Object(c["i"])("span",{class:"hljs-number"},"0"),Object(c["h"])("; i < children.length; i++) {\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (isArray(children[i])) {\n      "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-built_in"},"Array"),Object(c["h"])(".prototype.concat.apply([], children)\n    }\n  }\n  "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" children\n}\n\n"),Object(c["i"])("span",{class:"hljs-comment"},"// 2. When the children contains constructs that always generated nested Arrays,"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-comment"},"// e.g. <template>, <slot>, v-for, or when the children is provided by user"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-comment"},"// with hand-written render functions / JSX. In such cases a full normalization"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-comment"},"// is needed to cater to all possible types of children values."),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"export"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-keyword"},"function"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-title"},"normalizeChildren"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-params"},"children: any"),Object(c["h"])("): ?"),Object(c["i"])("span",{class:"hljs-title"},"Array"),Object(c["h"])("<"),Object(c["i"])("span",{class:"hljs-title"},"VNode"),Object(c["h"])("> ")]),Object(c["h"])("{\n  "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(" isPrimitive(children)\n    ? [createTextVNode(children)]\n    : "),Object(c["i"])("span",{class:"hljs-built_in"},"Array"),Object(c["h"])(".isArray(children)\n      ? normalizeArrayChildren(children)\n      : "),Object(c["i"])("span",{class:"hljs-literal"},"undefined"),Object(c["h"])("\n}\n")])],-1),M=Object(c["g"])("<p><code>normalizeChildren</code>调用场景有2中，其一是<code>render</code>函数是用户手写的，当<code>children</code>只有一个节点时，Vue.js从接口层面允许用户把<code>children</code>写成基础类型用来创建单个简单的文本节点，这种情况会调用<code>createTextNode</code>创建一个文本节点的VNode；另一个场景是当<code>slot</code>、<code>v-for</code>的时候会产生嵌套数组的情况，需要调用<code>normalizeArrayChildren</code>方法</p>",1);function N(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n,a,l,i,j,o,r,h,b,p,O,d,u,m,g,f,v,y,w,k,x,V,C,S,I,_,E,P,A,T,M])}const z={};z.render=N;t["default"]=z},6237:function(e,t,s){},"62b5":function(e,t,s){"use strict";var c=s("d4ec"),n=s("bee2"),a=(s("159b"),s("ac1f"),s("466d"),s("5319"),s("99af"),s("d81d"),function(){function e(){Object(c["a"])(this,e),this.CatalogMaxLevels=3,this.CatalogList=[],this.CatalogOffset=null}return Object(n["a"])(e,[{key:"getCatalogOffset",value:function(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this.CatalogOffset||e){var t=document.getElementById("js-catalog");this.CatalogOffset={left:(null===t||void 0===t?void 0:t.offsetLeft)||0,top:(null===t||void 0===t?void 0:t.offsetTop)||0,width:(null===t||void 0===t?void 0:t.offsetWidth)||0}}return this.CatalogOffset}},{key:"getCatalogHtml",value:function(){var e=this,t=this.getAllH(),s=[],c="";if(this.CatalogList=t,!t||!t.length)return c;t.forEach((function(t,n){var a=e.getHText(t),l=e.getHLabel(t),i=s.indexOf(l);if(i<0)s.length<e.CatalogMaxLevels&&(s.unshift(l),c+=e.addStartUl(),c+=e.addLi(a,n));else if(0===i)c+=e.addLi(a,n);else{while(i--)s.shift(),c+=e.addEndUl();c+=e.addLi(a,n)}}));while(s.length)s.shift(),c+=this.addEndUl();return c}},{key:"anchor",value:function(e){if("A"===(null===e||void 0===e?void 0:e.target.nodeName)){var t,s,c=null===(t=e.target.attributes)||void 0===t||null===(s=t.href)||void 0===s?void 0:s.value,n=c.substring(1,c.length),a=document.getElementById(n);a&&a.scrollIntoView({behavior:"smooth"})}}},{key:"getAllH",value:function(){var e=document.getElementById("js-markdown-body"),t=e.innerHTML.match(/<[hH][1-6](\s.*?)>.*?<\/[hH][1-6]>/g);return t}},{key:"getHLabel",value:function(e){var t,s=null===(t=e.match(/<\w+?(\s.*?)>/))||void 0===t?void 0:t[0];return s.replace(/id=\"(.*?)\"/,"").replaceAll(/\s/g,"")}},{key:"getHText",value:function(e){return e.replace(/<[^>]+>/g,"")}},{key:"addStartUl",value:function(){return'<ul class="catalog-list">'}},{key:"addEndUl",value:function(){return"</ul>\n"}},{key:"addLi",value:function(e,t){return'<li class="item"><a href="#heading-'.concat(t,'" title="').concat(e,'">').concat(e,"</a></li>\n")}},{key:"setHId",value:function(){var e=this;this.CatalogList&&this.CatalogList.map((function(t,s){for(var c=e.getHText(t),n=e.getHLabel(t),a=n.replace("<","").replace(">",""),l=document.getElementsByTagName(a),i=0;i<l.length;i++){var j=l[i];if((null===j||void 0===j?void 0:j.innerHTML)===c){var o="heading-".concat(s);j.setAttribute("id",o)}}}))}}]),e}());t["a"]=new a},"6a7c":function(e,t,s){},"7e5f":function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])('<p>GeoServer是 OpenGIS Web 服务器规范的 J2EE 实现，利用 GeoServer 可以方便的发布地图数据，允许用户对特征数据进行更新、删除、插入操作，通过 GeoServer 可以比较容易的在用户之间迅速共享空间地理信息。它兼容 WMS 和 WFS 特性；支持 PostgreSQL、 Shapefile 、 ArcSDE 、 Oracle 、 VPF 、 MySQL 、 MapInfo ；支持上百种投影；能够将网络地图输出为 jpeg 、 gif 、 png 、 SVG 、 KML 等格式；能够运行在任何基于 J2EE/Servlet 容器之上；嵌入 MapBuilder 支持 AJAX 的地图客户端OpenLayers；除此之外还包括许多其他的特性。</p><p><strong>JAVA环境安装配置</strong></p><ul><li><p>GeoServer需要JAVA环境，所以需要先安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank">JAVA JDK,比如本文下载的是8u152_x64</a>,这里我的安装路径为系统默认的C:\\Program Files\\Java <img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20170831image1.png" alt> 安装之后会存在两个文件包分别是JDK的文件包和JRE的文件包</p></li><li><p>接下来为重要的环境变量配置！！！奉上一个<a href="http://blog.csdn.net/tiantang_1986/article/details/53894947" target="_blank">环境配置链接</a></p></li></ul><p>其中需要设置的环境变量为</p>',4),a=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"JAVA_HOME：C:\\Program Files\\Java\\jre1.8.0_152\nCLASSPATH: .;%JAVA_HOME%\\jdk1.8.0_152\\lib\nPath: %JAVA_HOME%\\jdk1.8.0_152\\bin\n")],-1),l=Object(c["g"])('<ul><li>cmd命令输入java -version如果出现对应版本号，说明配置成功</li></ul><p><strong>GeoServer安装</strong></p><ul><li><p>首先下载，Stable版本的GeoServer无需安装TomCat等服务器，如果想要用TomCat来运行的话，选择下载Web Archive。<a href="http://geoserver.org/download/" target="_blank">GeoServer——Stable</a><img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20170831image2.png" alt></p></li><li><p>安装过程中就按照指令一步步安装就好了，其中需要注意的有：</p></li></ul><p>(1)首先，JRE的路径选择，JRE的路径为上文提到的C:\\Program Files\\Java下的C:\\Program Files\\Java\\jre1.8.0_144 <img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20170831image3.png" alt></p><p>(2)其次，GeoServer运行端口的选择，以及登录名和密码的设置</p><ul><li>以上都完成了之后，Start GeoServer，成功运行之后，浏览器打开http://localhost:7070/geoserver/web/，输入用户名密码之后便可操作</li></ul><p><strong>利用GeoServer发布WMS</strong></p><ul><li>新建工作区 <img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20171130image1.png" alt></li></ul><p>命名工作区 <img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20171130image2.png" alt></p><ul><li>新建数据存储， <img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20171130image3.png" alt></li></ul><p>这里选择的是shp文件 <img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20171130image4.png" alt></p><p>发布该数据 <img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20171130image5.png" alt></p><p>设置投影，并计算经纬度包围盒 <img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20171130image6.png" alt></p><ul><li><p>新建样式，这里选择的是sld文件 <img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20171130image7.png" alt></p></li><li><p>预览图层 <img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20171130image8.png" alt></p></li></ul><p>输入样式名，显示对应样式下的WMS <img src="https://zhangmingemma.github.io/dist/images/2017-08-31/20171130image9.png" alt></p>',15);function i(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n,a,l])}const j={};j.render=i;t["default"]=j},"83f3":function(e,t,s){var c={"./2016-11-20-Cluster Paper Reading.md":"2863","./2016-12-03-Text Categorization Summary.md":"dda5","./2017-03-29-Python NLTK.md":"4ddc","./2017-08-31-Geoserver.md":"7e5f","./2018-10-15-Vue1.md":"bfab","./2018-10-16-Vue2.md":"b61f","./2018-10-17-Vue3.md":"fc13","./2018-10-18-Vue4.md":"b804","./2018-10-25-VueRouter.md":"8bdf","./2019-07-16-Miniprogram Plugin.md":"32d2","./2021-07-03-Blog 1.md":"02cc","./2021-07-04-Blog 2.md":"3209","./2021-07-05-Blog 3.md":"ef22","./2022-06-01-Garbage Collection.md":"df62","./2022-06-15-Vue Code Learning.md":"61c0","./2022-06-16-Vue Data Responsive.md":"30df"};function n(e){var t=a(e);return s(t)}function a(e){if(!s.o(c,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return c[e]}n.keys=function(){return Object.keys(c)},n.resolve=a,e.exports=n,n.id="83f3"},"8bdf":function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["i"])("p",null,"title: Vue (五)：Vue Router实现原理 date: 2018-10-25 tags: JavaScript, Vue",-1),a=Object(c["i"])("p",null,[Object(c["h"])("vue-router是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。这篇文章讲述的主要内容便是vue-router的实现原理，相当于"),Object(c["i"])("a",{href:"https://github.com/vuejs/vue-router"},"vue-router源码"),Object(c["h"])("的粗浅理解。行文主要包括vue-router的使用方法、实现原理两大部分，使用方法的介绍是为了辅助实现原理的陈述。")],-1),l=Object(c["i"])("h3",null,"使用方法",-1),i=Object(c["i"])("ol",null,[Object(c["i"])("li",null,[Object(c["h"])("注册VueRouter插件:"),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" Vue "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'vue'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"import"),Object(c["h"])(" VueRouter "),Object(c["i"])("span",{class:"hljs-keyword"},"from"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'vue-router'"),Object(c["h"])("\nVue.use(VueRouter)\n")])])]),Object(c["i"])("li",null,[Object(c["h"])("定义（路由）组件与路由。"),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" User = { "),Object(c["i"])("span",{class:"hljs-attr"},"template"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'<div>用户</div>'"),Object(c["h"])(" }\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" Role = { "),Object(c["i"])("span",{class:"hljs-attr"},"template"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'<div>角色</div>'"),Object(c["h"])(" }\n"),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" routes = [\n  { "),Object(c["i"])("span",{class:"hljs-attr"},"path"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'/user'"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-attr"},"component"),Object(c["h"])(": User },\n  { "),Object(c["i"])("span",{class:"hljs-attr"},"path"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},"'/home'"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-attr"},"component"),Object(c["h"])(": Home }\n]\n")])])]),Object(c["i"])("li",null,[Object(c["h"])("创建 router 实例，并传 "),Object(c["i"])("code",null,"routes"),Object(c["h"])(" 配置"),Object(c["i"])("code",null,"const router = new VueRouter({routes })")]),Object(c["i"])("li",null,[Object(c["h"])("创建和挂载根实例。"),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" app = "),Object(c["i"])("span",{class:"hljs-keyword"},"new"),Object(c["h"])(" Vue({\n    router,\n    "),Object(c["i"])("span",{class:"hljs-attr"},"template"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-string"},'`\n        <div id="app">\n        <h1>Basic</h1>\n        <ul>\n            <li><router-link to="/">/</router-link></li>\n            <li><router-link to="/user">用户</router-link></li>\n            <li><router-link to="/role">角色</router-link></li>\n            <router-link tag="li" to="/user">/用户</router-link>\n        </ul>\n        <router-view class="view"></router-view>\n        </div>\n    `'),Object(c["h"])("\n}).$mount("),Object(c["i"])("span",{class:"hljs-string"},"'#app'"),Object(c["h"])(")\n")])])])],-1),j=Object(c["g"])('<h3>实现原理</h3><p>每一个工具实现的原理都依赖JS/HTML基本语法，比如Vue的双向数据绑定依赖的是JS的Object.defineProperty。而Vue Router的实现依赖于两种前端路由，即模式history模式和hash模式：</p><ul><li>history模式 <ul><li>HTML5中的两个API：pushState和replaceState，改变url之后页面不会重新刷新，也不会带有#号，页面地址美观，url的改变会触发popState事件，监听该事件也可以实现根据不同的url渲染对应的页面内容</li><li>但是因为没有#会导致用户在刷新页面的时候，还会发送请求到服务端，为避免这种情况，需要每次url改变的时候，都将所有的路由重新定位到跟路由下</li></ul></li><li>hash模式 <ul><li>url hash: http://foo.com/#help</li><li>#后面hash值的改变，并不会重新加载页面，同时hash值的变化会触发hashchange事件，该事件可以监听，可根据不同的哈希值渲染不同的页面内容</li></ul></li></ul><h4>1. 插件注册</h4><p>Vue.use将VueRouter插件注入Vue中，use方法会调用vue-router的<code>install</code>方法，对<strong>VueRouter进行安装</strong>，整个安装过程精简版的源码，全部<a href="https://github.com/vuejs/vue-router/blob/dev/src/install.js">源码地址</a>：</p>',5),o=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["h"])("Vue.mixin({\n  beforeCreate () { ...},\n})\n"),Object(c["i"])("span",{class:"hljs-built_in"},"Object"),Object(c["h"])(".defineProperty(Vue.prototype, "),Object(c["i"])("span",{class:"hljs-string"},"'$router'"),Object(c["h"])(", {\n  "),Object(c["i"])("span",{class:"hljs-keyword"},"get"),Object(c["h"])(" () { "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("._routerRoot._router }\n})\n"),Object(c["i"])("span",{class:"hljs-built_in"},"Object"),Object(c["h"])(".defineProperty(Vue.prototype, "),Object(c["i"])("span",{class:"hljs-string"},"'$route'"),Object(c["h"])(", {\n  "),Object(c["i"])("span",{class:"hljs-keyword"},"get"),Object(c["h"])(" () { "),Object(c["i"])("span",{class:"hljs-keyword"},"return"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("._routerRoot._route }\n})\nVue.component("),Object(c["i"])("span",{class:"hljs-string"},"'RouterView'"),Object(c["h"])(", View)\nVue.component("),Object(c["i"])("span",{class:"hljs-string"},"'RouterLink'"),Object(c["h"])(", Link)\n")])],-1),r=Object(c["g"])('<p>install这个过程主要做了这样的三件事：</p><ul><li>对Vue实例混入beforeCreate/destroyed两个钩子操作，在Vue实例创建生命周期中钩子函数执行前被调用，这个在创建Vue实例部分详细介绍；</li><li>设置Vue.prototype代理，当访问this.$router和this.$route的时候,返回this._routerRoot._router和_route，方便所有组件可以获取到这两个属性</li><li>注册RouterLink和RouterView两个组件 <ul><li>router-view: 获取到匹配的组件，在非keepalive模式下，每次都要设置钩子进而更新匹配了的实例元素</li><li>router-link: 绑定click事件，在其点击的时候根据设置的 to 的值去调用 router 的 push 或者 replace 来更新路由的，同时呢，会检查自身是否和当前路由匹配（严格匹配和包含匹配）来决定自身的 activeClass 是否添加</li></ul></li></ul><h4>2. 创建router实例</h4><p>全部<a href="https://github.com/vuejs/vue-router/blob/dev/src/index.js">源码地址</a>,核心源码：</p>',4),h=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".matcher = createMatcher(options.routes || [], "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(")\n"),Object(c["i"])("span",{class:"hljs-keyword"},"let"),Object(c["h"])(" mode = options.mode || "),Object(c["i"])("span",{class:"hljs-string"},"'hash'"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".fallback = mode === "),Object(c["i"])("span",{class:"hljs-string"},"'history'"),Object(c["h"])(" && !supportsPushState && options.fallback !== "),Object(c["i"])("span",{class:"hljs-literal"},"false"),Object(c["h"])("\n"),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" ("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".fallback) {\n  mode = "),Object(c["i"])("span",{class:"hljs-string"},"'hash'"),Object(c["h"])("\n}\n"),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (!inBrowser) {\n  mode = "),Object(c["i"])("span",{class:"hljs-string"},"'abstract'"),Object(c["h"])("\n}\n"),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".mode = mode\n"),Object(c["i"])("span",{class:"hljs-keyword"},"switch"),Object(c["h"])(" (mode) {\n  "),Object(c["i"])("span",{class:"hljs-keyword"},"case"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'history'"),Object(c["h"])(":\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".history = "),Object(c["i"])("span",{class:"hljs-keyword"},"new"),Object(c["h"])(" HTML5History("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(", options.base)\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"break"),Object(c["h"])("\n  "),Object(c["i"])("span",{class:"hljs-keyword"},"case"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'hash'"),Object(c["h"])(":\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".history = "),Object(c["i"])("span",{class:"hljs-keyword"},"new"),Object(c["h"])(" HashHistory("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(", options.base, "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".fallback)\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"break"),Object(c["h"])("\n  "),Object(c["i"])("span",{class:"hljs-keyword"},"case"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-string"},"'abstract'"),Object(c["h"])(":\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".history = "),Object(c["i"])("span",{class:"hljs-keyword"},"new"),Object(c["h"])(" AbstractHistory("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(", options.base)\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"break"),Object(c["h"])("\n  "),Object(c["i"])("span",{class:"hljs-attr"},"default"),Object(c["h"])(":\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (process.env.NODE_ENV !== "),Object(c["i"])("span",{class:"hljs-string"},"'production'"),Object(c["h"])(") {\n      assert("),Object(c["i"])("span",{class:"hljs-literal"},"false"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-string"},[Object(c["h"])("`invalid mode: "),Object(c["i"])("span",{class:"hljs-subst"},"${mode}"),Object(c["h"])("`")]),Object(c["h"])(")\n    }\n}\ninit(){....}\n")])],-1),b=Object(c["i"])("p",null,"可以看到这个阶段，Vue Router主要做了两件主要的事情：",-1),p=Object(c["i"])("ul",null,[Object(c["i"])("li",null,"创建 match 匹配函数：根据用户路由配置对象生成普通的根据 path 来对应的路由记录以及根据 name 来对应的路由记录的 map，方便后续匹配对应"),Object(c["i"])("li",null,[Object(c["h"])("根据配置的"),Object(c["i"])("code",null,"mode"),Object(c["h"])("创建路由实现的实例： "),Object(c["i"])("ul",null,[Object(c["i"])("li",null,"如果当前环境不支持history模式，会强制切换到hash模式；默认hash模式"),Object(c["i"])("li",null,"如果当前环境不是浏览器环境，会切换到abstract模式下。")])])],-1),O=Object(c["i"])("h4",null,"3. 创建Vue实例",-1),d=Object(c["i"])("p",null,"在这里创建Vue实例，首先会执行install时候混入的钩子函数，这一部分的源码：",-1),u=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["h"])("Vue.mixin({\n  beforeCreate () { \n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (isDef("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".$options.router)) {\n      "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("._routerRoot = "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("\n      "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("._router = "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".$options.router\n      "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("._router.init("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(")\n      Vue.util.defineReactive("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-string"},"'_route'"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("._router.history.current)      "),Object(c["i"])("span",{class:"hljs-comment"},"//为vue实例定义数据劫持"),Object(c["h"])("\n    } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(" {\n\n      "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("._routerRoot = ("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".$parent && "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".$parent._routerRoot) || "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])("      "),Object(c["i"])("span",{class:"hljs-comment"},"//非跟组件则直接从父组件中取"),Object(c["h"])("\n    }\n    registerInstance("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(", "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(")\n  },\n  destroyed () {\n    registerInstance("),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(")\n  }\n})\n")])],-1),m=Object(c["i"])("p",null,"这一部分，主要做了两件事情",-1),g=Object(c["i"])("ul",null,[Object(c["i"])("li",null,"对_router赋值，此时this.$options.router包含着传入的路由参数"),Object(c["i"])("li",null,"执行创建vue router实例中的init方法，根据不同模式生成监控路由变化的History对象")],-1),f=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["h"])("init (app: any "),Object(c["i"])("span",{class:"hljs-comment"},"/* Vue component instance */"),Object(c["h"])(") {\n    ...\n    const history = "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".history\n    "),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (history "),Object(c["i"])("span",{class:"hljs-keyword"},"instanceof"),Object(c["h"])(" HTML5History) {\n      history.transitionTo(history.getCurrentLocation())\n    } "),Object(c["i"])("span",{class:"hljs-keyword"},"else"),Object(c["h"])(),Object(c["i"])("span",{class:"hljs-keyword"},"if"),Object(c["h"])(" (history "),Object(c["i"])("span",{class:"hljs-keyword"},"instanceof"),Object(c["h"])(" HashHistory) {\n      "),Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" setupHashListener = "),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"()"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n        history.setupListeners()\n      }\n      history.transitionTo(\n        history.getCurrentLocation(),\n        setupHashListener,\n        setupHashListener\n      )\n    }\n    history.listen("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["i"])("span",{class:"hljs-params"},"route"),Object(c["h"])(" =>")]),Object(c["h"])(" {\n      "),Object(c["i"])("span",{class:"hljs-keyword"},"this"),Object(c["h"])(".apps.forEach("),Object(c["i"])("span",{class:"hljs-function"},[Object(c["h"])("("),Object(c["i"])("span",{class:"hljs-params"},"app"),Object(c["h"])(") =>")]),Object(c["h"])(" {\n        app._route = route\n      })\n    })\n}\n")])],-1),v=Object(c["g"])('<p>这一部分，主要做了两件事情：</p><ul><li>通过history的模式来确定不同路由的切换动作<code>history.transitionTo</code>，更新浏览器地址 <ul><li>对于hash模式，更新hash的值</li><li>对于history模式，利用pushState/replaceState更新浏览器地址</li><li>对于Abstract模式下，所做的仅仅是用一个数组当做栈来模拟浏览器历史记录，拿一个变量来标示当前处于哪个位置。</li></ul></li><li>通过<code>history.listen</code>来注册路由变化的响应回调</li></ul><p>一旦this._router.history.curren，即history实例当前的路由对象有变化，就会触发更新机制，继而调用应用实例的 render 重新渲染</p><ul><li>hash模式的更新机制：触发onHashChange的事件，调用transitionTo</li><li>history模式的更新机制：触发popState的事件，调用transitionTo</li></ul><p><strong>为什么不直接在初始化 HashHistory 的时候监听 hashchange 事件呢？</strong></p><p>这个是为了修复https://github.com/vuejs/vue-router/issues/725 这个 bug 而这样做的，简要来说就是说如果在 beforeEnter 这样的钩子函数中是异步的话，beforeEnter 钩子就会被触发两次，原因是因为在初始化的时候如果此时的 hash 值不是以 / 开头的话就会补上 #/，这个过程会触发 hashchange 事件，所以会再走一次生命周期钩子，也就意味着会再次调用 beforeEnter 钩子函数。</p><p>自此整个vue-router的实现原理就解释完啦~~</p><p>参考文献：</p><ol><li><a href="https://blog.csdn.net/u013938465/article/details/79421239">深入Vue-Router源码分析路由实现原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/24574970">vue-router 源码分析-history</a></li></ol>',9);function y(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n,a,l,i,j,o,r,h,b,p,O,d,u,m,g,f,v])}const w={};w.render=y;t["default"]=w},a7bb:function(e,t,s){"use strict";s.d(t,"a",(function(){return n})),s.d(t,"b",(function(){return a})),s.d(t,"e",(function(){return l})),s.d(t,"f",(function(){return i})),s.d(t,"d",(function(){return j})),s.d(t,"c",(function(){return o}));s("4de4");var c=s("a1e9"),n={ClientID:"f2fc4c018508a76889b4",ClientSecret:"c61f4feab775f95de8af0e4e215e1a5b2b54707c",Repo:"zhangmingemma.github.io",Owner:"zhangmingemma"},a={PageSie:5},l=function(e){var t=Object(c["k"])(null);return e.then((function(e){t.value=e})),{res:t}},i=function(){setTimeout((function(){window.scrollTo({top:0,behavior:"smooth"})}))},j=function(e,t){return e instanceof Array&&t instanceof Array&&e.filter((function(e){return t.indexOf(e)>=0}))||[]},o=function(){return"./dist/posts"}},b419:function(e,t,s){"use strict";s("6a7c")},b601:function(e,t,s){},b61f:function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])('<p>title: Vue (二)：视图更新原理 date: 2018-10-16 tags: JavaScript, Vue</p><p>我们都知道Vue存在双向绑定机制，数据更新之后会触发Observer的set方法，进一步触发Watcher，进行视图的更新操作。那么视图的更新是否是对真实DOM进行更新操作的呢？视图更新过程中又有什么Vue独特的性能优化方案呢？实际上，Vue2.0加入了Virtual DOM，在页面更新渲染时，Vue会先依据更新后的数据渲染生成虚拟DOM，在虚拟DOM和更新前的虚拟DOM进行对比运算，得到所有需要在DOM上进行的变更，然后在 patch 过程中应用到真实DOM上实现视图的同步更新。本节讲述的主要内容便是虚拟DOM，DOM的diff算法以及DOM的patch算法。本系列其他文章：</p><ul><li><a href="https://zhangmingemma.github.io/#/post?file=2018-10-16-Vue1">Vue (一)：响应式原理</a></li><li><a href="https://zhangmingemma.github.io/#/post?file=2018-10-16-Vue3">Vue (三)：数据驱动原理</a></li><li><a href="https://zhangmingemma.github.io/#/post?file=2018-10-17-Vue4">Vue (四)：组件化原理</a></li><li><a href="https://zhangmingemma.github.io/#/post?file=2018-10-17-VueRouter">Vue (五)：Vue Router原理</a></li></ul><h2>一. 虚拟DOM</h2><p><strong>首先，虚拟DOM是什么？</strong></p><p>真实的DOM可以通过<code>document.CreateElement</code> 和 <code>document.CreateTextNode</code>创建；虚拟DOM是一个纯粹的JS对象，可以通过<code>document.createDocumentFragment</code> 创建，Vue中一个虚拟DOM包含以下属性：</p>',6),a=Object(c["g"])('<li>tag: 当前节点的标签名</li><li>data: 当前节点的数据对象</li><li>children: 数组类型，包含了当前节点的子节点</li><li>text: 当前节点的文本，一般文本节点或注释节点会有该属性</li><li><p style="color:red;">elm: 当前虚拟节点对应的真实的dom节点</p></li><li>context: 编译作用域</li><li>functionalContext: 函数化组件的作用域</li><li><p style="color:blue;">key: 节点的key属性，用于作为节点的标识，有利于patch的优化</p></li><li><p style="color:blue;">sel: 节点的选择器</p></li><li>componentOptions: 创建组件实例时会用到的选项信息</li><li>child: 当前节点对应的组件实例</li><li>parent: 组件的占位节点</li><li>raw: raw html</li><li>isStatic: 静态节点的标识，静态节点未绑定动态数据，在数据更新时不需要对比节点</li>',14),l=Object(c["h"])("isRootInsert: 是否作为根节点插入，被"),i=Object(c["h"])("包裹的节点，该属性的值为false"),j=Object(c["i"])("li",null,"isComment: 当前节点是否是注释节点",-1),o=Object(c["i"])("li",null,"isCloned: 当前节点是否为克隆节点",-1),r=Object(c["i"])("li",null,"isOnce: 当前节点是否有v-once指令",-1),h=Object(c["i"])("p",null,[Object(c["i"])("strong",null,"为什么要使用虚拟DOM？")],-1),b=Object(c["i"])("p",null,"虚拟DOM因为是纯粹的JS对象，所以操作它会很高效。虽然很多时候手工优化dom确实会比virtual dom效率高，对于比较简单的dom结构用手工优化没有问题，但当页面结构很庞大，结构很复杂时，手工优化会花去大量时间，而且可维护性也不高，不能保证每个人都有手工优化的能力。至此，virtual dom的解决方案应运而生，virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。",-1),p=Object(c["i"])("p",null,"virtual dom 另一个重大意义就是提供一个中间层，js去写ui，ios安卓之类的负责渲染，就像reactNative一样。",-1),O=Object(c["i"])("h2",null,"二. patch过程",-1),d=Object(c["i"])("p",null,"Vue在对同级虚拟DOM和真实DOM进行对比执行，当新旧虚拟节点的key和sel都相同时，则进行节点的深度diff，若不相同则整个替换虚拟节点，同时创建真实DOM，实现视图更新。",-1),u=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"function patch (oldVnode, vnode) {\n    if (sameVnode(oldVnode, vnode)) { // 有必要进行patch, key和sel都相同时才进行patch\n        patchVnode(oldVnode, vnode)\n    } else {  // 没有必要进行patch, 整个替换\n        const oEl = oldVnode.el\n        let parentEle = api.parentNode(oEl)\n        createEle(vnode) // vnode创建它的真实dom，令vnode.el =真实dom\n        if (parentEle !== null) {\n            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 插入整个新节点树\n            api.removeChild(parentEle, oldVnode.el) // 移出整个旧的虚拟DOM\n            oldVnode = null\n        }\n    }\n    return vnode\n}\n")],-1),m=Object(c["i"])("p",null,"那么节点的深度patch过程如何呢？源码如下，分为注释中的四个情况来分别讨论patch过程：",-1),g=Object(c["i"])("ul",null,[Object(c["i"])("li",null,"文本节点，无子节点，直接更新文本即可，无需patch"),Object(c["i"])("li",null,"两个节点都有子节点且不一样，则调用updateChildren函数比较子节点，是diff的核心"),Object(c["i"])("li",null,"只有新节点有子节点，调用createEle(vnode)"),Object(c["i"])("li",null,"新节点没有子节点，老节点有子节点，直接删除老节点。")],-1),f=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"function patchVnode (oldVnode, vnode) {\n    const el = vnode.el = oldVnode.el  // vnode.el引用到现在的真实dom; 当el修改时，vnode.el会同步变化。\n    let i, oldCh = oldVnode.children, ch = vnode.children\n    if (oldVnode === vnode) return //可以认为没有变化\n    if (oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text) { //1. 文本内容不同，则只进行文本替换\n        api.setTextContent(el, vnode.text)\n    }else {  \n        updateEle(el, vnode, oldVnode)\n        if (oldCh && ch && oldCh !== ch) { // 2. 两个节点都有子节点且不一样，则调用updateChildren函数比较子节点，是diff的核心\n            updateChildren(el, oldCh, ch)\n        }else if (ch){\n            createEle(vnode) // 3. 只有新节点有子节点，调用createEle(vnode)，在老dom节点上添加子节点\n        }else if (oldCh){\n            api.removeChildren(el) // 4. 新节点没有子节点，老节点有子节点，直接删除老节点。\n        }\n    }\n}\n")],-1),v=Object(c["i"])("h2",null,"三. diff算法",-1),y=Object(c["i"])("p",null,"接下来就是最复杂的diff算法的理解了，diff算法用于比较新旧虚拟节点树，是视图更新渲染的关键。下面是一张很经典的图，出自《React’s diff algorithm》，Vue的diff算法也同样，即仅在同级的vnode间做diff，递归地进行同级vnode的diff，最终实现整个DOM树的更新。需要注意的是，在新旧虚拟DOM树对比的过程中，是以对比结果直接对真实的DOM树进行修改，而不是只修改虚拟节点树。",-1),w=Object(c["i"])("img",{style:{width:"400px"},class:"center",src:"https://zhangmingemma.github.io/dist/images/2018-10-16/vue-diff1.png"},null,-1),k=Object(c["i"])("h3",null,"1. diff的简易源码",-1),x=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"updateChildren (parentElm, oldCh, newCh) {\n    let oldStartIdx = 0, newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx\n    let idxInOld\n    let elmToMove\n    let before\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {   //对于vnode.key的比较，会把oldVnode = null\n            oldStartVnode = oldCh[++oldStartIdx] \n        }else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx]\n        }else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx]\n        }else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx]\n        }else if (sameVnode(oldStartVnode, newStartVnode)) {\n            patchVnode(oldStartVnode, newStartVnode)\n            oldStartVnode = oldCh[++oldStartIdx]\n            newStartVnode = newCh[++newStartIdx]\n        }else if (sameVnode(oldEndVnode, newEndVnode)) {\n            patchVnode(oldEndVnode, newEndVnode)\n            oldEndVnode = oldCh[--oldEndIdx]\n            newEndVnode = newCh[--newEndIdx]\n        }else if (sameVnode(oldStartVnode, newEndVnode)) {\n            patchVnode(oldStartVnode, newEndVnode)\n            api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))\n            oldStartVnode = oldCh[++oldStartIdx]\n            newEndVnode = newCh[--newEndIdx]\n        }else if (sameVnode(oldEndVnode, newStartVnode)) {\n            patchVnode(oldEndVnode, newStartVnode)\n            api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)\n            oldEndVnode = oldCh[--oldEndIdx]\n            newStartVnode = newCh[++newStartIdx]\n        }else {\n            // 使用key时的比较\n            if (oldKeyToIdx === undefined) {\n                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表\n            }\n            idxInOld = oldKeyToIdx[newStartVnode.key]\n            if (!idxInOld) {\n                api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\n                newStartVnode = newCh[++newStartIdx]\n            }\n            else {\n                elmToMove = oldCh[idxInOld]\n                if (elmToMove.sel !== newStartVnode.sel) {\n                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\n                }else {\n                    patchVnode(elmToMove, newStartVnode)\n                    oldCh[idxInOld] = null\n                    api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)\n                }\n                newStartVnode = newCh[++newStartIdx]\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el\n        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)\n    }else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n}\n")],-1),V=Object(c["g"])('<h3>2. 过程概述</h3><p><img style="width:200px;display:inline-block;" class="center" src="https://zhangmingemma.\ngithub.io/dist/images/2018-10-16/vue-diff2.png"></p><p>过程比较复杂，概括可以理解为：首先设置新旧虚拟DOM节点的孩子树<code>newCh</code>、<code>oldCh</code>的起始<code>StartIdx</code>、结尾索引<code>EndIdx</code>。它们的2个变量相互比较，一共有4种比较方式。举例说明，下面是一个对比前后的DOM树，</p><img style="width:400px;display:inline-block;" class="center" src="https://zhangmingemma.github.io/dist/images/2018-10-16/vue-diff3.png"><p>(1). 当新旧起始节点为<code>null</code>时，则将起始索引<code>++</code>,并更新起始节点；同样的，当新旧结尾节点为<code>null</code>时，则将结尾索引<code>--</code>，并更新结尾节点 (2). 当新旧起始节点相同时（即key和sel都相同），则<code>patchVnode</code>进行patch，同时将新旧起始索引<code>++</code>；同样的，当新旧结尾节点相同时（即key和sel都相同），则<code>patchVnode</code>进行patch，同时将新旧结尾索引<code>--</code>，对于真实DOM而言，就是节点保留原地</p><img style="width:400px;" class="center" src="https://zhangmingemma.github.io/dist/images/2018-10-16/vue-diff4.png"><img style="width:300px;" class="center" src="https://zhangmingemma.github.io/dist/images/2018-10-16/vue-diff5.png"><p>(3). 当旧起始节点和新结尾节点相同时，<code>patchVnode</code>进行patch，将oldStartNode.elm移动到旧结尾节点oldEndNode.elm之后，旧起始索引<code>++</code>新结尾索引<code>--</code>；同理，当新起始节点和旧结尾节点相同时，<code>patchVnode</code>进行patch，将旧结尾节点oldEndNode.elm移动到旧起始节点oldStartNode.elm之后，旧结尾索引<code>--</code>新起始索引<code>++</code>;<br></p><img style="width:400px;" class="center" src="https://zhangmingemma.github.io/dist/images/2018-10-16/vue-diff6.png"><img style="width:400px;" class="center" src="https://zhangmingemma.github.io/dist/images/2018-10-16/vue-diff7.png"><p>(4) 以上情况都不是的时候，使用key进行比较，从用旧虚拟节点树key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</p><ul><li>若新起始节点的key不在oldKeyToIdx中，在旧起始节点位置上插入新起始节点，同时新起始索引<code>++</code></li><li>若新起始节点的key在oldKeyToIdx中，且key相同的两个虚拟节点sel相同，则<code>patchVnode</code>进行patch，把key相同的旧虚拟节点的elm移动到oldStartVnode.elm之前，新起始索引<code>++</code></li><li>若新起始节点的key在oldKeyToIdx中，且key相同的两个虚拟节点sel不同，则在把新起始节点的elm插入到oldStartVnode.elm之前，新起始索引<code>++</code></li></ul><p>(6) 在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较。结束时存在两种具体的情况：</p><ul><li><p><code>oldStartIdx &gt; oldEndIdx</code>，可以认为oldCh先遍历完。当然也有可能newCh此时也正好完成了遍历，统一都归为此类。此时newStartIdx和newEndIdx之间的vnode是新增的，调用addVnodes，把这些虚拟node.elm全部插进before的后边.</p></li><li><p><code>newStartIdx &gt; newEndIdx</code>，可以认为newCh先遍历完。此时oldStartIdx和oldEndIdx之间的vnode在新的子节点里已经不存在了，调用removeVnodes将这些虚拟node.elm从dom里删除。</p></li></ul><img style="width:400px;" class="center" src="https://zhangmingemma.github.io/dist/images/2018-10-16/vue-diff8.png"><p>自此，整个视图更新渲染过程中，Vue所做的事情就已经介绍完啦~~~</p><p>参考文献：</p><ol><li><a href="https://blog.csdn.net/m6i37jk/article/details/78140159">深入Vue2.x的虚拟DOM diff原理</a></li><li><a href="https://segmentfault.com/a/1190000008782928">解析vue2.0的diff算法</a></li><li><a href="https://segmentfault.com/a/1190000008291645">Vue原理解析之Virtual Dom</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjQ1NjMwNw==&amp;mid=2247484449&amp;idx=1&amp;sn=7f346b97a177218cc09fc50562ed121c&amp;chksm=f9a66e3dced1e72b8a88fd0d78b5a5b8bd2e0ec95552e675d44923d368bba2ec438c520cd7be&amp;cur_album_id=1619085427984957440&amp;scene=189#rd">【Vue原理】Diff - 源码版 之 Diff 流程</a></li></ol>',18);function C(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n,Object(c["i"])("ul",null,[a,Object(c["i"])("li",null,[l,Object(c["i"])(c["b"],null,{default:Object(c["E"])((function(){return[i]})),_:1})]),j,o,r]),h,b,p,O,d,u,m,g,f,v,y,w,k,x,V])}const S={};S.render=C;t["default"]=S},b804:function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])('<h2>组件式开发</h2><p>讲完数据双向绑定，可以再来理解一下Vue的组件式开发的概念:</p><blockquote><p>Vue允许小型、独立、可重复使用的组件构建大型应用，几乎任意类型的应用界面都可以抽象成一个组件树。Vue将组建抽象成一个高度封装过的函数，我们只需要在其中定义必要的属性，比如说父组件传入数据的prop，页面模板，交互逻辑之类的，就可以将一部分功能逻辑封装为一个可重复利用，独立的组件。</p></blockquote><p><strong>那么Vue提供的组件封装和我们自己用原生JS封装组件之间有什么样的优势呢？</strong></p><p>Vue的组件封装：<br><img style="height:160px;" src="https://zhangmingemma.github.io/dist/images/2018-10-15/vue-component1.png"><img style="height:160px;" src="https://zhangmingemma.github.io/dist/images/2018-10-15/vue-component2.png"></p><p>JS原生组件封装：<br><img style="width:400px;" src="https://zhangmingemma.github.io/dist/images/2018-10-15/vue-component3.png"></p><p>二者相比之下，Vue组件的优势就很明显了：<br></p><ul><li>**可读性：**我们可以看到原生语言封装的组件，页面模板的定义、DOM交互、数据请求都混杂在一起，可读性较差，而Vue的组件封装中页面模板、交互逻辑、CSS样式和我们单独写页面是很类似的，可读性较强;<br></li><li>**可扩展性：**Vue的组件能够轻松的在页面模板或者交互逻辑中扩展新的功能，而原生语言封装的组件在扩展过程中则需要考虑会不会牵动其他的组件逻辑，以及对已有逻辑的更改，可扩展性较差；<br></li><li>**可维护性：**Vue注册一个组件之后，组件的更新和渲染都是独立的，因此当我们对其中一个组件进行更改的时候，其他组件不会受到影响</li></ul><h2>生命周期</h2><p>Vue的生命周期是指Vue从创建实例到实例销毁所经历的一系列过程，可以看到在vue一整个的生命周期中会有很多钩子函数提供给我们在vue生命周期不同的时刻进行操作, 我们一一详解:</p><table><thead><tr><th>钩子</th><th>状况</th><th>可进行的操作</th></tr></thead><tbody><tr><td>beforecreate</td><td>只是一个空壳，无法访问到数据和真实的dom</td><td>添加loading</td></tr><tr><td>created</td><td>实的DOM无法访问，已经可以访问数据，也可以更改数据，此时更改数据不会触发updated函数，不会触发其他的钩子函数</td><td>获取初始数据、结束loading</td></tr><tr><td>beforemount</td><td>虚拟dom已经创建完成，还无法访问真实的DOM,此时更改数据也不会触发updated，不会触发其他的钩子函数，是渲染前最后一次更改数据的机会</td><td>初始数据的获取</td></tr><tr><td>mounted</td><td>组件已经出现在页面中，数据、真实dom、事件都挂载好了</td><td>操作真实dom</td></tr><tr><td>beforeupdate</td><td>当组件或实例的数据更改之后，会立即执行beforeUpdate，因此这个时候数据已经更新，vue的虚拟dom机制会重新构建虚拟dom与上一次的虚拟dom树利用diff算法进行对比之后重新渲染</td><td>不做什么</td></tr><tr><td>updated</td><td>数据已经更改完成，dom也重新render完成</td><td>操作更新后的真实dom</td></tr><tr><td>beforedestroy</td><td>调用$destroy方法后，立即执行beforeDestroy</td><td>清除计时器、清除非指令绑定的事件等善后</td></tr><tr><td>destroyed</td><td>Observer、Watcher都已经解绑，事件监听器都被移除，子实例也都会被销毁，修改数据得不到响应了，但原生DOM还存在</td><td>不做什么</td></tr></tbody></table><p>备注：</p><ul><li>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 <strong>vm.$nextTick</strong> 替换掉 mounted</li><li><strong>Vue 异步执行 DOM 更新</strong>。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。</li></ul><h2>小知识点</h2><h3>v-if和v-show</h3><ul><li>v-show中，元素是一直存在的，当v-show为false时，元素display:none只是隐藏了而已。</li><li>v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。</li></ul><p>so，一般的，v-if有更高的切换消耗，而v-show有更多的初始化渲染消耗。 so，如果需要频繁的切换而对安全性无要求，使用v-show。如果在运行时，条件不可能改变，则使用v-if较好。</p><h3>vuex</h3><p>vuex是一种状态管理模式，就是将所有的组件共享的状态集中进行管理，在数据更新之后就会统一的改变各个组件的状态。里面有一些关键的模块，</p><ul><li>state是用来存放共享的数据的，</li><li>getters用来过滤数据，避免对庞大的数据中每一部分都要提交或者更新，</li><li>mutation定义修改数据的逻辑，</li><li>action用来提交修改，最终实现数据的统一更新</li></ul><h3>Vue 与 React的区别</h3><p>React 和 Vue 有许多相似之处，它们都有：</p><ul><li>使用 Virtual DOM</li><li>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</li><li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li></ul><p>React 和 Vue 之间的区别：</p><ul><li>在 React应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上述的子树问题限制。</li><li>在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写JavaScript 的一种语法糖。Vue 也提供了渲染函数，甚至支持 JSX。然而，我们默认推荐的还是HTML模板。</li><li>Vue 提供了 Vue-cli 脚手架，能让你非常容易地构建项目，包含了 Webpack，Browserify，甚至 no build system。React 在这方面也提供了 create-react-app，但是现在还存在一些局限性：它不允许在项目生成时进行任何配置，而 Vue 支持 Yeoman-like 定制。它只提供一个构建单页面应用的单一模板，而 Vue 提供了各种用途的模板。它不能用用户自建的模板构建项目，而自建模板对企业环境下预先建立协议是特别有用的。</li><li>Vue 和 React 都提供了强大的路由来应对大型应用。Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。</li></ul>',25);function a(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n])}const l={};l.render=a;t["default"]=l},b81d:function(e,t,s){"use strict";var c=s("53ca"),n=s("5530"),a=s("1da1"),l=s("d4ec"),i=s("bee2"),j=(s("18a5"),s("99af"),s("d81d"),s("ac1f"),s("1276"),s("498a"),s("b0c0"),s("5319"),s("a15b"),s("466d"),s("fb6a"),s("96cf"),s("a1e9")),o=s("5c40"),r=s("bc3a"),h=s.n(r),b=s("62b5"),p=s("a7bb"),O=s("1487"),d=s.n(O),u=s("0e54"),m=s("589c");u.setOptions({renderer:new u.Renderer,gfm:!0,tables:!0,breaks:!0,pedantic:!1,smartLists:!0,smartypants:!0,highlight:function(e){return d.a.highlightAuto(e).value}});var g=function(){function e(){Object(l["a"])(this,e),this.Post={}}return Object(i["a"])(e,[{key:"postCompiler",value:function(e){var t=Object(j["k"])(""),s=Object(j["k"])(""),c=Object(j["j"])({catalogOffset:null,post:{}}),l=Object(p["e"])(this.getPostInfo(e)),i=l.res;return Object(o["P"])(Object(a["a"])(regeneratorRuntime.mark((function e(){return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:if(!i.value||!i.value.content){e.next=10;break}return c.post=i.value,t.value=u(i.value.content),e.next=5,Object(o["s"])();case 5:return s.value=b["a"].getCatalogHtml(),b["a"].setHId(),e.next=9,Object(o["s"])();case 9:c.catalogOffset=b["a"].getCatalogOffset(!0);case 10:case"end":return e.stop()}}),e)})))),window.onresize=function(){c.catalogOffset=b["a"].getCatalogOffset(!0)},Object(n["a"])(Object(n["a"])({postHtml:t,catalogHtml:s},Object(j["r"])(c)),{},{anchor:b["a"].anchor})}},{key:"getPostInfo",value:function(){var e=Object(a["a"])(regeneratorRuntime.mark((function e(t){var s,c,n,a;return regeneratorRuntime.wrap((function(e){while(1)switch(e.prev=e.next){case 0:if(t){e.next=2;break}return e.abrupt("return",{});case 2:return e.next=4,h.a.get("".concat(Object(p["c"])(),"/").concat(t,".md"));case 4:return s=e.sent,c=s.data,n={},c&&(n["content"]=c,n["abstract"]=this.getPostAbstract(c),n["name"]=this.getPostName(t),a=this.matchPostBase(c),a&&a.length>=4&&(n["title"]=a[1],n["date"]=a[2],n["tags"]=a[3].split(",").map((function(e){return e.trim()})))),e.abrupt("return",n);case 9:case"end":return e.stop()}}),e,this)})));function t(t){return e.apply(this,arguments)}return t}()},{key:"getPostName",value:function(e){if(e){var t=e.split("/");if(t&&t.length){var s=t.pop();if(s)return s.replace(/\.\w+$/,"")}}return""}},{key:"matchPostBase",value:function(e){var t=e.split("\n").map((function(e){return e.trim()})).join("");return t.match(/-+title: (.*?)date: (.*?)tags: (.*?)-+/)}},{key:"getPostAbstract",value:function(e){var t=e.match(/--- -->(\s+(.*))+/);if(t&&t.length>=1){var s=null===t||void 0===t?void 0:t[0].replace("--- --\x3e",""),c=m.parse(s.trim()),n=this.parseMarkAst(c).slice(0,500);return n+"..."}return""}},{key:"parseMarkAst",value:function(e){var t=this,s="";return e&&e.length&&e.map((function(e){var n;["paragraph","heading","strong","em"].indexOf(null===e||void 0===e?void 0:e.type)>=0&&e.text&&e.text.length&&e.text.map((function(e){if("string"===typeof e)s+=t.getAstText(e);else if("object"===Object(c["a"])(e)){var n,a=null===e||void 0===e||null===(n=e.text)||void 0===n?void 0:n[0];a&&"string"===typeof a&&(s+=a.replaceAll("\n","").trim())}})),"list"===(null===e||void 0===e?void 0:e.type)&&null!==e&&void 0!==e&&null!==(n=e.body)&&void 0!==n&&n.length&&e.body.map((function(c){"listitem"===c.type&&(s+=t.parseMarkAst(e))}))})),s}},{key:"getAstText",value:function(e){var t=e.replaceAll("\n","").trim(),s=t.replace(/<[^>]+>/g," ");return s}}]),e}();t["a"]=new g},bfab:function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])('<p>title: Vue (一)：响应式原理 date: 2018-10-15 tags: Vue</p><p>Vue拥有极易上手的开发框架和模板语法模板，目前已经成为主流前端开发框架，使用范围极广。我想在这个系列的文章，谈论一下我对Vue的基本理解，包含其涉及到的理论概念、基本原理。这篇文章主要谈论一下Vue涉及的基本理论概念及响应式原理，本系列其他文章：</p><ul><li><a href="https://zhangmingemma.github.io/#/post?file=2018-10-16-Vue2">Vue (二)：视图更新原理</a></li><li><a href="https://zhangmingemma.github.io/#/post?file=2018-10-16-Vue3">Vue (三)：数据驱动原理</a></li><li><a href="https://zhangmingemma.github.io/#/post?file=2018-10-17-Vue4">Vue (四)：组件化原理</a></li><li><a href="https://zhangmingemma.github.io/#/post?file=2018-10-17-VueRouter">Vue (五)：Vue Router原理</a></li></ul><h2>一. 概念</h2><blockquote><p>Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。</p></blockquote><p>Vue的概念中提到一个主要的关键概念叫渐进式框架，那什么是<strong>渐进式框架</strong>呢？</p><p>渐进式框架是指没有强主张，对框架的使用没有强约束关系，可以将Vue当做Jquey只使用他的页面模板，也可以只使用其数据绑定和组件式开发特性，完全不care vuex,vue-router这样的周边工具，也可以使用vue全家桶搭建复杂的单页应用，这种模式便是渐进式开发框架。</p><h2>二. 双向绑定</h2><p>双向绑定是指视图变化的时候能够响应到数据属性的更新，而数据属性的更新也能够快速响应到视图的变化。这里附上我自己根据Vue源码编写的<a href="https://github.com/zhangmingemma/framework-source-exercise/tree/master/bilateral-bind">简易版数据双向绑定实现代码</a></p><h3>1. 实现</h3><p>数据双向绑定的实现主要依赖与三个功能模块：</p><ul><li>观察者Observer: <code>Object.defineProperty</code>观察监听数据的变化</li><li>订阅者Watcher: 将创建的实例中的data添加为Watcher实例，当数值更新变化的时候，更新视图中的数据值</li><li>指令解析器Compiler: 解析DOM中的指令模板，为事件模板，绑定监听事件，为数据模板，添加awatcher实例，视图中数据值变化时更新数据值</li></ul><p>整个双向绑定实现的过程是从Vue实例创建时开始的，具体过程：</p><h4>(1) 创建Vue实例</h4><p>这个时候的代码如下，主要做了两件事情</p>',15),a=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"function MVVM(options){\n    this.data = options.data;\n    var data = this.data,me = this;\n    Object.keys(data).forEach(function(key){\n        me._proxy(key);\n    })\n    observe(data); //将数据属性添加到Observer中\n    this.$compile = new Compile(options.el || document.body,this); //解析页面模板\n}\n")],-1),l=Object(c["i"])("h4",null,"(2) Observer监听data变化",-1),i=Object(c["i"])("p",null,"将data中定义的键值通过Object.defineProperty的get和set方法观察监听数据的变化；触发get方法的时候，收集依赖，存入subs数组；数据变化时，subs依赖中逐个通知Watcher更新视图中的数据值",-1),j=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"function observe(data){\n    Object.keys(data).forEach(function(key){\n        defineReactive(data,key,data[key]); //为每一个数据项绑定数据值监听\n    })\n}\nfunction defineReactive(data,key,val){\n    var dep  = new Dep();\n    observe(val); //递归监听数据元素中的所有子元素\n    Object.defineProperty(data, key, {\n        get:function(){  //获取值时触发get方法，依赖收集\n            Dep.target && dep.addSub(Dep.target); // 添加watcher\n            return val;\n        },\n        set:function(newval){  //更改值时触发set方法，依赖更新\n            if (newval === val) {\n                return;\n            }\n            val = newval;\n            dep.notify();//通知Watcher\n        }\n    })\n}\nfunction Dep(){\n    this.subs = [];\n}\nDep.prototype = {\n    addSub: function(sub){\n        this.subs.push(sub);\n    },\n    notify: function(){\n        this.subs.forEach(function(sub){\n            sub.update();\n        })\n    }\n}\nDep.target = null\nWatcher.prototype = {\n    get: function(){\n        Dep.target = this; // 指向不停的watcher，页面渲染时指向页面watcher\n        var value = this.vm.data[this.exp];\n        Dep.target = null;\n        return value;\n    },\n    update:function(){\n        var value = this.get(),\n            oldValue = this.value;\n        if(value != oldValue){\n            this.value = value;\n            this.cb.call(this.vm,value,oldValue);\n        }\n    }\n}\n")],-1),o=Object(c["i"])("h4",null,"(3) Compiler解析模板指令",-1),r=Object(c["i"])("p",null,"将实例中包含的页面元素逐一解析，按节点类型，为绑定事件的元素添加事件监听，将绑定v-model的添加input事件监听，为绑定的数据注册Watcher实例，监听变化",-1),h=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"function compile(el,vm){\n    this.vm = vm; //vm是整个MVVM实例，即MVVM.js中的options,data都包含\n    this.$el = document.querySelector(el); //el是真实的DOM节点\n    this.$fragment = this.node2Fragment(this.$el); //创建虚拟DOM节点\n    this.compileElement(this.$fragment); //解析页面模板\n    this.$el.appendChild(this.$fragment);\n}\nfunction compileElement(el){\n    var childNodes = el.childNodes,\n        me = this;\n    [].slice.call(childNodes).forEach(function(node){\n        var reg = /\\{\\{(.*)\\}\\}/; //正则表达式匹配页面模板\n        var text = node.textContent;\n        if(node.nodeType == 1){// 元素节点\n            me.compile(node); //解析“v-”绑定的数据节点，如果绑定v-model，则注册时间监听页面视图变化\n        }else if(node.nodeType == 3 && reg.test(text)){ // 文本节点\n            me.compiletext(node,RegExp.$1); //解析“{{}}”绑定的数据节点\n        }\n        if (node.childNodes && node.childNodes.length) {\n            me.compileElement(node); //递归解析所有子节点\n        }\n    })\n}\nfunction compiletext(node,exp){  //为{{}}绑定的数据属性添加Watcher\n    var me = this,\n        initText = this.vm[exp];\n    this.updatetext(node,initText);\n    new Watcher(this.vm,exp,function(val){\n        me.updatetext(node,val);\n    })\n} \nfunction modelHandler(node,vm,exp,dir){ //为v-model绑定的数据属性添加Watcher\n    var me = this,\n        val = this.vm[exp];\n    this.modelUpdater(node,val);\n    new Watcher(me.vm,exp,function(value){\n        me.modelUpdater(node,value);\n    });\n    node.addEventListener('input',function(e){ //为v-model绑定注册监听事件\n        var newValue = e.target.value;\n        if(val === newValue){return;}\n        me.vm[exp] = newValue;\n        val = newValue;\n    })\n}\n")],-1),b=Object(c["g"])('<ul><li>数据变化 -----&gt; 视图变化 <ul><li>当数据变化的时候，会触发观察者的set方法，从而触发发生变化的数据属性对应的Watcher，</li><li>Watcher会将视图中某一节点node.value替换为新的值</li></ul></li><li>视图变化 -----&gt; 数据变化 <ul><li>当在输入框输入文字的时候，触发input的监听事件</li><li>将input的node的值赋给绑定订阅者列表中绑定的键值，从而更新数据</li></ul></li></ul><h3>2. special point</h3><p>Vue官方文档中<a href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B">列表渲染</a>中描述了Vue在数据监听中的特殊之处</p><h4>(1) Vue不能检测对象属性的添加或删除</h4><blockquote><p>由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：</p><p>对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用</p><ul><li>Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。例如：Vue.set(vm.userProfile, &#39;age&#39;, 27)</li><li>使用 Object.assign 方法，直接赋值的原理监听。例如：this.watchObj = Object.assign({}, this.watchObj, {name: &#39;xiaoyue&#39;,age: 15});</li></ul></blockquote><p>原因是由于Vue在初始化实例时就对属性执行了setter/getter转化过程，所以属性必须开始就在对象上，这样才能让Vue转化监听，后期添加的属性无法进行变化监测。</p><h4>(2) 数组变化监听的特殊之处</h4><p>我们知道Vue能够监听<strong>整个对数组进行赋值更新</strong>，<strong>对数组使用变异方法进行更新</strong>，并可以响应到视图跟新中，Vue的官方文档中有这样的一段描述：</p><blockquote><p>Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法有push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p><p>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p><ol><li>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue</li><li>当你修改数组的长度时，例如：vm.items.length = newLength</li></ol></blockquote><p>举个例子：</p>',10),p=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"var vm = new Vue({\n  el: '#demo',\n  data: {\n      nameArray:['Foo' ,'Bar']\n  },\n  computed: {\n    fullName: function () {\n      return this.nameArray[0] + ' ' + this.nameArray[1]\n    }\n  },\n  methods: {\n    change () {\n        this.nameArray[0] = '123'; //fullName不会发生改变\n        this.nameArray = ['123','Bar']; //fullName发生改变\n        this.nameArray.splice(0, 1, '123'); //fullName发生改变\n        this.$set(this.nameArray, 0, '123'); //fullName发生改变\n    }\n  }\n})\n")],-1),O=Object(c["i"])("p",null,[Object(c["h"])("其实很简单的可以理解为什么Vue无法监听数组中新增的属性，因为在Vue实例创建的时候，数组中的每个元素就被添加到了Observer的列表中，监测器变化，支持视图响应，新增的属性无法添加到Observer的列表中，因此没有办法响应到视图，对此Vue设置了变异方法对新增元素的push,unshift,splice三种方法做了特异处理，这一部分的源码在"),Object(c["i"])("a",{href:"https://github.com/vuejs/vue/blob/dev/src/core/observer/array.js"},"vue/observer/array.js"),Object(c["h"])("：")],-1),d=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"['push','pop','shift','unshift','splice','sort','reverse'].forEach(function (method) {\n  const original = arrayProto[method]\n  def(arrayMethods, method, function mutator (...args) {\n    const result = original.apply(this, args)\n    const ob = this.__ob__\n    let inserted\n    switch (method) { //针对添加新元素的变异方法做了特殊的处理，使得Vue能够监听到通过变异方法添加的元素的变化\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted) //对新增的数据元素进行Observer\n    ob.dep.notify()\n    return result\n  })\n})\n")],-1),u=Object(c["g"])('<p><strong>但是Object.defineProperty是可以通过索引属性来设置属性的访问器属性的，为什么监听不到呢？？</strong></p><p>其实并不是说JS不能支持响应式数组，并没有这种限制，而是一般的开发者使用数组与使用对象的方法有区别，数组在JS中常被用作栈、队列、集合等数据结构的实现方式，会存储批量的数据以待遍历，并且编译器对数组和对象的优化也有所不同，所以数组的处理需要异化来提高性能。</p><p><strong>首先，针对索引这一点</strong>Vue 中是通过对 每个键设置 getter/setter 来实现响应式的，开发者使用数组，目的往往是遍历，此时调用 getter 开销太大了，所以 Vue 不在数组每个键上设置，而是在数组上定义<code>__ob__</code> ，并且替换了 push 等等能够影响原数组的原型方法.</p><p><strong>其次，针对length这一点</strong>我们观察Vue的源码，它针对数组做了特殊的变化监测策略：用 Object.keys() 或者 Object.getOwnPropertyNames() 就能获得所有键的名字，前者是所有自有可枚举的，后者是所有自有的，不需要用 length。</p><p>从源码可以看到，Vue跳过了对数组每个键设置响应的过程，而是直接对值进行递归设置响应式,这一部分的源码在<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js">vue/observer/index.js</a>：</p>',5),m=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"export class Observer {\n  ...\n  constructor (value: any) {\n    ...\n    if (Array.isArray(value)) {\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n      this.observeArray(value)\n    } else {\n      this.walk(value) //监听对象元素的变化\n    }\n  }\n  observeArray (items: Array<any>) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])//对值进行递归响应式\n    }\n  }\n}\n")],-1);function g(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n,a,l,i,j,o,r,h,b,p,O,d,u,m])}const f={};f.render=g;t["default"]=f},c1e3:function(e,t,s){"use strict";s("3548")},cd49:function(e,t,s){"use strict";s.r(t);s("e260"),s("e6cf"),s("cca6"),s("a79d");var c=s("7a23"),n={class:"m-page"};function a(e,t){var s=Object(c["y"])("Nav"),a=Object(c["y"])("router-view");return Object(c["r"])(),Object(c["e"])("div",n,[Object(c["i"])(s),Object(c["i"])(a)])}s("d55a");const l={};l.render=a;var i=l,j=(s("d3b7"),s("3ca3"),s("ddb0"),s("6c02")),o=Object(c["G"])("data-v-3408c6b9");Object(c["u"])("data-v-3408c6b9");var r={class:"home"};Object(c["s"])();var h=o((function(e,t,s,n,a,l){var i=Object(c["y"])("Block"),j=Object(c["y"])("Pagination");return Object(c["r"])(),Object(c["e"])("div",r,[(Object(c["r"])(!0),Object(c["e"])(c["a"],null,Object(c["x"])(e.postList,(function(e,t){return Object(c["r"])(),Object(c["e"])(i,{key:t,post:e},null,8,["post"])})),128)),Object(c["i"])(j,{total:e.total,onPageChange:e.onPageChange},null,8,["total","onPageChange"])])})),b=s("5530"),p=s("597d"),O=s("5c40"),d=s("2efe"),u=Object(c["G"])("data-v-d6a35aac");Object(c["u"])("data-v-d6a35aac");var m={key:0,class:"pagination"},g={class:"pagination-title"},f={class:"pagination-main"};Object(c["s"])();var v=u((function(e,t,s,n,a,l){return e.total>e.pageSize?(Object(c["r"])(),Object(c["e"])("div",m,[Object(c["i"])("div",g,"共计"+Object(c["A"])(e.total)+"篇文章，"+Object(c["A"])(e.pageCount)+"页",1),Object(c["i"])("div",f,[Object(c["i"])("div",{class:["pagination-main-item break start",{disable:1===e.curPage}],onClick:t[1]||(t[1]=function(){return e.toPre&&e.toPre.apply(e,arguments)})},null,2),(Object(c["r"])(!0),Object(c["e"])(c["a"],null,Object(c["x"])(e.pageLine,(function(t){return Object(c["r"])(),Object(c["e"])("div",{class:["pagination-main-item",{active:t===e.curPage,empty:"..."===t}],key:t,onClick:function(s){return e.toJump(t)}},Object(c["A"])(t),11,["onClick"])})),128)),Object(c["i"])("div",{class:["pagination-main-item break",{disable:e.curPage===e.pageCount}],onClick:t[2]||(t[2]=function(){return e.toNext&&e.toNext.apply(e,arguments)})},null,2)])])):Object(c["f"])("",!0)})),y=(s("a9e3"),s("a630"),s("d81d"),s("a7bb")),w=Object(c["j"])({props:{total:{type:Number,default:0},onPageChange:{type:Function,default:function(){return function(){}}}},setup:function(e){var t=y["b"].PageSie,s=6,n=Object(c["w"])(1),a=Object(c["v"])({pageLine:[]}),l=function(){if(i.value<=s){var e=Array.from(new Array(i.value).keys());return e.map((function(e){return e+1}))}var t=[];return n.value-1>1&&t.push(n.value-1),t.push(n.value),n.value+1<i.value&&t.push(n.value+1),t[0]>2&&t.unshift("..."),1!=t[0]&&t.unshift(1),t[t.length-1]<i.value-1&&t.push("..."),t[t.length-1]!=i.value&&t.push(i.value),t},i=Object(c["c"])((function(){return Math.ceil(e.total/t)}));a.pageLine=l(),Object(c["D"])((function(){return n.value}),(function(){a.pageLine=l();var s=(n.value-1)*t,c=s+t;e.onPageChange&&e.onPageChange(s,c)})),Object(c["D"])((function(){return i.value}),(function(){a.pageLine=l()}));var j=function(){var e=n.value-1;n.value=e>=1?e:n.value},o=function(){var e=n.value+1;n.value=e<=i.value?e:n.value},r=function(e){"string"!==typeof e&&(n.value=e>=1&&e<=i.value?e:n.value)};return Object(b["a"])(Object(b["a"])({curPage:n,pageCount:i,pageSize:t},Object(c["B"])(a)),{},{toPre:j,toNext:o,toJump:r})}});s("256c");w.render=v,w.__scopeId="data-v-d6a35aac";var k=w,x=Object(O["l"])({setup:function(){var e=p["a"].listCompiler(),t=function(t,s){Object(y["f"])(),e.reloadList({startIndex:t,endIndex:s})};return Object(b["a"])(Object(b["a"])({},e),{},{onPageChange:t})},components:{Block:d["a"],Pagination:k}});s("b419");x.render=h,x.__scopeId="data-v-3408c6b9";var V=x,C=(s("b0c0"),Object(c["G"])("data-v-712f90fa"));Object(c["u"])("data-v-712f90fa");var S={class:"list"},I={class:"list-tag"},_={class:"list-main"},E={class:"date"},P={class:"title"};Object(c["s"])();var A=C((function(e,t,s,n,a,l){return Object(c["r"])(),Object(c["e"])("div",S,[Object(c["i"])("div",I,[Object(c["i"])("div",{class:["blog-tag",{selected:!e.selectedTags.length}],onClick:t[1]||(t[1]=function(){return e.tapAll&&e.tapAll.apply(e,arguments)})},"All",2),(Object(c["r"])(!0),Object(c["e"])(c["a"],null,Object(c["x"])(e.tagList,(function(t){return Object(c["r"])(),Object(c["e"])("div",{class:["blog-tag",{selected:e.selectedTags.indexOf(t)>=0}],key:t,onClick:function(s){return e.tapTag(t)}},Object(c["A"])(t),11,["onClick"])})),128))]),Object(c["i"])("div",_,[(Object(c["r"])(!0),Object(c["e"])(c["a"],null,Object(c["x"])(e.postList,(function(t,s){return Object(c["r"])(),Object(c["e"])("div",{class:"list-main-item",key:s,onClick:function(s){return e.tapPost(t.name)}},[Object(c["i"])("span",E,Object(c["A"])(t.date),1),Object(c["i"])("span",P,Object(c["A"])(t.title),1)],8,["onClick"])})),128))])])})),T=(s("a434"),Object(c["j"])({setup:function(){var e=Object(j["e"])(),t=Object(c["v"])({tagList:[],selectedTags:[]}),s=p["a"].listCompiler({banPagination:!0});t.tagList=p["a"].getAllPostTag();var n=function(e){if(e){var c=t.selectedTags.indexOf(e);c>=0?t.selectedTags.splice(c,1):t.selectedTags.push(e),s.reloadList({tags:t.selectedTags})}},a=function(){t.selectedTags=[],s.reloadList()},l=function(t){t&&(Object(y["f"])(),e.push("/post?file=".concat(t)))};return Object(b["a"])(Object(b["a"])(Object(b["a"])({},Object(c["B"])(t)),s),{},{tapPost:l,tapTag:n,tapAll:a})}}));s("3f9c");T.render=A,T.__scopeId="data-v-712f90fa";var M=T,N=[{path:"/",name:"Home",component:V},{path:"/list",name:"List",component:M},{path:"/cv",name:"CV",component:function(){return s.e("chunk-14436ac0").then(s.bind(null,"3f23"))}},{path:"/post",name:"Post",component:function(){return s.e("chunk-fb6f7452").then(s.bind(null,"37d3"))}},{path:"/tag",name:"Tag",component:function(){return s.e("chunk-a7c54b84").then(s.bind(null,"8ea7"))}}],z=Object(j["a"])({history:Object(j["b"])(),routes:N}),D=z,$=s("cf05"),R=s.n($),L=Object(c["G"])("data-v-31190f33");Object(c["u"])("data-v-31190f33");var H={class:"header"},B={class:"header-inner-logo"},F=Object(c["i"])("img",{src:R.a},null,-1),q=Object(c["h"])("Gemma's Blog"),W={class:"header-inner-nav"},J=Object(c["h"])("主页"),G=Object(c["h"])("归档"),U=Object(c["h"])("CV");Object(c["s"])();var K=L((function(e,t,s,n,a,l){var i=Object(c["y"])("router-link");return Object(c["r"])(),Object(c["e"])("div",H,[Object(c["i"])("div",{class:["header-inner clearfix",{"larger-nav":e.isPost}]},[Object(c["i"])("div",B,[F,Object(c["i"])(i,{class:["title home",{active:"Home"===e.routeName}],to:"/"},{default:L((function(){return[q]})),_:1},8,["class"])]),Object(c["i"])("div",W,[Object(c["i"])(i,{class:["title",{active:"Home"===e.routeName}],to:"/"},{default:L((function(){return[J]})),_:1},8,["class"]),Object(c["i"])(i,{class:["title",{active:"List"===e.routeName}],to:"/list"},{default:L((function(){return[G]})),_:1},8,["class"]),Object(c["i"])(i,{class:["title",{active:"CV"===e.routeName}],to:"/cv"},{default:L((function(){return[U]})),_:1},8,["class"])])],2)])})),X=Object(c["j"])({setup:function(){var e=Object(c["w"])(""),t=Object(c["w"])(!1),s=Object(j["d"])();return Object(c["D"])((function(){return s.name}),(function(){e.value=s.name,t.value="Post"===s.name})),{routeName:e,isPost:t}}});s("c1e3");X.render=K,X.__scopeId="data-v-31190f33";var Y=X,Q=(s("de77"),s("2c43"),Object(c["d"])(i));Q.component("Nav",Y),Q.use(D).mount("#app")},ce75:function(e,t,s){},cf05:function(e,t,s){e.exports=s.p+"img/logo.cfd07c7f.png"},d55a:function(e,t,s){"use strict";s("353e")},dda5:function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])('<p>文本分类是一项系统的工程，所涉及的技术很多，按流程可以将文本分类分为:文本预处理阶段、训练阶段、分类阶段、评价四个阶段，其中预处理阶段要文本处理成计算机能识别的格式，首先对文本进行分词处理，中文文本和英文文本组织形式不同，中文文本的分词过程比英文分词要复杂得多。分词后文本的特征词非常多，而我们需要的只是少数有使用价值的特征词，因此分词后的文本要进行特征选择，并将特征选择后的特征项加权，最后将文本表示成向量空间模型(VSM)，经过预处理后的文本才能进行分类。分类算法是文本分类的核心技术。评估阶段是对文本分类的效果进行评价，常用的指标有:准确率、召回率、以及综合这两个指标的评价方法一F1值等。</p><h3>文档表示方法</h3><p>文档集划分为训练集和测试集两个部分，训练集用于分类模型的学习，一般占整个文档集的70%;测试集用于评价分类模型，一般占整个文档集的30%。开放的英文文档集Reuters-21578和20NewsGroups。前者比后者更为常用。</p><p>经过半个世纪的发展，在文本处理领域，研究者提出了一些文本表示模型，主要有：布尔模型、向量空间模型、概率检索模型、n-Gram模型等，其中使用最广、效果最好的是向量空间模型。</p><p><strong>向量空间模型</strong></p><p>20世纪60年代，Salton G等人提出了向量空间模型，并成功应用于SMART文本检索系统，其基本思想是:将文本表征成由特征项(词)构成的向量空间中的一个点，（W1,W2,…,Wi），其中Wi为第i个特征项的权重，然后通过计算空间两点之间的相似度来表示两个文本的相关程度，相似度计算一般采用欧氏距离或向量夹角的余弦值。向量空间模型在实际使用中取得了很好的效果，常用的文本分类算法中，支持向量机、K近邻、和NB都是基于向量空间模型的。</p><p><strong>布尔模型</strong></p><p>布尔模型可以看作是向量模型的一种特例，根据特征是否在文档中出现，特征的权值只能取1或0。许多时候，使用二值特征的分类效果结果并不比考虑特征频率的差。决策树方法、关联规则方法和Boosting方法就是基于布尔模型。</p><p><strong>概率模型</strong></p><p>我们可以用该流程的思想来解决出现在文档检索中的不确定性和找寻的不清楚性。概率模型的理论是基于概率排队的：如果文件是按相关概率递减方向排队时，那么就会出现最大的检索性能。选用此种模型可以克服BM和SVM中的不足，此种模型根据词与词间和文档间与词条的概率关联性进行搜索。设文档d和顾客查询c都用（a1,a2,…an）表示，当词条ti∈d时，有ai=1.否则ai=0,这种关系可数学表示为： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image1.png" class="center"> 其中 <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image2.png" class="center"> 　　f是所有参加训练的文档的总和，r则为顾客查询与文档集中相关的文档数，fi则表示训练文档集中有ti的文档数，ri则表示r个相关文档中有ti的文档数，模型的有点是有着非常严谨的数学理论基础，解决了不确定性推理的缺点，但是它的不足在于参数估计方面很困难，在文件和查询的表达方面也是很困难</p><h3>文档分词</h3><p>词是文本中最小的具有意义的语言成分，是构造向量空间模型的基础，文本分词的效果直接影响到文本分类的结果。在文本的组织上，中文与以英语为代表的欧美语言有着很大的不同，在西方语言中，词与词是使用空格隔开的，因此不需要进行分词处理，而在中文文本中，字、词是连在一起的，一个语句就是一连串的字、词组合，词与词之间没有明显界限，因此，分词的难度较大。常用的分词算法主要有:基于词典的分词方法、基于理解的分词方法、基于统计的分词方法。</p><p><strong>基于词典的分词方法</strong></p><p>基于词典的分词方法又叫做机械分词方法，它是按照一定的策略将待切分的字符串与词典中的词条进行匹配，若在词典中找到某个字符串，则匹配成功(即识别出一个词)。按照扫描方向的不同，基于词典的分词方法可以分为正向匹配和逆向匹配;按照不同长度优先匹配的情况，可以分为最大匹配和最小匹配;按照是否与词性标注过程相结合，又可以分为单纯分词方法和分词与标注相结合的一体化方法，常用的几种基于词典分词方法如下:正向最大匹配法(由左到右的方向)、逆向最大匹配法(由右到左的方向)、逐词遍历法。</p><p>在实际应用中，常常将上述方法结合起来。例如，可以将正向最大匹配方法和逆向最大匹配方法结合起来构成双向匹配法。由于汉语单字成词的特点，正向最小匹配和逆向最小匹配一般很少使用。一般说来，逆向匹配的切分精度略高于正向匹配，遇到的歧义现象也较少。</p><p>再一种方法是改进扫描方式，称为特征扫描或标志切分，优先在待分析字符串中识别和切分出一些带有明显特征的词，以这些词作为断点，可将原字符串分为较小的串再来进行机械分词，从而减少匹配的错误率。还有一种方法是将分词和词类标注结合起来，利用丰富的词类信息对分词决策提供帮助，并且在标注过程中又反过来对分词结果进行检验、调整，从而极大地提高切分的准确率。目前实用的自动分词系统基本上都是以采用机械分词为主，辅以少量的词法、语法和语义信息的分词系统。该方法的优点是易于实现，但精度较低，远远不能满足实际的需要。实际使用的分词系统，都是把机械分词作为一种初分手段，再利用各种其它的语言信息来进一步提高切分的准确率。</p><p><strong>基于理解的分词方法</strong></p><p>又称人工智能分词法，这种分词方法是通过让计算机模拟人对句子的理解，达到识别词的效果。其基本思想就是在分词的同时进行句法、语义分析，利用句法信息和语义信息来处理歧义现象。它通常包括三个部分:分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断，即它模拟了人对句子的理解过程。这种分词方法需要使用大量的语言知识和信息。由于汉语语言知识的笼统、复杂性，难以将各种语言信息组织成机器可直接读取的形式，因此目前基于理解的分词系统还处在试验阶段。</p><p><strong>基于统计的分词方法</strong></p><p>基于统计的分词算法的思想是:找出输入字符串的所有可能的切分结果，对每种切分结果利用能够反映语言特征的统计数据计算它的出现概率，然后从结果中选取概率最大的一种。词是稳定的字的组合，因此在上下文中，如果相邻的字共现的次数越多，就越有可能构成一个词。因此字与字相邻出现的频率或概率能够较好的反映成词的可信度。通过对语料中相邻共现的各个字的组合频度进行统计，计算它们的互现信息。互现信息体现了汉字之间结合关系的紧密程度。当紧密程度高于某一个阈值时，便可认为此字组可能构成了一个词。这种方法只需对语料中的字组频度进行统计，不需要切分词典，因而又叫做无词典分词法或统计取词方法。但这种方法也有一定的局限性，会经常抽出一些共现频度高、但并不是词的常用字组，并且对常用词的识别精度差，时空开销大。实际应用的统计分词系统都要使用一部基本的分词词典进行串匹配分词，同时使用统计方法识别一些新的词，即将串频统计和串匹配结合起来，既发挥匹配分词切分速度快、效率高的特点，又利用了无词典分词结合上下文识别生词、自动消除歧义的优点。</p><p>对于任何一个成熟的中文分词系统来说，不可能单独依靠某一种算法来实现，需要 综合不同的算法来处理不同的问题。</p><h3>停用词处理技术</h3><p>经过分词处理的文本，并不是所有的特征都对构造向量空间模型和分类有帮助，相反，将对文本分类没有帮助的词作为特征项，会对分类的精度造成很大的影响，特别对于使用文档频率(DF)进行特征选择的分类方法，影响更大。另外，去停用词可以很大程度上减小特征项的数量，对文本降维具有很大帮助，所以在构造向量空间模型前，要对分类无帮助的词进行尽可能彻底的清理。去停用词在技术上实现并不复杂，只需建立一个停用词词典停用词词典内的词条进行匹配，如果匹配成功，则将该词去掉。</p><h3>特征选择方法</h3><p>在经过文本分类系统的分词、去停用词处理后，文本的特征维数仍然很高，这里所指的特征维数是指要构造VSM空间的所有文本的特征之和，一个文本集合很可能包含十几万个特征词，而每篇文本包含的特征词却很少，这样构造的向量空间模型是一个高维的稀疏矩阵，会对分类算法的时间复杂度和空间复杂度造成很大的影响。实验显示，当向量空间的特征维度达到一定值时就可以实现很高的分类性能，随着特征维度的增加，分类性能反而会下降。因此，必须对特征项进行有效的筛选。常用的文本特征选择方法有:文档频率(DF)、信息增益(IG)、互信息(MI)、X2统计量(CHI)、期望交叉嫡等，这些方法的基本思想都是对每一个特征(在这里是中文词)，计算某种统计度量值，然后设定一个阈值T，把度量值小于T的那些特征过滤掉，剩下的即认为是有效特征。</p><p><strong>文档频率（DF）</strong></p><p>DF值低于某个阈值的词条是低频词，它们不含或含有较少的类别信息。将这样的词条从原始特征空间中移除，不但能够降低特征空间的维数，而且还有可能提高分类的精度。DF高于某个阈值的词为中、高频词，这些词被认为对分类的影响较大，应该保留。在英文环境中，当IG和CHI等统计方法的计算复杂度太高时，DF可以代替它们被使用。</p><p><strong>互信息（MI）</strong></p><p>如果用A表示包含词条t且属于类别c的文档频数，B为包含t但不属于c的文档频数，C表示属于c但是不包含t的文档频数，N表示语料中的文档总数，t和c的互信息由下式计算： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image3.png" class="center"></p><p>如果t和c无关（即P(tc)=P(t)*P(c)），I(t,c)值自然为零。为了将互信息应用于多个类别，由下式计算t对于c的互信息： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image4.png" class="center"></p><p>其中m为类别数，将低于特定阈值的词条从原始特征空间中移除，降低特征空间的维数，保留高于阈值的词条</p><p><strong>信息增益（IG）</strong></p><p>表示文档包含某一特征时文档类的平均信息量，定义为某一特征在文档中出现前后的信息熵之差。假定c为文本类变量，C为文本类的集合，d为文本，f为特征。对于特征f其信息增益记为IG(f)，计算公式 <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image5.png" class="center"></p><p><strong>X2统计（CHI）</strong></p><p>CHI统计方法度量词条t和文档类别c之间的相关程度，并假设t和c之间符合具有一阶自由度的x2分布，词条对于某类的x2统计值越高，它与类之间的相关性越大，携带的类别信息也较多，令N表示训练语料中的文档总数，c为某一特定类别，t表示特定的词条，A表示属于c类且包含t的文档频数，B表示不属于c类但包含t的文档频数，C表示属于c类但不包含t的文档频数，D表示既不属于c也不包含t的文档频数，则t对于c的CHI值计算公式： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image6.png" class="center"></p><p>对于多类问题，分别计算t对于每个类别的CHI值，可以用下面两种标准计算t对整个训练集的CHI： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image7.png" class="center"></p><p>其中m为类别数，从原始特征空间中移除低于特定阈值的词条，保留高于该阈值的词条作为文档表示的特征</p><h3>特征权重计算方法</h3><p><strong>布尔权重</strong></p><p>均权，布尔权重是最最简单的一种赋权方法，这种方法将所有特征同等看待，既不突出又不抑制任何一个特征。特征项的权值或者等于1，或者等于0,计算公式为: <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image8.png" class="center"></p><p>其中Wi为特征项i的权重，TF为特征项i出现的次数，这种方法的缺点就是无法体现一个词在文本中的重要程度。</p><p><strong>TF权重</strong></p><p>TF权重(Term Frequency)又称词频权重，或称特征项频率。不同类别的文档，在特征项的出现频率上有很大差异，因此特征项频率信息是文本分类的重要参考之一，一般较大的特征项在该类文档中具有较高的权重。它的计算公式为: <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image9.png" class="center"></p><p>实际应用中各类别文本的长度很难一致，各类文本包含的字数、词数可能差别会很大，这对词频会造成直接影响，因此通常对词频作归一化处理。另外，如果特征选择后的特征项中含有较多的非名词(如代词、数词、连词)，而这些词出现的概率非常高，如果使用TF权重加权，会赋值给这些词较高的权重，这势必对分类结果产生不利影响，因此，TF权重对去停用词的效果具有较强依赖性。</p><p><strong>IDF权重</strong></p><p>IDF越大，此特征项在文档中的的分布越集中，说明它在区分该文档内容属性方面的能力越强。反文档频率是特征项在文档集分布情况的量化。该方法以出现特征词的文本数为参数构建的函数代表特征项的权重。这体现了信息论中集中度的思想，具有一定的合理性，但忽略了分散度和频度两个因素，因此具有片面性，公式如下: <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image11.png" class="center"></p><p><strong>TFIDF权重</strong></p><p>TFIDF(Term Frequency-Inverse Document Frequency)是由是由Salton在1988年提出的，TFIDF权重综合考虑了TF权重和IFD权重的优点和不足，是目前加权效果最好的权重计算方法，广泛应用于文本处理领域。其基本思想是:如果特征项t在一类文档的出现的次数越多，而在整个文档集中出现的频率越低，那么t对分类的作用越大，应该赋予越高的权重，例如，助词“的”几乎在每篇文档中都出现，因此它的TF值非常高，相反，IDF值却非常低，综合考虑TF和IDF，该词将被赋予很低的权重。TFIDF权重，即TF权重和IDF权重的组合，利用了词频和文本频率两种信息，公式如下: <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image12.png" class="center"></p><p>式中TF为第k个特征词在第1篇文本中出现次数，N为训练集中总文本数，nk为出 现第k个特征词的文本数，a为一个经验值，一般取0. 01, 0. 1或者1</p><h3>相似度计算</h3><p><strong>向量夹角的余弦</strong></p><p>设文档A在VSM空间中的向量形式为a(x1,x2,…,xa)，文档B在VSM空间中向量形式为b(y1,y2,…,yb),则A,B文本的向量夹角的余弦表示为 <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image13.png" class="center"></p><p>两个向量夹角的余弦值越大，表示这两个向量的相似度越高</p><p><strong>欧氏距离</strong></p><p>欧式距离是通过空间向量点之间的距离来表示文本的相关程度，具体的形式为： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image14.png" class="center"></p><p>其中d(x,y)是样本x和y的欧式距离，m是样本属性总数，两个向量点之间的欧式距离越小，表示两个向量的相似度越高，在文本分类领域，使用向量夹角余弦计算文本相似度的效果，要好于欧式距离</p><h3>文本分类方法</h3><p>从文本分类的方法来看，现有的文本分类技术主要采用三种类型的方法:基于统计的方法，基于连接的方法和基于规则的方法。</p><p><strong>基于连结的方法</strong></p><p>即人工神经网络，是设计来模拟人脑神经网络的，并期望其能像大脑一样地运作，像大脑一样地学习，从而产生智慧。这种方法具有信息分布存放、运算全局并行、处理的非线性、容错性等特点，适用于学习一个复杂的非线性映射。但是使用它学习所形成的知识结构是人所难以理解的，系统本身对于使用的人来说就象是一个变魔术的黑盒子，根据输入给出输出，答案正确但不知道是怎么算出来的。</p><p><strong>基于规则的方法</strong></p><p>一种唯理主义方法，本质上是一种确定性的演绎推理方法，优点在于根据上下文对确定性事件进行定性描述，能充分利用现有的语言学成果。它成立的前提是有大量的知识，而这些知识是人类专家总结出来的，至少解释这些知识的各种“事实”以及对事实的解释“规则”是专家总结归纳的。由于必须有人的参与，所以对于知识的可理解性，可读性非常重视。同时，在不确定性事件的描述，规则之间的相容性等方面存在一些缺陷和限制。该算法在领域专家的知识上具有依赖性，分类体系好，错误率低，but在专业领域的知识组织和管理中比较实用，实现困难，成本高，没有普遍性，不容易移植等缺点。但是，有些统计方法无法解决的问题，利用规则却很容易解决。常用的基于规则的方法有决策树、关联规则等。</p><p><strong>基于统计的方法</strong></p><p>本质上是一种非确定性的定量推理方法，定量是基于概率的，因此其必然会掩盖小概率事件的发生。基于统计的方法是一种经验主义方法，其优势在于它的全部知识是通过对大规模语料库分析得到的，可以取得很好的一致性和非常高的覆盖率，对语言处理提供了比较客观的数据依据和可靠的质量保证。常用的基于统计的方法有Naive Bayes , KNN等。</p><p><strong>NaiveBayes算法</strong></p><p>贝叶斯分类是统计学分类方法，它是一类利用概率统计知识进行分类的算法。在许多场合，朴素贝叶斯(NaiveBayes, NB)分类算法可以与决策树和神经网络分类算法相媲美，该算法能运用到大型数据库中，且方法简单、分类准确率高、速度快。由于贝叶斯定理假设一个属性值对给定类的影响独立于其它属性的值，而此假设在实际情况中经常是不成立的，因此其分类准确率可能会下降。具体地，设每个数据样本用一个n维特征向量来描述n个属性的值，即:X={X1,X2,…,Xn}假定有m个类，分别用C1,C2,…,Cm表示。给定一个未知的数据样本X,若朴素贝叶斯分类法将未知的样本X分配给类C，则一定是: <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image15.png" class="center"></p><p>根据贝叶斯定律： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image16.png" class="center"></p><p>由于P(X)对于所有类为常数，最大化后验概率P(Ci |x)可转化为最大化先验概率P(x|Ci)P(Ci)。如果训练数据集中有许多属性和元组，计算P(x|Ci)的开销可能非常大，为此，通常假设各属性的取值相互独立，这样 <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image17.png" class="center"></p><p>先验概率可以从训练数据集中求得。根据此方法，对于一个位置类别的样本X，可以分别计算出X属于每一个类别Ci的概率然后选择其中概率最大的类别作为其类别。</p><p>Naive Bayes方法分为最大似然模型(Maximum Likelihood Model )、多项式模型(Multinomial Model )、泊松模型(PoisonModel)等。朴素贝叶斯算法的主要优点是：对于文本数据和数值数据的分类效果较好，与其他算法相比易于实现和计算。主要缺点：朴素贝叶斯算法成立的前提是各属性之间相互独立 ，当数据集满足这种独立性假设时，分类的准确度较高，否则可能较低。</p><p><strong>KNN算法</strong></p><p>KNN算法最初由Cover和Hart于1986年提出，该算法的基本思想：根据传统的向量空间模型，文本内容被形式化为特征空间中的加权特征向量，即D=D(T1,W1;T2,W2;…;Tm,Wm)。对于测试文本，计算它与训练样本集中每个文本的相似度，找出K个最相似的文本，根据加权距离和判断测试文本所属的类别。具体算法步骤如下：</p><ul><li><p>对于一个测试文本，根据特征词形成测试文本向量</p></li><li><p>计算该测试文本与训练集中每个文本的文本相似度： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image18.png" class="center"></p></li></ul><p>式中di为测试文本的特征向量，dj为第j类的中心向量；M为特征向量的维数；Wk为向量的第k维。k的值的确定一般先采用一个初始值，然后根据实验测试K的结果调整K值，一般初值设定为几十到几百</p><ul><li><p>按照文本相似度，在训练文本集中选出与测试文本最相似的k个文本</p></li><li><p>在测试文本的k个近邻中，依次计算每类的权重，计算公式 <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image19.png" class="center"></p></li></ul><p>x为测试文本的特征向量；Sim(x,di)为相似度计算公式；b为阈值，有嗲与优化选择；而y(di,cj)的取值为1或者0，如果di属于cj，则函数值为1，否则为0</p><ul><li>比较类的权重，将文本分到权重最大的那个类别 也就是说，如果在这k个文档中，有多个文档同属于一个类，则该类的分值为这些文档与测试文档之间的相似度之和。对这k个文档所属类的分值统计完毕后，即按分值进行排序。</li></ul><p><strong>类中心向量法</strong></p><p>类中心向量法的算法思想非常简单：将每一类别文本训练后得到该类别的中心向量Cj(W1,W2,…,Wj)分类时，将待分类文本T表示成n维向量的形式T(W1,W2,…,Wn)然后，计算文本T与每类中心向量的相似度，相似度计算可以采用向量夹角的余弦或是欧氏距离表示，将T归类为与其相似度最大的类中： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image20.png" class="center"></p><p>类中心的选择有三种方式：平均中心、和平均、归一化平均。和中心是某一类别中所有向量相加之和： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image21.png" class="center"></p><p>将和中心与该类向量的个数相除得到类别的平均中心： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image22.png" class="center"></p><p>而采用二范数对平均中心归一化处理得到归一化中心： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image23.png" class="center"></p><p>类中心向量法的优点是对训练集进行了最大程度的裁剪，待分类文本只需与极少的类中心向量对比，就可以将其分类，因此训练和分类速度很快。缺点是分类精度受类别的分布影响较大，当类别分布均匀，边界清晰时，分类精度较高;当类别分布不平衡，边界模糊时，分类的效果不好。</p><p><strong>SVM算法</strong></p><p>支持向量机SVM(Support Vector Machines)是Vapnik等人提出的一种基于统计学习理论的机器学习方法。SVM建立在统计学理论的VC理论和结构风险最小化原理基础上，其基本思想是:使用简单的线形分类器划分样本空间，如果一个训练集中的矢量被一个超平面正确地线性分割，且距离超平面最近的矢量之间的距离最大，则称该超平面为最佳超平面，其中距离超平面最近的对决策面设计起作用的点称为支持向量(Support Verctors)。支持向量机在解决小样本，非线性及高维模式识别问题等方面表现出明显的优势。</p><p>SVM的基本思想可用图3-1的两维情况来说明。图中，实心点和空心点代表两类样本，H为分类线，H1, H2分别为过各类中离分类线最近的样本且平行于分类线的直线，它们之间的距离叫做分类间隔(margin)。所谓最优分类线就是要求分类线不但能将两类正确分开(训练错误率为0)，而且使分类间隔最大。 <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image24.png" class="center"></p><p>支持向量机主要优点：对高维、稀疏数据不敏感，更好的捕捉了数据的内在特征，准确率高；缺点：对于非线性问题，核函数选择较为困难，分类结果召回率较低</p><p>训练样本在各个类别中分布的不均匀性对许多分类器会形成噪声。例如:在Bayes模型中，如果先验分布无法确定，“均匀分布”是符合信息论的最大嫡原则( Maximum Entropy)的;对于KNN和SVM分类器，远离类别边界的样本往往对分类没有什么作用，KNN分类器还会因为类别边界部分样本分布的不均匀而造成测试样本的错分。从候选训练样本集中选择合适的训练样本子集，不仅可以减少分类器的学习时间，甚至可以提高分类器的准确性。四种方法的实验结果比较： <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image25.png" class="center"> 　 　　可以看出支持向量机具有最好的分类效果，各项指标全面领先于其他分类算法。KNN分类效果仅次于支持向量机，而类中心向量法也有很好的分类表现，贝叶斯的分类效果最差，与其它三种算法相比有较大差距。在追求分类效率而对分类精度要求不高的领域，可以考虑使用类中心向量分类法，可以极大提高分类的效率;在对对分类精度要求较高时，可以采用SVM或KNN分类法。</p><h3>分类结果评估</h3><p><strong>单标注分类问题</strong></p><p>文档分类中普遍使用的性能评估指标有查全率(Recall，简记为:r)、查准率（C Precision， 简记为P)。对于文档类中的每一个类别，使用列联表(Contingency Table )来计算查全率和查准率。</p><table><thead><tr><th>Tables</th><th>真正属于该类的文档数</th><th>真正不属于该类的文档数</th></tr></thead><tbody><tr><td>判断为属于该类的文档数</td><td>a</td><td>b</td></tr><tr><td>判断为不属于该类的文档数</td><td>c</td><td>d</td></tr></tbody></table><p>这时，r和P分别定义为: <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image26.png" class="center"></p><p><strong>宏平均and微平均</strong></p><p>用列联表只能评价单个类的分类性能，如果要对分类的整体性能进行评价，通常使用宏 平均 &lt; Macro-Averaging)和微平均 ( Micro-Averaging )。宏观平均是先对每一个类统计r、p值，然后对所有的类求r、P的平均值，即 <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image27.png" class="center"></p><p>微观平均是先建立一个全局列联表，然后根据这个全局列联表进行计算，即: <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image28.png" class="center"></p><p>显然，宏平均是对类的平均，所以容易受小类的影响，而微平均则是对文档的平均，容易受到大类的影响。</p><p><strong>平衡点(Break-even Point )</strong></p><p>对于分类系统来说，r和p值是互相影响的。提高r会引起p的减小，反之亦然。因此， 为了更全面地反映分类系统的性能，一种做法是选取和p相等时的值来表征系统性能，这个值叫做平衡点(Break-even Point，简称BEP)值。当然，有时通过测试可能得不到和p相等的值。这时取最接近的和p值的平均值作为BEP值，称为插值BEP</p><p><strong>F值(F-measure )</strong></p><p>另一种常用的将查全率和查准率结合起来的性能评价方法是F测量，其计算公式为: <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image29.png" class="center"></p><p>其中，β是一个用来调节查全率和查准率权重的参数。β一般取值为1,公式转化为: <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image30.png" class="center"></p><p>显然，BEP是F1的特殊形式，因为当r=p时，有F1 =BEP</p><p><strong>多标注分类问题</strong></p><p>每一个输入的测试文档，都会返回一个排序后的文档类列表。这时，两个指标分别定为: <img src="https://zhangmingemma.github.io/dist/images/2016-12-03/20161203image31.png" class="center"></p><p>整个分类器的评估应该是对所有测试文档的这两个指标的统计平均。通常使用的统计平均为11点插值平均查准率(Interpolated 11-point Average Precision )</p><h3>文本可视化</h3><ul><li><p>标签云：经典的静态可视化分析，Wordle：将关键词或者标签生成为一个可视化的词云</p></li><li><p>ThemeRiver：动态文本可视化，TIARA：参考了wordle的源码实现了系统中的文本静态可视化</p></li><li><p>CiteSpace：以可视化技术针对科学论文以及引文进行网络分析的软件</p></li></ul>',108);function a(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n])}const l={};l.render=a;t["default"]=l},de77:function(e,t,s){},df62:function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])("<h1>什么是垃圾回收？</h1><p>程序运行过程中会产生<code>非活动对象</code>，这些对象没有被引用，占用着内存，需要被清除。这个清除的过程就是<code>垃圾回收(GC)</code>，让空间可以被再利用。对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则硬性系统性能，重则导致进程崩溃。自带垃圾回收机制的语言包括<code>Python</code>、 <code>Java</code>、 <code>JavaScript</code>等。</p><h1>垃圾如何产生？</h1><p>Javascript的引用类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用。所以，<code>Javascript</code>中对引用类型的操作都是操作对象的引用而不是实际的对象。举例：</p>",4),a=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"let test = {\n  name: 'test'\n}\ntest = [1,2]\n")],-1),l=Object(c["g"])('<p>上面的代码，声明了变量<code>test</code>，引用了对象<code>{name: &#39;test&#39;}</code>，接着对这个变量重新赋值为数组，即引用了另一个数组，之前的引用关系就没有了，对象<code>{name: &#39;test&#39;}</code>就是没有引用关系的<code>垃圾</code>，需要被回收。 <img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/1.png"></p><h1>垃圾回收机制</h1><p>垃圾回收机制，就是定期找出无用内存，并释放的机制。之所以为<code>定期</code>，而不是<code>实时</code>，是因为<code>实时</code>开销太大。常见的垃圾回收机制有<code>标记清除法</code>和<code>引用计数法</code>。</p><h2>一. 标记清除法</h2><p>标记清除法，是目前<code>JavaScript引擎</code>里最常用的算法，目前为止的大多数浏览器都采用的是<code>标记清除法</code>，只是各大浏览器厂商对算法进行了优化加工，并且不同浏览器在运行垃圾回收的频率上有所差异。</p><h3>1. 方案</h3><p>标记清除法，分为<code>标记</code>和<code>清除</code>两个阶段，<code>标记</code>阶段为所有<code>活动对象</code>做上标记，<code>清除</code>阶段则把<code>非活动对象</code>销毁掉。</p><ul><li><p>标记：从指针对象的起点开始，遍历全部对象，对可触达对象进行标记。下图分别是标记前、标记后内存中堆的状态 <img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/2.png"><img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/3.png"></p></li><li><p>清除：遍历整个堆，回收没有标记的对象，使其内存能够被再次利用。回收对象就是把对象作为分块，连接到<code>空闲链表</code>的单向链表，之后再分配控件的时候只需要遍历这个空闲链表，就可以找到可用的分块了 <img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/4.png"></p></li></ul><h3>2. 优点：实现简单</h3><h3>3. 缺点</h3><ul><li><p>碎片化严重，容易产生小的分块，可能会导致分配所需内存较大时找不到合适的分块 <img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/5.png"></p></li><li><p>分配速度慢，由于空闲分块是用链表实现，分块可能都不连续，每次分配都需要遍历空闲链表，极端情况下需要遍历整个链表 <img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/6.png"></p></li></ul><blockquote><p>分配策略</p></blockquote><ul><li>First-Fit，找到大于等于<code>size</code>的快立刻返回（最为明智的选择）</li><li>Best-Fit，遍历整个空闲链表，返回大于等于<code>size</code>的最小分块（分配效率略逊色）</li><li>Worst-Fit，遍历整个空闲链表，找到最大分块，切成两部分，一部分<code>size</code>大小，并将该部分返回（会产生很多小碎片）</li></ul><blockquote><p>分配速度慢的解决方案：制造多个空闲链表，分别存储不同size的回收对象分块，减少再次分配时的遍历次数</p></blockquote><h3>4. 标记整理法</h3><p>在<code>标记清除法</code>之后，将<code>活动对象</code>向内存的一端移动，最后清理掉边界的内存 <img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/7.png"></p><h2>二. 引用计数法</h2><p>引用计数法，把<code>对象是否不再需要</code>简化定义为<code>对象有没有其他对象在引用</code>，如果零引用，则将被垃圾回收。</p><h3>1. 方案</h3><ul><li>当声明了一个变量，并且将一个引用类型赋值给该变量的时候，这个值的引用次数就为1</li><li>如果同一个值又被赋给另外一个变量，那么引用数加1</li><li>如果该变量的值被其他的值覆盖了，那么引用数就减一</li><li>当这个值的引用数变为0时，垃圾回收器运行的时候就会清理掉引用数为0的值所占用的内存</li></ul><h3>2. 优点：可以立即回收垃圾，相比之下算法思路也更加清晰</h3><h3>3. 缺点</h3><ul><li>首先需要一个计数器，占用很大的位置，因为我们无法估计被引用数量的上限</li><li>循环引用的问题，下面的例子中对象<code>A</code>、<code>B</code>互相引用，他们的引用数量都是2，但是在<code>test</code>函数执行之后，对象<code>A</code>、<code>B</code>是应该被清理的，导致内存不会被释放</li></ul>',23),i=Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"function test() {\n  let A = new Object()\n  let B = new Object()\n  A.b = B\n  B.a = A\n}\n")],-1),j=Object(c["g"])('<p>上面的例子用<code>标记清除法</code>的思路来看的话，<code>test</code>执行之后，两个对象不在作用域中，<code>A</code>、<code>B</code>都是非活动对象，会被清除掉。</p><h1>V8的垃圾回收</h1><p>V8针对GC过程做了自己的一系列优化策略，首先是将内存对象划分为<code>新生代</code>和<code>老生代</code>两类，执行<code>分代式垃圾回收</code>，针对<code>新生代</code>的垃圾回收并进一步采用<code>并行回收</code>的策略进行优化，针对<code>老生代</code>的垃圾回收采用<code>增量标记</code>和<code>惰性清理</code>配合进行优化，此外，针对<code>老生代</code>的垃圾回收还有<code>并发回收</code>这种优化方式，每种方式的具体实现细节和优缺点接下来会展开进行详细陈述。</p><h2>一. 分代式垃圾回收</h2><p>如果垃圾回收算法在每次回收时都要检查内存中所有的对象，对大、老、存活时间长的对象和小、新、存活时间短的对象采用相同的频率去检查，是损耗性能的。因为前者检查一次耗损较大，且并不需要频繁清理，而后者刚好相反。<code>分代式回收机制</code>就是将堆内存分为新生代和老生代两区域，采用不同的策略管理垃圾回收。<code>新生代</code>是指存活时间较短的对象，只支持<code>1~8M</code>的容量，<code>老生代</code>是指存活时间较长、常驻内存的对象，容量较大。</p><h3>1. 新生代垃圾回收</h3><p>将堆内存一分为二，一是<code>使用区</code>，即处于使用状态的空间，另一个是<code>空闲区</code>，即处于闲置状态的空间。</p><img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/8.png"><ul><li>新加入的对象都会存放在<code>使用区</code>，使用区快写满的时候，会执行一次垃圾清理。</li><li>当开始垃圾回收时，新生代垃圾回收器会对<code>使用区</code>的对象进行标记，标记完成后将<code>使用区</code>的活动对象复制到<code>空闲区</code>并进行排序，随后进入垃圾清理阶段，将非活动对象都清理掉，最后进行角色互换，<code>使用区</code>变<code>空闲区</code>，<code>空闲区</code>变<code>使用区</code>。</li><li>当一个对象经过多次复制后仍旧存货，则被认为是<code>老生代</code>，将移入<code>老生代</code>内存中进行管理。当复制对象时<code>空闲区</code>空间占用超过25%，则直接移入<code>老生代</code>，否则将影响后续的内存分配。</li></ul><h3>2. 老生代垃圾回收</h3><p>老生代大多数占用空间较大，不适合来回复制，采用标准的标记清除法进行垃圾回收。</p><ul><li>标记阶段，从一组根元素开始，递归遍历，不可触达的对象即为非活动对象，进行清理</li><li>为避免产生碎片化内存，采用<code>标记整理法</code>优化空间</li></ul><h2>二. 并行回收 - 新生代</h2><p>JS是单线程的语言，进行垃圾回收会阻塞到JS脚本的执行，需要等待垃圾回收结束后恢复，因此，V8引入了<code>并行回收机制</code>去优化<code>新生代垃圾回收</code>。</p><img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/9.png"><p>并行回收就是启动多个线程来负责垃圾回收，这些线程同时将<code>使用区</code>中的数据移动到<code>空闲区</code>，这个过程中由于数据地址发生变化，还需要同步更新引用这些对象的指针。</p><h2>三. 增量标记与惰性清理 - 老生代</h2><p>对于<code>老生代垃圾回收</code>仍旧会完全阻塞JS脚本的执行，为了减少全停顿的时间，V8进行优化，将全停顿标记切换为<code>增量标记</code></p><h3>1. 增量标记</h3><p>增量标记，就是将以此GC标记过程，分成很多小步，没执行一步就让JS脚本执行一会儿，交替多次完成一轮GC</p><img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/10.png"><p>增量标记遇到的一个问题就是，在一次标记之后，执行JS程序，而后如何恢复？如何继续上次的标记？中间已经标记过的对象的引用关系发生了修改，该怎么办呢？</p><h4>1). 三色标记法 - 恢复增量标记</h4><p>针对上面<code>增量标记</code>中提到的，暂停标记执行JS程序后，无法恢复标记的问题，V8采用的应对方案是<code>三色标记法</code>。<code>三色标记法</code>即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三个颜色：白、灰、黑</p><ul><li>白色指未标记的对象</li><li>灰色指自身被标记，成员变量未被标记</li><li>黑色指自身和成员变量皆被标记</li></ul><img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/11.png"><p>最初所有对象均为白色，回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色推入标记工作表中，当回收器从标记工作表弹出对象并访问它的引用对象时，自身由灰色转黑色，并将自身的下一个引用对象转为灰色。直到没有可标记的灰色对象，剩下的所有白色对象都是非活动对象，可等待回收。三色标记法在恢复执行时可以通过内存中是否有灰色节点来判断整个标记流程是否完成，如没有直接进行清理，如有则直接从灰色节点开始继续标记进程，能够很好的配合<code>增量标记</code>执行GC</p><h4>2). 写屏障 - 已标记对象被修改</h4><p>针对上面<code>增量标记</code>中提到的，暂停标记执行JS程序后，已标记对象被修改的问题，V8采用的方案是<code>写屏障</code>。</p><img style="width:600px;" class="center" src="https://zhangmingemma.github.io/dist/images/2022-06-01/12.png"><p>比如例子中<code>B</code>的指向由<code>C</code>改为<code>D</code>，在进行下一次GC时，对象<code>C</code>已经无引用关系了，但它是黑色的，不会在此次GC中被回收，但会在下一轮的GC清理掉。但对象<code>D</code>此时是白色的，已经没有灰色对象，白色对象就会被清理掉，引用关系被回收，导致问题。<code>写屏障</code>的机制，就是一旦有黑色对象引用白色对象，会强制将引用的对象改为灰色，从而保证下一次GC时可以继续正确标记。</p><h3>2. 惰性清理</h3><p><code>增量标记</code>是针对标记过程的优化策略，能够不全停顿阻塞JS执行进程。<code>惰性清理</code>是针对清理过程的，当当前内存足以快速执行代码时，会延迟清理过程，这就是惰性清理。二者结合能够大大减少主线程的停顿时间，让用户与浏览器的交互变得流畅。但并没有减少主线程的停顿总时长，甚至会增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量。</p><h2>四. 并发回收</h2><p>主线程在执行JS的过程中，辅助线程在后台完成回收垃圾的操作，让主线程不被挂起。但缺点是并发回收的过程中，主线程JS逻辑还在执行，对象的引用关系随时都会发生变化，因此需要额外的一些读写锁机制来控制。</p>',35);function o(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n,a,l,i,j])}const r={};r.render=o;t["default"]=r},ef22:function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])('<p>上两篇解释了如何从项目文件夹内读取markdown文件，渲染文章页面，并生成目录树，锚定页面。本篇主要解释的是如何在文章内添加评论，将整个博客项目部署到github，通过github.io进行访问。本系列其他文章：</p><ul><li><a href="https://zhangmingemma.github.io/#/post?file=2021-07-03-Blog%201">Vue3.0搭建博客 (一)：读取文章列表，解析标题信息</a></li><li><a href="https://zhangmingemma.github.io/#/post?file=2021-07-04-Blog%202">Vue3.0搭建博客 (二)：文章html渲染, 抽取目录</a></li></ul><p>博客源码github: <a href="https://github.com/zhangmingemma/zhangmingemma.github.io" target="_blank">博客仓库地址</a></p><h2>1. 文章评论</h2><p>我这边不太想用服务器那一套，不想自己做存储，所以使用的是凹凸实验室开发的<code>gitalk</code>评论体系，它的原理其实是在github仓库内根据<code>id</code>新增issue，发表的评论便是新增的issue回复。指引中关于使用方法，其实说明的已经非常清楚了，这里就不做赘述了~~~</p><p>gitalk源码与指引: <a href="https://github.com/gitalk/gitalk" target="_blank">gitalk源码与指引</a> gitalk示例Demo: <a href="https://gitalk.github.io/" target="_blank">gitalk示例Demo</a></p><h2>2. 部署github</h2>',7),a=Object(c["i"])("ul",null,[Object(c["i"])("li",null,[Object(c["i"])("p",null,[Object(c["h"])("在"),Object(c["i"])("code",null,"vue.config.js"),Object(c["h"])("配置根目录和"),Object(c["i"])("code",null,"index.html"),Object(c["h"])("的文件路径：")]),Object(c["i"])("ul",null,[Object(c["i"])("li",null,[Object(c["h"])("设置"),Object(c["i"])("code",null,"publicPath"),Object(c["h"])("，是因为默认"),Object(c["i"])("code",null,"build"),Object(c["h"])("后的文件内容全部防止在"),Object(c["i"])("code",null,"dist"),Object(c["h"])("文件夹内，包含编译后的"),Object(c["i"])("code",null,"js"),Object(c["h"])("文件、"),Object(c["i"])("code",null,"css"),Object(c["h"])("文件、静态文件、"),Object(c["i"])("code",null,"public"),Object(c["h"])("文件夹下的内容等，因此我们需要将线上环境的根目录指向"),Object(c["i"])("code",null,"/dist"),Object(c["h"])("，这样"),Object(c["i"])("code",null,"index.html"),Object(c["h"])("中引用的"),Object(c["i"])("code",null,"js"),Object(c["h"])("和"),Object(c["i"])("code",null,"css"),Object(c["h"])("的路径才是正确的。")]),Object(c["i"])("li",null,[Object(c["h"])("设置"),Object(c["i"])("code",null,"indexPath"),Object(c["h"])("，是因为"),Object(c["i"])("code",null,"build"),Object(c["h"])("后的"),Object(c["i"])("code",null,"index.html"),Object(c["h"])("默认也是防止在"),Object(c["i"])("code",null,"dist"),Object(c["h"])("文件夹内的，所以部署后访问自己的页面，需要是"),Object(c["i"])("code",null,"zhangmingemma.github.io/dist"),Object(c["h"])("，太丑了，所以我们这边配置后将"),Object(c["i"])("code",null,"index.html"),Object(c["h"])("放在最外层，可以直接访问"),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-built_in"},"module"),Object(c["h"])(".exports = {\n    "),Object(c["i"])("span",{class:"hljs-attr"},"parallel"),Object(c["h"])(": "),Object(c["i"])("span",{class:"hljs-literal"},"false"),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"publicPath"),Object(c["h"])(": process.env.NODE_ENV === "),Object(c["i"])("span",{class:"hljs-string"},'"production"'),Object(c["h"])(" ? "),Object(c["i"])("span",{class:"hljs-string"},'"/dist"'),Object(c["h"])(" : "),Object(c["i"])("span",{class:"hljs-string"},'"/"'),Object(c["h"])(",\n    "),Object(c["i"])("span",{class:"hljs-attr"},"indexPath"),Object(c["h"])(": path.resolve(__dirname, "),Object(c["i"])("span",{class:"hljs-string"},"'index.html'"),Object(c["h"])(")\n}\n")])])])])]),Object(c["i"])("li",null,[Object(c["i"])("p",null,[Object(c["i"])("code",null,"vue-router"),Object(c["h"])("使用hash模式，而非history模式，原因是history模式的路由跳转，会向服务器重新发起页面请求，而GitHub Pages并没有提供服务器，所以我们需要使用hash模式")]),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-javascript"},[Object(c["i"])("span",{class:"hljs-keyword"},"const"),Object(c["h"])(" router = createRouter({\n    "),Object(c["i"])("span",{class:"hljs-attr"},"history"),Object(c["h"])(": createWebHashHistory(),\n    routes\n})\n")])])]),Object(c["i"])("li",null,[Object(c["i"])("p",null,[Object(c["h"])("新建代码仓库"),Object(c["i"])("code",null,"username.github.io"),Object(c["h"])("，将build后包含dist文件夹的代码"),Object(c["i"])("code",null,"push"),Object(c["h"])("到仓库的"),Object(c["i"])("code",null,"gh-pages"),Object(c["h"])("分支，之后就可以访问"),Object(c["i"])("code",null,"https://username.github.io"),Object(c["h"])("，看到自己的博客了。")])]),Object(c["i"])("li",null,[Object(c["i"])("p",null,[Object(c["h"])("这里"),Object(c["i"])("code",null,"markdown"),Object(c["h"])("中我有引用一些存储在"),Object(c["i"])("code",null,"public/images"),Object(c["h"])("目录下的本地图片，在部署之后，markdown没有被webpack解析到内容，所以图片的路径并没有得到转换，访问的是域名根目录，我这里的处理方式是转换为线上地址，本地开发的时候配置代理来访问。如果大家有更好的处理方式可以评论告诉我。我的具体做法是")]),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":"",class:"language-markdown"},"// 原来图片的引用路径\n![](../images/2021-07-03/1.png)\n\n// 修改后图片的引用路径\n![](https://username.github.io/dist/images/2021-07-03/1.png)\n")]),Object(c["i"])("p",null,"本地开发时配置的代理是："),Object(c["i"])("pre",null,[Object(c["i"])("code",{"v-pre":""},"username.github.io/dist/images http://127.0.0.1:8080/images \n")])])],-1);function l(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n,a])}const i={};i.render=l;t["default"]=i},fc13:function(e,t,s){"use strict";s.r(t);var c=s("7a23"),n=Object(c["g"])("<h2>new Vue发生了什么~~~</h2><p><code>src/core/instance/index.js</code></p><ul><li>初始化生命周期</li><li>初始化时间</li><li>初始化渲染</li><li>beforeCreate钩子触发</li><li>初始化State --&gt; 初始化Props,监听props数据变化；初始化Data,监听data数据变化；初始化computed；初始化watch</li><li>created钩子触发</li><li>$mount执行vue挂载</li></ul><h2>vue挂载</h2><p><code>src/platform/web/entry-runtime-with-compiler.js</code>，重定义$mount方法 在Vue2中，所有vue组件模板的页面内容最终都会转换成render方法，这个过程就是”在线编译“的过程，在线编译依赖”compileToFunctions“。</p><p><code>src/core/instance/lifecycle.js</code>，原型上挂载<code>$mount</code>方法</p><ul><li>beforeMount钩子</li><li>初始化Watcher实例，初始化或触发watcher变更时，执行： <ul><li>若_isMounted，则触发beforeUpdate钩子</li><li>生成虚拟DOM</li><li>更新视图</li></ul></li><li>mounted钩子</li></ul>",7);function a(e,t){return Object(c["r"])(),Object(c["e"])("section",null,[n])}const l={};l.render=a;t["default"]=l}});
//# sourceMappingURL=app.562c62dd.js.map